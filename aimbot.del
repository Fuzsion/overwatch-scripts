import "macros.del";
import "aimbotlobby.json";
/* Player Variables */

playervar bool can_aim;         // (bool)   can the player aimbot
playervar bool cancel_aim;      // (bool)   interact override for can_aim
playervar bool is_stealth;      // (bool)   sombra stealth
playervar bool has_target;      // (bool)   does the player have a target?
playervar bool aim_override;    // (bool)   primary/secondary fire hero specific override to prevent locking
playervar bool aim_tgl;         // (bool)   manual aim lock toggle
playervar player target;        // (player) the target player of the player's aimbot
playervar vec offset;           // (vector) offset for targeting
playervar num speed_div;


// --------------------------- //
// ---------- RULES ---------- //
// --------------------------- //

rule: "init"
{
    CreateHudText(host, null, null, <"<0>%", ServerLoad()>, Location.Left, 0, Color.White, Color.White, Color.White, HudTextRev.VisibleToAndString);
    CreateHudText(all, null, null, "ㅤHvH (ESP+Aimbot) | Created by scort#11221", Location.Right, 0, Color.White, Color.White, Color.White, HudTextRev.VisibleTo);
    CreateHudText(all, null, "ㅤv1.0.0 | Code: ? ? ?\n", null, Location.Right, 0.1, Color.White, Color.White, Color.White, HudTextRev.VisibleTo);
}

rule: "player init"
Event.OngoingPlayer
{
    CreateEffect(all, Effect.Sphere, Color.SkyBlue, (EyePosition(target) + target.offset) + WorldVectorOf(Vector(aim_x, aim_y, aim_z), player, LocalVector.Rotation), 0.1);
    DisableNameplates(player, all);
    StartForcingPlayerOutlines(player, all, true, Color.Red, OutlineType.Always);

    CreateHudText(aim_tgl ? player : null, null, null, <"  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLocking">, Location.Top, 1, Color.White, Color.White, Color.White, HudTextRev.VisibleToAndString);

    CreateProgressBarInWorldText(FilteredArray(EnemyPlayers(), !is_stealth && IsAlive()), NormalizedHealth() * 100, null, player, 0, Clipping.DoNotClip, Color.Red);

    CreateInWorldText(FilteredArray(EnemyPlayers(), !is_stealth && IsAlive()), <"<0> <1> | <2>HP <3>", HeroIconString(HeroOf()), player, RoundToInteger(Health()), IsUsingUltimate() 
                                                                                                                                                                        ? "| Using Ultimate" 
                                                                                                                                                                        : UltimateChargePercent() == 100 
                                                                                                                                                                            ? <"| <0>", IconString(Icon.Checkmark)>
                                                                                                                                                                            : <"| <0>%", UltimateChargePercent()>>, player, 0.85, Clipping.DoNotClip);

    CreateHudText(has_target ? player : null, null, null, aim_y, Location.Left, 0,
                    Color.White, Color.White, Color.White, HudTextRev.VisibleToAndString);

    CreateHudText(has_target ? player : null, null, null, <"Current Target: <0> <1>", HeroIconString(HeroOf(target)), target>, Location.Right, 1,
                Color.White, Color.White, Color.White, HudTextRev.VisibleToAndString);

    CreateHudText(has_target ? player : null, null, null, <"Distance: <0>m", Round(DistanceBetween(EyePosition(), EyePosition(target)))>, Location.Right, 2,
                Color.White, Color.White, Color.White, HudTextRev.VisibleToAndString);

}

rule: "Spawned"
Event.OngoingPlayer
if (IsAlive())
{
    is_stealth = false;
    offset = Vector(0, 0.1, 0);
    speed_div = 32;
    aim_tgl = false;
}

rule: "Death"
Event.OnDeath
{
    is_stealth = false;
    can_aim = false;
    has_target = false;
    aim_override = false;
    aim_tgl = false;
}


// --------------------------- //
// -------- AIM LOGIC -------- //
// --------------------------- //

num aim_x: (SpeedOfInDirection(target, WorldVectorOf(Left(), player, LocalVector.Rotation)) / target.speed_div) - (SpeedOfInDirection(player, WorldVectorOf(Left(), player, LocalVector.Rotation)) / speed_div);
// alternate y: Max((VerticalAngleTowards(player, EyePosition(target)) * -1) / (120 - DistanceBetween(EyePosition(), EyePosition(target))), 0),
num aim_y: Max((YOf(EyePosition(target)) - YOf(EyePosition())) / (15 + DistanceBetween(EyePosition(), EyePosition(target))), 0);
num aim_z: (SpeedOfInDirection(target, WorldVectorOf(Forward(), player, LocalVector.Rotation)) / target.speed_div);

rule: "Aim Logic :: welcome to hell"
Event.OngoingPlayer
if (can_aim)
if (!cancel_aim)
if (!aim_override)
{
    if (IsInLineOfSight(player, PlayerClosestToReticle(player, OppositeTeamOf(TeamOf())), BarrierLOS.AllBarriersBlock))
    {
        target = PlayerClosestToReticle(player, OppositeTeamOf(TeamOf()));
    }

    if (!IsDead(target) || !target.is_stealth)
    {
        has_target = true;

        StartFacing(player, VectorTowards(EyePosition(), (EyePosition(target) + target.offset) + WorldVectorOf(Vector(aim_x, aim_y, aim_z), player, LocalVector.Rotation)), 100000, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }

    if (target == player || target == 0 || IsDead(target) || cancel_aim || aim_override || is_stealth || target.is_stealth)
    {
        has_target = false;
        StopFacing();
    }

    Wait(0.25, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

rule: "Aim Logic :: Stop facing events"
Event.OngoingPlayer
if (target == player || target == 0 || is_stealth || cancel_aim || aim_override || IsDead(target) || target.is_stealth)
{
    has_target = false;
    StopFacing();
}


rule: "Aiming (start)"
Event.OngoingPlayer
if (IsButtonHeld(player, Button.PrimaryFire) || IsButtonHeld(player, Button.SecondaryFire) && !cancel_aim)
{
    can_aim = true;
}

rule: "Aiming (stop)"
Event.OngoingPlayer
if (!IsButtonHeld(player, Button.PrimaryFire))
if (!IsButtonHeld(player, Button.SecondaryFire))
if (!aim_tgl)
{
    can_aim = false;
    has_target = false;
    target = 0;
    StopFacing();
}

rule: "Aim Toggle"
Event.OngoingPlayer
if (IsButtonHeld(player, Button.Interact))
if (IsAlive())
{
    if (aim_tgl)
    {
        aim_tgl = false;
    }
    else
    {
        aim_tgl = true;
        can_aim = true;
    }
}


rule: "In air"
Event.OngoingPlayer
if (IsInAir())
{
    offset = Vector(0, 0.3, 0);
}

rule: "On ground"
Event.OngoingPlayer
if (IsOnGround())
{
    offset = Vector(0, 0.1, 0);
}

// ---------------------------- //
// ------ HERO SPECIFICS ------ //
// ---------------------------- //

rule: "Soldier :: Start sprinting"
Event.OngoingPlayer
Player.Soldier76
if (IsUsingAbility1())
{
    cancel_aim = true;
    speed_div = 16;
    //offset = Vector(SpeedOfInDirection(player, WorldVectorOf(Left(), player, LocalVector.Rotation)) / 16, -0.15, 0);
    offset = Vector(0, -0.15, 0);
}

rule: "Soldier :: Stop sprinting"
Event.OngoingPlayer
Player.Soldier76
if (!IsUsingAbility1())
{
    cancel_aim = false;
    speed_div = 32;
    offset = Vector(0, 0.1, 0);
}

rule: "Sombra :: Stealth"
Event.OngoingPlayer
Player.Sombra
if (IsUsingAbility1())
{
    cancel_aim = true;
    is_stealth = true;
}

rule: "Sombra :: Unstealth"
Event.OngoingPlayer
Player.Sombra
if (!IsUsingAbility1())
if (is_stealth)
{
    cancel_aim = false;
    is_stealth = false;
}

rule: "Widowmaker :: In air"
Event.OngoingPlayer
Player.Widowmaker
if (IsInAir())
{
    offset = Vector(0, 0.2, 0);
}

rule: "Widowmaker :: On ground"
Event.OngoingPlayer
Player.Widowmaker
if (IsOnGround())
{
    offset = Vector(0, 0.1, 0);
}

/* Pharah */
rule: "Pharah"
Event.OngoingPlayer
Player.Pharah
if (IsInAir())
{
    offset = Vector(0, 0.45, 0);
}

rule: "Pharah"
Event.OngoingPlayer
Player.Pharah
if (IsOnGround())
{
    offset = Vector(0, 0.1, 0);
}

/* Wrecking Ball */
rule: "Wrecking Ball"
Event.OngoingPlayer
Player.WreckingBall
if (IsUsingAbility1() && IsAlive())
{
    offset = Vector(0, -1, 0);
}

rule: "Wrecking Ball"
Event.OngoingPlayer
Player.WreckingBall
if (!IsUsingAbility1())
{
    offset = Vector(0, 0.1, 0);
}

/* Primary Override */
rule: "Primary Override (start) :: Winston/Rein/Moira"
Event.OngoingPlayer
if (IsAlive())
if (IsButtonHeld(player, Button.PrimaryFire))
if (!aim_override)
{
    if (IsHero(Hero.Winston) || IsHero(Hero.Reinhardt) || IsHero(Hero.Moira))
    {
        cancel_aim = true;
        aim_override = true;
        StopFacing();
    }
}

rule: "Primary Override (end) :: Winston/Rein/Moira"
Event.OngoingPlayer
if (!IsButtonHeld(player, Button.PrimaryFire))
if (aim_override)
{
    if (IsHero(Hero.Winston) || IsHero(Hero.Reinhardt)|| IsHero(Hero.Moira))
    {
        cancel_aim = false;
        aim_override = false;
    }
}


/* Secondary Override */
rule: "Secondary Override (start) :: Dva/Hanzo/Lucio/Bastion/Mercy/Orisa/Baptiste/Reaper/Pharah/Winston/Junk/Tracer/Ball/Rein"
Event.OngoingPlayer
if (IsButtonHeld(player, Button.SecondaryFire)) 
if (!aim_override)
{
    if (IsHero(Hero.Dva) || IsHero(Hero.Hanzo) || IsHero(Hero.Lucio) || IsHero(Hero.Bastion) || IsHero(Hero.Mercy) ||
        IsHero(Hero.Orisa) || IsHero(Hero.Baptiste) || IsHero(Hero.Reaper) || IsHero(Hero.Pharah) || IsHero(Hero.Winston) ||
        IsHero(Hero.Junkrat) || IsHero(Hero.Tracer) || IsHero(Hero.WreckingBall) || IsHero(Hero.Reinhardt))
    {
        cancel_aim = true;
        aim_override = true;
        StopFacing();
    }
}

rule: "Secondary Override (end) :: Dva/Hanzo/Lucio/Bastion/Mercy/Orisa/Baptiste/Reaper/Pharah/Junk/Tracer/Ball"
Event.OngoingPlayer
if (!IsButtonHeld(player, Button.SecondaryFire))
if (aim_override)
{
    if (IsHero(Hero.Dva) || IsHero(Hero.Hanzo) || IsHero(Hero.Lucio) || IsHero(Hero.Bastion) || IsHero(Hero.Mercy) || IsHero(Hero.Orisa) ||
        IsHero(Hero.Baptiste) || IsHero(Hero.Reaper) || IsHero(Hero.Pharah) || IsHero(Hero.Junkrat) || IsHero(Hero.Tracer) || IsHero(Hero.WreckingBall))
    {
        cancel_aim = false;
        aim_override = false;
    }
}


// --------------------------- //
// ------ MISCELLANEOUS ------ //
// --------------------------- //

rule: "[Debug] :: Bots"
if (IsButtonHeld(host, Button.Ultimate) && !IsButtonHeld(host, Button.Crouch))
{
    CreateDummyBot(HeroOf(host), OppositeTeamOf(TeamOf(host)), -1, RayCastHitPosition(EyePosition(host), EyePosition(host) + Facing(host) * 100, null, null, true), Facing(host) * -1);
}
rule: "[Debug] :: Destroy Bots"
if (IsButtonHeld(host, Button.Crouch) && IsButtonHeld(host, Button.Ultimate))
{
    DestroyAllDummyBots();
}