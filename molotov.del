import "macros.del";
import "testSettings.json";

globalvar num S_RADIUS;
globalvar num S_DURATION;
globalvar num S_DAMAGE;
globalvar num S_DOT;
globalvar num S_SPEED;
globalvar num S_GRAV;
globalvar num S_BOUNCE_STRENGTH;
globalvar num S_GROUND_ANGLE;
globalvar bool s_fire;
globalvar bool s_ignore_ground;
globalvar bool s_show_dbg;
globalvar vec proj_grav_vec;
playervar vec vel;
playervar vec proj_pos;
playervar num airtime;
playervar num bounces;
playervar any e_arr;
playervar bool landed;

rule: "init"
{

    s_fire = WorkshopSettingToggle("Damage", "Fire (On)", true, 0);
    S_RADIUS = WorkshopSettingReal("Damage", "Fire Radius (7)", 7, 0.1, 100, 1);
    S_DURATION = WorkshopSettingReal("Damage", "Fire Duration (7)", 7, 0.1, 100, 2);
    S_DOT = WorkshopSettingReal("Damage", "Fire Damage (9)", 9, 0.1, 100, 3);
    S_DAMAGE = WorkshopSettingInteger("Damage", "Explosion Damage (40)", 40, 1, 600, 4);

    S_SPEED = WorkshopSettingReal("Projectile", "Projectile Speed (30)", 30, 0.1, 70, 0);
    S_GRAV = WorkshopSettingReal("Projectile", "Projectile Weight/Gravity (20)", 20, 0, 100, 1);
    S_BOUNCE_STRENGTH = WorkshopSettingReal("Projectile", "Projectile Bounce Strength (2 = Same as the prior bounce | 1 = No bounce) (1.6)", 1.6, 1, 2, 2);
    S_GROUND_ANGLE = WorkshopSettingInteger("Projectile", "Maximum Ground Detection Angle for Projectile Explosion (40)", 40, 1, 180, 3);
    s_ignore_ground = WorkshopSettingToggle("Projectile", "Disable Ground Detection (Off)", false, 4);

    s_show_dbg = WorkshopSettingToggle("Debug", "Show Debug Info", false, 0);

    proj_grav_vec = Vector(0, -S_GRAV, 0);
}

rule: "dbg"
Event.OngoingPlayer
if (s_show_dbg)
{
    CreateHudText(player, null, null, <"landed: <0>", landed>, Location.Left, 0);
    CreateHudText(player, null, null, <"proj_pos: <0>", proj_pos>, Location.Left, 1);
    CreateHudText(player, null, null, <"vel: <0>", vel>, Location.Left, 2);
    CreateHudText(player, null, null, <"airtime: <0>", airtime>, Location.Left, 3);

    CreateBeamEffect(all, BeamType.BadBeam, proj_pos, RayCastHitPosition(proj_pos, proj_pos + (vel * 0.016) * 100, EnemyPlayers(), player, true), Color.White);
}


void DestroyEffects() playervar "destroy now please"
{
    for (num i = 0; i < 4; i++)
    {
        DestroyEffect(e_arr[i]);
    }
}

rule: "proj"
Event.OngoingPlayer
if (IsMeleeing())
{
    if (EntityExists(e_arr))
    {
        DestroyEffects();
    }

    proj_pos = EyePosition();
    vel = Facing() * S_SPEED;
    airtime = 0;
    landed = false;

    vec[] normals = [];
    vec[] hp = [];
    vec[] hp_ricochets = [];
    any[] ricochets = [];

    while (DistanceBetween(proj_pos, RayCastHitPosition(proj_pos, proj_pos + (vel * 0.016) * 100, EnemyPlayers(), player, true)) >= 0.25 + (S_SPEED / 100) && airtime < 5) // did not hit surface
    {
        vel += proj_grav_vec * 0.016; // update vel with grav vector
        proj_pos += vel * 0.016; // update the projectile position with the vel vector
        airtime += 0.016; // 62.5 = ow tickrate, 3750 ticks = 1 second
        PlayEffect(all, PlayEffect.EchoStickyBombExplosionEffect, Color.Team2, proj_pos, 0.1); // effect for the projectile
        MinWait();

        for (num i = 0; i < 4; i++) // i < amount of vectors to store, usually never more than 3
        {
            if (DistanceBetween(proj_pos, RayCastHitPosition(proj_pos, proj_pos + (vel * 0.016) * 100, EnemyPlayers(), player, true)) <= 0.25 + (S_SPEED / 100)) // hit surface? otherwise break
            {
                if (i > 0)
                {
                    proj_pos = hp[i - 1];
                    vel = ricochets[i - 1];
                }

                # https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector/3340378#3340378
                hp[i] = RayCastHitPosition(proj_pos, proj_pos + vel * 100, EnemyPlayers(), player, true); // get hit pos
                normals[i] = RayCastHitNormal(proj_pos, proj_pos + vel * 100, EnemyPlayers(), player, true); // get normal
                ricochets[i] = vel - (S_BOUNCE_STRENGTH * (normals[i] * Dot(vel, normals[i]))); // convert normal to reflection
                hp_ricochets[i] = RayCastHitPosition(hp[i], hp[i] + ricochets[i] * 100, EnemyPlayers(), player, true); // raycast from hit pos to reflection vector

                PlayEffect(all, PlayEffect.BaptisteBioticLauncherExplosionSound, Color.White, proj_pos, 45); // hit sound

                if (!s_ignore_ground && AngleBetweenVectors(normals[i], Up()) < S_GROUND_ANGLE) // breaks the loop if the normal and up vector is within the specified angle
                    break;
            }
            else { break; } // break the loop if no surface is hit
        }
    }

    Damage(PlayersWithinRadius(proj_pos, S_RADIUS, LOSCheck: RadiusLOS.SurfacesAndEnemyBarriers), player, S_DAMAGE);

    // effects n shit
    PlayEffect(all, PlayEffect.AsheDynamiteExplosionEffect, Color.Team1, proj_pos, 0);
    PlayEffect(all, PlayEffect.GoodExplosion, Color.Orange, proj_pos, S_RADIUS);
    PlayEffect(all, PlayEffect.AsheDynamiteExplosionSound, Color.White, proj_pos, 100);
    PlayEffect(all, PlayEffect.AnaBioticGrenadeExplosionSound, Color.White, proj_pos, 45);

    if (s_fire)
    {
        landed = true;
        DestroyEffects();

        CreateEffect(all, Effect.Ring, Color.Orange, proj_pos, S_RADIUS);
        e_arr[0] = LastCreatedEntity();
        CreateEffect(all, Effect.Ring, Color.Red, proj_pos, S_RADIUS);
        e_arr[1] = LastCreatedEntity();
        CreateEffect(all, Effect.Sparkles, Color.Orange, proj_pos, S_RADIUS);
        e_arr[2] = LastCreatedEntity();
        CreateEffect(all, Effect.TorbjornOverloadingSound, Color.White, proj_pos, 60);
        e_arr[3] = LastCreatedEntity();

        Wait(S_DURATION, WaitBehavior.RestartWhenTrue);

        landed = false;
        DestroyEffects();
    }

    airtime = 0;
}

rule: "damage"
Event.OngoingPlayer
if (landed)
{
    SetStatus(
        PlayersWithinRadius(proj_pos, 
                            S_RADIUS, 
                            LOSCheck: RadiusLOS.SurfacesAndEnemyBarriers), player, Status.Burning, 0.30);
    Damage(
        PlayersWithinRadius(proj_pos, 
                            S_RADIUS, 
                            LOSCheck: RadiusLOS.SurfacesAndEnemyBarriers), player, S_DOT);

    WaitIfTrue(0.25); // dumb solution for a 'tick' rate but w/e
    LoopIfConditionIsTrue();
}

// rule: "[Debug] :: Bots"
// if (IsButtonHeld(host, Button.Interact) && !IsButtonHeld(host, Button.Crouch))
// {
//     CreateDummyBot(HeroOf(host), OppositeTeamOf(TeamOf(host)), -1, RayCastHitPosition(EyePosition(host), EyePosition(host) + Facing(host) * 100, null, null, true), Facing(host) * -1);
// }
// rule: "[Debug] :: Destroy Bots"
// if (IsButtonHeld(host, Button.Crouch) && IsButtonHeld(host, Button.Interact))
// {
//     DestroyAllDummyBots();
// }

