import "macros.del";
// import "clonesv2lobby.json";
import "clonesv2lobbydbg.json";
define owner_bots: FilteredArray(AllyPlayers(), IsDummyBot(Curr()) && Curr().owner == player);
define living_bots: FilteredArray(AllLivingPlayers(TeamOf()), IsDummyBot(Curr()) && Curr().owner == player);
define human_player_cnt: CountOf(FilteredArray(AllyPlayers(), !IsDummyBot(Curr()) && HasSpawned(Curr())));

// global
globalvar define DISTANCE; // maximum distance until bot teleports to owner
globalvar define OOS_TIME; // out of los time before teleport
globalvar define TIMER_DUR; // duration of the combat timer
globalvar define RESPAWN_TIME; // respawn time
globalvar define FAILSAFE_TIME; // respawn failsafe time
globalvar define GENJI_DAMAGE;
globalvar define slot_arr; // amount of players and bots per team (from 0 - 5)
globalvar define inspector; // inspector toggle
globalvar define genji_nerf; // bool genji nerf
globalvar define heal_toggle; // bool heal over time

// all
playervar define cced; // bool for cc status is applied
playervar define player_slot; // slot of player to create bots for
playervar define genji_ao; // genji damage modification
playervar define max_health; // maximum health a bot spawned with

// stats
playervar define kills; // amount of kills owner and bots have
playervar define deaths; // amount of deaths owner and bots have
playervar define damage_dealt; // amount of damage owner and bots have done
playervar define damage_taken; // amount of damage owner and bots have taken
playervar define heal_dealt; // amount of healing owner and bots have done
playervar define heal_taken; // amount of healing owner and bots have recieved

// owner
playervar define owner; // player who owns a set of bots
playervar define owner_alive; // whether the owner is alive
playervar define is_rezzing; // checks if the owner is replacing a bot
playervar define new_player; // closest bot to owner upon death
playervar define position_of; // position of the new_player
playervar define facing; // facing direction of the new_player
playervar define health_of; // health of the new_player
playervar define ammo_of; // ammo of new_player
playervar define heal_ot; // heal over time for the owner
playervar define timer; // time out of combat
playervar define attacked; // bool for if bot is attacked
playervar define attack_timer; // attacked timer

// bot
playervar define bot_alive; // bot is alive

globalvar define BOT_AMOUNT;
globalvar define S_BOT_AMOUNT;
globalvar define pf_arr;
globalvar define sf_arr;
globalvar define sfr_arr;
globalvar define a1_arr;
globalvar define a1c_arr;
globalvar define a2_arr;
globalvar define a2c_arr;
globalvar define j_arr;
globalvar define c_arr;

rule: "Initial Global"
{
    DisableInspectorRecording();
    DisableAnnouncer();

    pf_arr = [Hero.Brigitte];
    sf_arr = [Hero.Orisa, Hero.Reinhardt, Hero.Sigma, Hero.WreckingBall, Hero.Doomfist, Hero.Sombra, Hero.Soldier76, Hero.Brigitte, Hero.Lucio];
    sfr_arr = [Hero.Dva, Hero.Bastion];
    a1_arr = [Hero.Soldier76, Hero.Zenyatta, Hero.Bastion, Hero.Tracer, Hero.Symmetra, Hero.Junkrat]; // array of heroes where ability 1 does not have a cooldown or uses charges instead
    a1c_arr = [Hero.Tracer, Hero.Symmetra, Hero.Junkrat];
    a2_arr = [Hero.Brigitte, Hero.Zenyatta]; // array of heroes where ability 2 does not have a cooldown or uses charges instead
    a2c_arr = [Hero.Brigitte];
    j_arr = [Hero.Hanzo];
    c_arr = [Hero.WreckingBall];

    slot_arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    S_BOT_AMOUNT = WorkshopSettingCombo("General", "Team Size (10 is likely to crash the server!)", 1, ["4", "6", "8", "10"], 1);

    if (S_BOT_AMOUNT == 0)
        BOT_AMOUNT = 4;
    else if (S_BOT_AMOUNT == 1)
        BOT_AMOUNT = 6;
    else if (S_BOT_AMOUNT == 2)
        BOT_AMOUNT = 8;
    else if (S_BOT_AMOUNT == 3)
        BOT_AMOUNT = 10;

    TIMER_DUR = WorkshopSettingReal("General", "In Combat Timer (6)", 6, 0, 30, 2);
    RESPAWN_TIME = WorkshopSettingInteger("General", "Bot Respawn Time (15)", 15, 0, 90, 3);
    heal_toggle = WorkshopSettingToggle("General", "Heal Over Time out of combat (On)", true, 4);

    DISTANCE = WorkshopSettingReal("Teleport", "Teleport Distance (12)", 12, 0, 100, 1);
    OOS_TIME = WorkshopSettingReal("Teleport", "Out of LOS Teleport Time (0.25)", 0.25, 0, 5, 2);

    genji_nerf = WorkshopSettingToggle("Genji", "Genji Ability 1 Damage Modification (On)", true, 1);
    GENJI_DAMAGE = WorkshopSettingReal("Genji", "Genji Ability 1 Damage Percentage (33.34)", 33.34, 0, 100, 2);

    CreateHudText(all, null, null, "ㅤMimic | Created by scort#11221", Location.Right, 0.1, Color.White, Color.White, Color.White, HudTextRev.VisibleTo);
    CreateHudText(all, null, "ㅤv1.0.0 | Code: WRYEP", null, Location.Right, 0.2);
    CreateHudText(all, null, " \n\n\n", null, Location.Left, 0.01);
}

rule: "Initial Player Join"
Event.OnPlayerJoin
{
    player_slot = [];
}

rule: "[All] :: Human Init"
Event.OngoingPlayer
if (!IsDummyBot())
{
    owner_alive = true;
}

rule: "[All] :: Assembling Heroes Time"
if (IsAssemblingHeroes())
{
    SetMatchTime(10);
}

rule: "[All] :: cced"
Event.OngoingPlayer
if (HasStatus(player, Status.Asleep) || 
    HasStatus(player, Status.Frozen) || 
    HasStatus(player, Status.KnockedDown) || 
    HasStatus(player, Status.Rooted) || 
    HasStatus(player, Status.Stunned))
{
    cced = true;
}

rule: "[All] :: Not cced"
Event.OngoingPlayer
if (!HasStatus(player, Status.Asleep) && 
    !HasStatus(player, Status.Frozen) && 
    !HasStatus(player, Status.KnockedDown) && 
    !HasStatus(player, Status.Rooted) && 
    !HasStatus(player, Status.Stunned))
{
    cced = false;
}

rule: "[All] :: CC Failsafe" // this is needed because dva getting de-meched and mei using ice block wont set cced to false correctly sometimes
Event.OngoingPlayer
if (cced)
{
    WaitIfTrue(8);
    cced = false;
}

disabled rule: "---------------- Owner Rules ----------------"{}

            /////////////                   /////////////
            /////////////    OWNER RULES    /////////////
            /////////////                   /////////////

rule: "[Owner] :: Create Bots"
Event.OngoingPlayer
if (!IsDummyBot() && HasSpawned() && IsAlive() && 
    (CountOf(FilteredArray(AllyPlayers(), Curr().owner == player && IsDummyBot(Curr()))) 
                                            < Floor((BOT_AMOUNT - CountOf(FilteredArray(AllyPlayers(), !IsDummyBot(Curr()))))
                                            / CountOf(FilteredArray(AllyPlayers(), !IsDummyBot(Curr()) && HasSpawned(Curr()))))))
{
    // divides amount of available slots by the amount of human players
    player_slot = LastOf(FilteredArray(slot_arr, 
                        !EntityExists(PlayersInSlot(Curr(), TeamOf())) || (IsDummyBot(Curr()) && !EntityExists(Curr().owner))));

    CreateDummyBot(HeroOf(), TeamOf(), player_slot, PositionOf() + WorldVectorOf(Vector(0, 0, -0.5), player), FacingDirectionOf());
    PlayersInSlot(player_slot, TeamOf()).owner = player;

    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Owner] :: Destroy Bots"
Event.OngoingPlayer
if (!IsDummyBot() && 
    (CountOf(FilteredArray(AllyPlayers(), Curr().owner == player && IsDummyBot(Curr()))) 
                                            > Floor((BOT_AMOUNT - CountOf(FilteredArray(AllyPlayers(), !IsDummyBot(Curr()) && HasSpawned(Curr()))))
                                            / CountOf(FilteredArray(AllyPlayers(), !IsDummyBot(Curr()) && HasSpawned(Curr()))))))
{
    DestroyDummyBot(TeamOf(), 
                    FirstOf(FilteredArray(slot_arr, 
                                          IsDummyBot(PlayersInSlot(Curr(), TeamOf())) && PlayersInSlot(Curr(), TeamOf()).owner == player && EntityExists(PlayersInSlot(Curr(), TeamOf())))));

    Wait(0.064);
    LoopIfConditionIsTrue();
}

// rule: "[Owner] :: Create Bots"
// Event.OnPlayerJoin
// if (!IsDummyBot())
// {
//     WaitUntil(HasSpawned() && IsAlive(), 999999);

//     while (CountOf(FilteredArray(AllyPlayers(), Curr().owner == player && IsDummyBot(Curr())))
//                                                 < Floor((BOT_AMOUNT - CountOf(FilteredArray(AllyPlayers(), !IsDummyBot(Curr())))))
//                                                 / human_player_cnt)
//     {
//         Wait(0.032);

//         player_slot = LastOf(FilteredArray(slot_arr, !EntityExists(PlayersInSlot(Curr(), TeamOf())) || (IsDummyBot(Curr()) && !EntityExists(Curr().owner))));

//         CreateDummyBot(HeroOf(), TeamOf(), player_slot, PositionOf() + WorldVectorOf(Vector(0, 0, -0.5), player), FacingDirectionOf());
    
//         PlayersInSlot(player_slot, TeamOf()).owner = player;
//     }
// }

// rule: "[Owner] :: Destroy Bots"
// Event.OngoingPlayer
// {

// }

rule: "[Owner] :: Replace Healthiest Bot"
Event.OnDeath
if (!IsDummyBot() && !EventWasEnvironment() && IsTrueForAny(AllLivingPlayers(TeamOf()), Curr().owner == player && IsDummyBot(Curr())))
{
    define bots = owner_bots;
    is_rezzing = true;
    new_player = FilteredArray(AllLivingPlayers(), Curr() != player && Curr().owner == player);
    new_player = LastOf(SortedArray(new_player, NormalizedHealth(Curr())));
    position_of = PositionOf(new_player);
    facing = FacingDirectionOf(new_player);
    health_of = Health(new_player);
    ammo_of[0] = Ammo(new_player, 0);
    ammo_of[1] = Ammo(new_player, 1);
    Kill(new_player);
    Teleport(player, position_of);
    PlayEffect(player, PlayEffect.EchoStickyBombExplosionEffect, Color.Team1, RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 0.8, null, null, true));
    SetFacing(player, facing, Relative.ToWorld);
    SetPlayerHealth(player, health_of);
    SetAmmo(player, 0, ammo_of[0]);
    SetAmmo(player, 1, ammo_of[1]);
    Resurrect();
    MinWait();
    CancelPrimaryAction(bots);
    is_rezzing = false;

    // if (CountOf(FilteredArray(AllDeadPlayers(TeamOf()), IsDummyBot(Curr()) && Curr().owner == player)) == (6 / CountOf(FilteredArray(AllyPlayers(), !IsDummyBot(Curr()) && HasSpawned(Curr())))))
    //     DisableRespawning(bots);
}

rule: "[Owner] :: Start heal_ot"
Event.OngoingPlayer
if (heal_toggle && !IsDummyBot() && timer == 0 && Health() < MaxHealth())
{
    // stop timer
    timer = 0;
    StopChasingVariable(timer);
    StartHealOverTime(player, null, 10000, 10);
    heal_ot = LastHealOverTime();
}

rule: "[Owner] :: Stop heal_ot"
Event.OnDamageTaken
if (heal_toggle && !IsDummyBot() && !IsHero(Hero.Mercy) && !IsHero(Hero.Lucio))
{
    // start timer
    timer = TIMER_DUR;
    StopChasingVariable(timer);
    ChaseVariableAtRate(timer, 0, 1, RateChaseReevaluation.None);
    StopHealOverTime(heal_ot);
}

rule: "[Owner] :: Stop heal_ot if Full HP"
Event.OngoingPlayer
if (timer == 0 && Health() == MaxHealth())
{
    StopHealOverTime(heal_ot);
}

rule: "[Owner] :: Alive"
Event.OngoingPlayer
if (!IsDummyBot() && IsAlive() && !is_rezzing)
{
    owner_alive = true;
}

rule: "[Owner] :: Dead"
Event.OngoingPlayer
if (!IsDummyBot() && IsDead() && !is_rezzing)
{
    owner_alive = false;

    define bots = owner_bots;
    WaitUntil(owner_alive, 9999);
    Respawn(bots);
    EnableRespawning(bots);
}

rule: "[Owner] :: Prevent Bot Spawning"
Event.OngoingPlayer
if (!owner_alive)
{
    define bots = owner_bots;
    DisableRespawning(bots);
}

// FilteredArray(AllDeadPlayers(TeamOf()), IsDummyBot(Curr()) && Curr().owner == player)

rule: "[Owner] :: Kill Bots if Owner falls off Map"
Event.OnDeath
if (!IsDummyBot() && EventWasEnvironment())
{
    define bots = owner_bots;
    Kill(bots);
}

rule: "[Owner] :: Respawn Failsafe"
Event.OngoingPlayer
if (!IsDummyBot() && IsDead() && !is_rezzing)
{
    WaitIfTrue(RESPAWN_TIME + 1);
    Respawn();
}

rule: "[Owner] :: Stun Status On"
Event.OngoingPlayer
if (HasStatus(owner, Status.Stunned) && !HasStatus(player, Status.Stunned))
{
    AbortIf(IsUsingAbility1(owner) && IsHero(Hero.Mei));

    SetStatus(player, null, Status.Stunned, 2.5);
    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Owner] :: Stun Status Off"
Event.OngoingPlayer
if (!HasStatus(owner, Status.Stunned))
{
    ClearStatus(player, Status.Stunned);
}

rule: "[Owner] :: Sleep Status On"
Event.OngoingPlayer
if (HasStatus(owner, Status.Asleep) && !HasStatus(player, Status.Asleep))
{
    SetStatus(player, null, Status.Asleep, 5.5);
    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Owner] :: Sleep Status Off"
Event.OngoingPlayer
if (!HasStatus(owner, Status.Asleep))
{
    ClearStatus(player, Status.Asleep);
}

rule: "[Owner] :: Freeze Status On"
Event.OngoingPlayer
if (HasStatus(owner, Status.Frozen) && !HasStatus(player, Status.Frozen))
{
    SetStatus(player, null, Status.Frozen, 7.35);
    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Owner] :: Freeze Status Off"
Event.OngoingPlayer
if (!HasStatus(owner, Status.Frozen))
{
    ClearStatus(player, Status.Frozen);
}

rule: "[Owner] :: Knockdown Status On"
Event.OngoingPlayer
if (HasStatus(owner, Status.KnockedDown) && !HasStatus(player, Status.KnockedDown))
{
    SetStatus(player, null, Status.KnockedDown, 3);
    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Owner] :: Knockdown Status Off"
Event.OngoingPlayer
if (!HasStatus(owner, Status.KnockedDown))
{
    ClearStatus(player, Status.KnockedDown);
}

rule: "[Owner] :: Hack Status On"
Event.OngoingPlayer
if (HasStatus(owner, Status.Hacked) && !HasStatus(player, Status.Hacked))
{
    SetStatus(player, null, Status.Hacked, 5.5);
    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Owner] :: Hack Status Off"
Event.OngoingPlayer
if (!HasStatus(owner, Status.Hacked))
{
    ClearStatus(player, Status.Hacked);
}

disabled rule: "---------------- Bot Rules ----------------"{}

            /////////////                 /////////////
            /////////////    BOT RULES    /////////////
            /////////////                 /////////////

playervar define clone_effects;
rule: "[Bot] :: Init"
Event.OngoingPlayer
if (IsDummyBot())
if (!IsDuplicating())
{
    for (define i = 0; i < 3; i++)
        DestroyEffect(clone_effects[i]);

    StartForcingDummyBotName(player, <"<0> Clone", owner>);
    SetRespawnMaxTime(player, RESPAWN_TIME);
    SetUltimateAbilityEnabled(player, false);

    Wait(1);
    CreateEffect(all, Effect.EchoCloningEffect, Position: player, Color: Color.White);
    // clone_effects[0] = LastCreatedEntity();
    // CreateEffect(EnemyPlayers(), Effect.EchoCloningEffect, Position: player, Color: Color.Team2);
    // clone_effects[1] = LastCreatedEntity();
    CreateEffect(all, Effect.EchoCloningSound, Position: player, Radius: 20);
    clone_effects[2] = LastCreatedEntity();
}

rule: "[Bot] :: Alive"
Event.OngoingPlayer
if (IsDummyBot())
if (IsAlive())
{
    bot_alive = true;

    EnableRespawning();

    SetWeapon(player, Weapon(owner));
}

rule: "[Bot] :: Dead"
Event.OngoingPlayer
if (IsDummyBot())
if (IsDead())
{
    bot_alive = false;
    attacked = false;
    SetUltimateCharge(player, 0);
    SetUltimateAbilityEnabled(player, false);
}

rule: "[Bot] :: Incorrect Hero"
Event.OngoingPlayer
if (IsDummyBot())
if (!EntityExists(owner) || HeroOf() != HeroOf(owner) || TeamOf() != TeamOf(owner))
{
    Wait(0.080);
    DestroyDummyBot(TeamOf(), SlotOf());
}

rule: "[Bot] :: Enable Ult"
Event.OngoingPlayer
if (IsDummyBot())
if (UltimateChargePercent(owner) == 100)
if (bot_alive)
{
    SetUltimateAbilityEnabled(player, true);
    SetUltimateCharge(player, 100);
    // Wait(0.08);
    // LoopIf(UltimateChargePercent() != 100);
}

rule: "[Bot] :: Disable ult"
Event.OngoingPlayer
if (IsDummyBot())
if (UltimateChargePercent(owner) != 100)
{
    WaitIfTrue(1);
    SetUltimateCharge(player, 0);
    SetUltimateAbilityEnabled(player, false);
}

// rule: "[Bot] :: Bot Ult Charge Failsafe"
// Event.OngoingPlayer
// if (IsDummyBot() && UltimateChargePercent(owner) != 100 && UltimateChargePercent() > 0)
// {
//     WaitIfTrue(3);
//     SetUltimateAbilityEnabled(player, false);
//     SetUltimateCharge(player, 0);
// }

void TeleportBot() playervar "Teleport Sub"
{
    Teleport(player, owner + WorldVectorOf(Vector(0, 0, -0.5), owner));

    AbortIf(IsHero(Hero.Sombra) && IsUsingAbility1());

    PlayEffect(all, PlayEffect.EchoStickyBombExplosionEffect, Color.White, player);
    PlayEffect(all, PlayEffect.TracerRecallDisappearEffect, Color.White, player);
}

rule: "[Bot] :: Owner out of range"
Event.OngoingPlayer
if (bot_alive && IsAlive(owner) && !cced && DistanceBetween(owner, player) > DISTANCE)
{
    TeleportBot();
}

rule: "[Bot] :: Owner out of sight"
Event.OngoingPlayer
if (bot_alive && IsAlive(owner) && !cced && !IsInLineOfSight(owner, player))
{
    WaitIfTrue(OOS_TIME);
    TeleportBot();
}

disabled rule: "---------------- Input Emulation (IE) ----------------"{}

            /////////////                            /////////////
            /////////////    INPUT EMULATION (IE)    /////////////
            /////////////                            /////////////

rule: "[IE] :: Aim & Movement"
Event.OngoingPlayer
if (bot_alive)
{
    StartThrottleInDirection(player, WorldVectorOf(ThrottleOf(owner), owner, LocalVector.Rotation), ThrottleOf(owner) != Vector(0,0,0));

    StartFacing(player, DirectionTowards(EyePosition(),
    RayCastHitPosition(EyePosition(owner), UpdateEveryFrame(EyePosition(owner) + FacingDirectionOf(owner) * 100), AllLivingPlayers(OppositeTeamOf(TeamOf(owner))), AllLivingPlayers(TeamOf(owner)), true)), 
    !cced ? 10000 : 0.001);
}

rule: "[IE] :: Hello"
Event.OngoingPlayer
if (!IsDummyBot() && IsCommunicating(player, Communication.Hello))
{
    define bots = owner_bots;
    Communicate(bots, Communication.Hello);
}

rule: "[IE] :: Weapon 1"
Event.OngoingPlayer
if (!IsDummyBot() && Weapon() == 1)
{
    define bots = owner_bots;
    SetWeapon(bots, 1);
}

rule: "[IE] :: Weapon 2"
Event.OngoingPlayer
if (!IsDummyBot() && Weapon() == 2)
{
    define bots = owner_bots;
    SetWeapon(bots, 2);
}

rule: "[IE] :: Ammo Clip 1"
Event.OngoingPlayer
if (IsTrueForAny(owner_bots, Ammo(player, 0) != Ammo(owner, 0)))
{
    define bots = owner_bots;
    WaitIfTrue(0.25);
    SetAmmo(bots, 0, Ammo(player, 0));
}

rule: "[IE] :: Ammo Clip 2"
Event.OngoingPlayer
if (IsTrueForAny(owner_bots, Ammo(player, 1) != Ammo(owner, 1)))
{
    define bots = owner_bots;
    WaitIfTrue(0.25);
    SetAmmo(bots, 1, Ammo(player, 1));
}

                    // button pressed //

rule: "[IE] :: Pressed Primary"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.PrimaryFire) && IsAlive() && !cced)
{
    StartHoldingButton(living_bots, Button.PrimaryFire);
}

rule: "[IE] :: Pressed Secondary"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.SecondaryFire) && IsAlive() && !cced)
{
    StartHoldingButton(living_bots, Button.SecondaryFire);
}

rule: "[IE] :: Pressed Ability 1"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.Ability1) && IsAlive() && !cced)
{
    StartHoldingButton(living_bots, Button.Ability1);
}

rule: "[IE] :: Pressed Ability 2"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.Ability2) && IsAlive() && !cced)
{
    StartHoldingButton(living_bots, Button.Ability2);
}

rule: "[IE] :: Pressed Jump"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.Jump) && IsAlive() && !cced)
{
    StartHoldingButton(living_bots, Button.Jump);
}

rule: "[IE] :: Pressed Crouch"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.Crouch) && IsAlive() && !cced)
{
    StartHoldingButton(living_bots, Button.Crouch);
}

rule: "[IE] :: Pressed Melee"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.Melee) && IsAlive() && !cced)
{
    StartHoldingButton(living_bots, Button.Melee);
}

rule: "[IE] :: Pressed Reload"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.Reload) && IsAlive() && !cced)
{
    StartHoldingButton(living_bots, Button.Reload);
}

rule: "[IE] :: Pressed Ultimate"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.Ultimate) && IsAlive() && !cced)
{
    StartHoldingButton(living_bots, Button.Ultimate);
}

rule: "[IE] :: Pressed Interact"
Event.OngoingPlayer
if (!IsDummyBot() && IsButtonHeld(player, Button.Interact) && IsAlive())
{
    StartHoldingButton(living_bots, Button.Interact);
}

                        // release //

rule: "[IE] :: Released Primary"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.PrimaryFire) || IsDead() || cced))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.PrimaryFire);
    // SetAbilityCooldown(bots, Button.PrimaryFire, AbilityCooldown(player, Button.PrimaryFire));
}

rule: "[IE] :: Released Secondary"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.SecondaryFire) || IsDead() || cced))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.SecondaryFire);
    // SetAbilityCooldown(bots, Button.SecondaryFire, AbilityCooldown(player, Button.SecondaryFire));
}

rule: "[IE] :: Released Ability 1"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.Ability1) || IsDead() || cced))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.Ability1);
    // SetAbilityCooldown(bots, Button.Ability1, AbilityCooldown(player, Button.Ability1));
}

rule: "[IE] :: Released Ability 2"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.Ability2) || IsDead() || cced))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.Ability2);
    // SetAbilityCooldown(bots, Button.Ability2, AbilityCooldown(player, Button.Ability2));
}

rule: "[IE] :: Released Jump"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.Jump) || IsDead() || cced))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.Jump);
    // SetAbilityCooldown(bots, Button.Jump, AbilityCooldown(player, Button.Jump));
}

rule: "[IE] :: Released Crouch"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.Crouch) || IsDead() || cced))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.Crouch);
    // SetAbilityCooldown(bots, Button.Crouch, AbilityCooldown(player, Button.Crouch));
}

rule: "[IE] :: Released Melee"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.Melee) || IsDead() || cced))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.Melee);
}

rule: "[IE] :: Released Reload"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.Reload) || IsDead() || cced))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.Reload);
}

rule: "[IE] :: Released Ultimate"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.Ultimate) || IsDead() || cced))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.Ultimate);
}

rule: "[IE] :: Released Interact"
Event.OngoingPlayer
if (!IsDummyBot() && (!IsButtonHeld(player, Button.Interact) || IsDead()))
{
    define bots = owner_bots;
    StopHoldingButton(bots, Button.Interact);
    // SetAbilityCooldown(bots, Button.Jump, AbilityCooldown(player, Button.Jump));
}

//                            // cooldowns //

// rule: "[IE] :: Primary Cooldown (Brig)"
//     Event.OngoingPlayer
//     Player.Brigitte
//     if (!IsDummyBot() && !IsFiringPrimary() && IsButtonHeld(player, Button.SecondaryFire) && AbilityCooldown(player, Button.PrimaryFire) != 0)
//     {
//         define bots = owner_bots;
//         SetAbilityCooldown(bots, Button.PrimaryFire, AbilityCooldown(player, Button.PrimaryFire));
//     }

// rule: "[IE] :: Secondary Cooldown"
//     Event.OngoingPlayer
//     if (!IsDummyBot() && !IsFiringSecondary())
//     {
//         define bots = owner_bots;
//         SetAbilityCooldown(bots, Button.SecondaryFire, AbilityCooldown(player, Button.SecondaryFire));
//     }

// rule: "[IE] :: Ability 1 Cooldown"
//     Event.OngoingPlayer
//     if (!IsDummyBot() && !IsUsingAbility1())
//     {
//         define bots = owner_bots;
//         SetAbilityCooldown(bots, Button.Ability1, AbilityCooldown(player, Button.Ability1));
//     }

// rule: "[IE] :: Ability 2 Cooldown"
//     Event.OngoingPlayer
//     if (!IsDummyBot() && !IsUsingAbility2())
//     {
//         define bots = owner_bots;
//         SetAbilityCooldown(bots, Button.Ability2, AbilityCooldown(player, Button.Ability2));
//     }

disabled rule: "---------------- HUD Text ----------------"{}

            /////////////                /////////////
            /////////////    HUD TEXT    /////////////
            /////////////                /////////////

rule: "[HUD] :: Update Kills"
Event.OnFinalBlow
{
    (owner == null ? player : owner).kills++;
}

rule: "[HUD] :: Update Deaths"
Event.OnDeath
if (!is_rezzing)
{
    (owner == null ? player : owner).deaths++;
}

rule: "[HUD] :: Update Damage Dealt"
Event.OnDamageDealt
if (Victim() != player)
{
    (owner == null ? player : owner).damage_dealt += Round(EventDamage());
}

rule: "[HUD] :: Update Damage Recieved"
Event.OnDamageTaken
if (Attacker() != player)
{
    (owner == null ? player : owner).damage_taken += Round(EventDamage());
}

rule: "[HUD] :: Update Heal Dealt"
Event.OnHealingDealt
if (Healee() != player)
{
    (owner == null ? player : owner).heal_dealt += Round(EventHealing());
}

rule: "[HUD] :: Update Heal Recieved"
Event.OnHealingTaken
if (Healer() != player)
{
    (owner == null ? player : owner).heal_taken += Round(EventHealing());
}

rule: "[HUD] :: Bot Under Attack"
Event.OnDamageTaken
if (IsDummyBot())
{
    attacked = true;
    attack_timer = TIMER_DUR;
    StopChasingVariable(attack_timer);
    ChaseVariableAtRate(attack_timer, 0, 1, RateChaseReevaluation.None);
}

rule: "[HUD] :: Bot Attack Timer End"
Event.OngoingPlayer
if (IsDummyBot() && attack_timer == 0)
{
    attacked = false;
    timer = 0;
    StopChasingVariable(timer);
}

rule: "[HUD] :: Stats"
Event.OngoingPlayer
if (!IsDummyBot())
{
    // Wait(1.5);
    CreateHudText(player, null,
    <" \n<0><1><2><3><4><5>",
    <"Kills: <0>\n", kills>, 
    <"Deaths: <0>\n", deaths>, 
    <"Damage Dealt: <0>\n", damage_dealt>, 
    <"Damage Taken: <0>\n", damage_taken>, 
    heal_dealt != 0 ? <"Healing Dealt: <0>\n", heal_dealt> : "", 
    heal_taken != 0 ? <"Healing Taken: <0>\n", heal_taken> : "">, 
    null, 
    Location.Left, 15, Color.White, Color.White, Color.White);
}

define percentage: (NormalizedHealth() * 100);
define r: (percentage <= 75) ? 255 : Floor(256 - (percentage - 50) * 5.12);
define g: (percentage >= 75) ? 255 : Floor(percentage * 5.12);
define healthColor: CustomColor(r, g, 0, 255);

// define healthColor: Colors.Gradient(new ComponentColor(Color.Red), new ComponentColor(Color.Green), NormalizedHealth());

rule: "[HUD] :: Bot Stats"
Event.OngoingPlayer
if (IsDummyBot() && HasSpawned())
{
    // MaxHealth() updates dynamically, using a variable lets me get around this. this will break when echo clones someone or if dva is out of mech
    max_health = MaxHealth();

    CreateHudText(owner, 
    Header:         HeroIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf()),
    Subheader:      <"<0><1><2><3><4><5><6><7><8>",
    ArrayContains(a1c_arr, HeroOf()) || 
    ArrayContains(a1c_arr, HeroBeingDuplicated()) ?
    AbilityCharge(player, Button.Ability1) > 0 ? <"<0><1> ", AbilityIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf(), Button.Ability1), AbilityCharge(player, Button.Ability1)> : " 0 " : "",

    !ArrayContains(a1_arr, HeroOf()) && 
    !ArrayContains(a1_arr, HeroBeingDuplicated()) ? 
    <"<0>", AbilityCooldown(player, Button.Ability1) != 0 ? <" <0> ", Round(AbilityCooldown(player, Button.Ability1))> : AbilityIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf(), Button.Ability1)> : "",

    ArrayContains(a2c_arr, HeroOf()) || 
    ArrayContains(a2c_arr, HeroBeingDuplicated()) ?
    AbilityCharge(player, Button.Ability2) > 0 ? <" <0><1> ", AbilityIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf(), Button.Ability2), AbilityCharge(player, Button.Ability2)> : "  0 " : "",

    !ArrayContains(a2_arr, HeroOf()) &&
    !ArrayContains(a2_arr, HeroBeingDuplicated()) ? 
    <" <0>", AbilityCooldown(player, Button.Ability2) != 0 ? <" <0> ", Round(AbilityCooldown(player, Button.Ability2))> : AbilityIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf(), Button.Ability2)> : "",

    (ArrayContains(sf_arr, HeroOf())) || 
    (ArrayContains(sf_arr, HeroBeingDuplicated())) || 
    (!IsDuplicating() && IsHero(Hero.Echo)) ?
    <" <0>", AbilityCooldown(player, Button.SecondaryFire) != 0 ? <" <0> ", Round(AbilityCooldown(player, Button.SecondaryFire))> : AbilityIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf(), Button.SecondaryFire)> : "",

    ArrayContains(sfr_arr, HeroOf()) || 
    ArrayContains(sfr_arr, HeroBeingDuplicated()) ?
    <" <0><1> ", AbilityIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf(), Button.SecondaryFire), Round(AbilityResource(player, Button.SecondaryFire))> : "",

    ArrayContains(pf_arr, HeroOf()) || 
    ArrayContains(pf_arr, HeroBeingDuplicated()) ?
    <" <0>", AbilityCooldown(player, Button.PrimaryFire) != 0 ? <" <0> ", Round(AbilityCooldown(player, Button.PrimaryFire))> : AbilityIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf(), Button.PrimaryFire)> : "",

    ArrayContains(j_arr, HeroOf()) ||
    ArrayContains(j_arr, HeroBeingDuplicated()) ?
    <" <0>", AbilityCooldown(player, Button.Jump) != 0 ? <" <0> ", Round(AbilityCooldown(player, Button.Jump))> : AbilityIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf(), Button.Jump)> : "",

    ArrayContains(c_arr, HeroOf()) ||
    ArrayContains(c_arr, HeroBeingDuplicated()) ?
    <" <0>", AbilityCooldown(player, Button.Crouch) != 0 ? <" <0>", Round(AbilityCooldown(player, Button.Crouch))> : AbilityIconString(IsDuplicating() ? HeroBeingDuplicated() : HeroOf(), Button.Crouch)> : "">, 

    Text:           IsAlive() ? <"<2><0> HP <1>", Ceiling(Health()), attacked ? IconString(Icon.Warning) : "", IsDuplicating() ? <"<0> ", AbilityIconString(Hero.Echo, Button.Ultimate)> : ""> : "Dead",
    Location:       Location.Left, 
    SortOrder:      SlotOf() + 1, 
    HeaderColor:    (Health() > max_health) && !IsDuplicating()
                        ? Color.Blue
                        : healthColor, 
    SubheaderColor: Color.White, 
    TextColor:      (Health() > max_health) && !IsDuplicating()
                        ? Color.Blue
                        : healthColor, 
    Reevaluation:   HudTextRev.VisibleToSortOrderStringAndColor);
}

disabled rule: "---------------- Hero Specifics (HS) ----------------"{}
            /////////////                           /////////////
            /////////////    HERO SPECIFICS (HS)    /////////////
            /////////////                           /////////////

// rule: "[HS] :: Sombra Disable Ability 2"
// Event.OngoingPlayer
// Player.Sombra
// if (IsDummyBot())
// {
//     DisableAbility2();
// }

rule: "[HS] :: Sombra Stealth After Bot Spawns"
Event.OngoingPlayer
Player.Sombra
if (IsDummyBot() && IsAlive() && IsUsingAbility1(owner))
{
    PressButton(player, Button.Ability1);
}

rule: "[HS] :: Sombra Unstealth Bots"
Event.OngoingPlayer
Player.Sombra
if (!IsUsingAbility1(owner) && IsUsingAbility1())
{
    PressButton(player, Button.Ability1);
}

rule: "[HS] :: Mei Cancel Ice Block" // gross fix fuck you blizzard
Event.OngoingPlayer
Player.Mei
if (!IsDummyBot() && !IsUsingAbility1())
{
    define bots = living_bots;
    CancelPrimaryAction(bots);
}

rule: "[HS] :: Mei Ice Block After Bot Spawns"
Event.OngoingPlayer
Player.Mei
if (IsUsingAbility1(owner) && bot_alive && !IsUsingAbility1())
{
    PressButton(player, Button.Ability1);
    Wait(0.16);
    LoopIfConditionIsTrue();
}

rule: "[HS] :: Baptiste Reload Fix"
Event.OngoingPlayer
Player.Baptiste
if (IsDummyBot() && (Ammo(player, 0) == 0 || Ammo(player, 1) == 0))
{
    // why do i have to do this blizzard
    PressButton(player, Button.Reload);
}

rule: "[HS] :: Reaper Cancel TP if bot failed"
Event.OngoingPlayer
Player.Reaper
if (!IsDummyBot() && !IsUsingAbility2())
{
    define bots = living_bots;
    CancelPrimaryAction(bots);
}

rule: "[HS] :: Genji On"
Event.OngoingPlayer
Player.Genji
if (genji_nerf && IsUsingAbility1())
{
    StartDamageModification(EnemyPlayers(), player, GENJI_DAMAGE);
    genji_ao = LastDamageModificationID();
}

rule: "[HS] :: Genji Off"
Event.OngoingPlayer
Player.Genji
if (!IsUsingAbility1())
{
    StopDamageModification(genji_ao);
}

rule: "[HS] :: Echo Clone"
Event.OngoingPlayer
Player.Echo
if (IsDuplicating())
{
    for (define i = 0; i < 3; i++)
        DestroyEffect(clone_effects[i]);
}

disabled rule: "---------------- Debug ----------------"{}

            /////////////             /////////////
            /////////////    DEBUG    /////////////
            /////////////             /////////////

rule: "[DBG] :: Inspector Toggle"
if (IsButtonHeld(host, Button.Melee) && IsButtonHeld(host, Button.Interact))
{
    inspector = !inspector;
    if (inspector)
    {
        SmallMessage(host, "Inspector enabled");
        EnableInspectorRecording();
    }
    else
    {
        SmallMessage(host, "Inspector disabled");
        DisableInspectorRecording();
    }
}

// rule: "[DBG] :: Aim Effect"
// Event.OngoingPlayer
// {
//     CreateEffect(owner, Effect.Sphere, Color.Red, RayCastHitPosition(EyePosition(), EyePosition() + FacingDirectionOf() * 100, AllLivingPlayers(OppositeTeamOf(TeamOf())), AllyPlayers(), true), 0.1);
//     CreateEffect(player, Effect.Sphere, Color.Blue, RayCastHitPosition(EyePosition(), EyePosition() + FacingDirectionOf() * 100, AllLivingPlayers(OppositeTeamOf(TeamOf())), AllyPlayers(), true), 0.2);
// }

// rule: "[DBG] :: CC All Bots"
// Event.OngoingPlayer
// if (!IsDummyBot() && IsInteractHeld())
// {
//     SetStatus(FilteredArray(AllPlayers(), IsDummyBot(Curr())), null, Status.Stunned, 5);
// }

// rule: "[DBG] :: CC Owner Bots"
// Event.OngoingPlayer
// if (!IsDummyBot() && IsInteractHeld())
// {
//     SetStatus(owner_bots, null, Status.Asleep, 5);
// }

// rule: "[DBG] :: CC"
// Event.OngoingPlayer
// if (!IsDummyBot() && IsInteractHeld())
// {
//     SetStatus(player, null, Status.Asleep, 12);
// }

// rule: "[DBG] :: Kill All Bots"
// Event.OngoingPlayer
// if (!IsDummyBot() && IsInteractHeld())
// {
//     Kill(FilteredArray(AllPlayers(), IsDummyBot(Curr())));
// }

// rule: "[DBG] :: Kill Owner Bots"
// Event.OngoingPlayer
// if (!IsDummyBot() && IsInteractHeld())
// {
//     Kill(owner_bots);
// }

// rule: "[DBG] :: Kill"
// Event.OngoingPlayer
// if (!IsDummyBot() && IsInteractHeld())
// {
//     Kill();
// }

// rule: "[DBG] :: Kill All"
// Event.OngoingPlayer
// if (!IsDummyBot() && IsInteractHeld())
// {
//     Kill(all);
// }

rule: "[DBG] :: Ult"
Event.OngoingPlayer
if (!IsDummyBot() && IsInteractHeld())
{
    SetUltimateCharge(player, 100);
}

// rule: "[DBG] :: Kill Team 2"
// Event.OngoingPlayer
// if (IsButtonHeld(host, Button.Interact))
// {
//     Kill(PlayersInSlot(0, Team.Team2));
//     MinWait();
//     Kill(FilteredArray(AllPlayers(Team.Team2), IsDummyBot(Curr()) && Curr().owner == player));
// }

// rule: "[DBG] :: Damage"
// Event.OngoingPlayer
// if (/* !IsDummyBot() &&  */IsInteractHeld())
// {
//     Damage(player, player, 25);
// }

rule: "[DBG] :: Server Stats"
{
    CreateHudText(host, null, null, "Server Load", Location.Right, 21);
    CreateHudText(host, null, "Cur", <"<0>%", Round(ServerLoad() / 2.55)>, Location.Right, 22, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
    CreateHudText(host, null, "Avg", <"<0>%", Round(ServerLoadAverage() / 2.55)>, Location.Right, 23, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
    CreateHudText(host, null, "Peak", <"<0>%", Round(ServerLoadPeak() / 2.55)>, Location.Right, 24, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
    CreateHudText(host, null, null, "Entity/Text Count", Location.Right, 25);
    CreateHudText(host, null, "Ent", EntityCount(), Location.Right, 26, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
    CreateHudText(host, null, "Txt", TextCount() - 7, Location.Right, 27, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
}

// rule: "[DBG] :: HUD"
// Event.OngoingPlayer
// if (!IsDummyBot())
// {

//     CreateHudText(player, null, null, <"is_rezzing: <0>", is_rezzing>, Location.Right, 1.1);
//     CreateHudText(player, null, null, <"cced: <0>", cced>, Location.Right, 1.2);
//     CreateHudText(player, null, null, <"owner_alive: <0>", owner_alive>, Location.Right, 1.3);
//     CreateHudText(player, null, null, <"timer: <0>\n", timer>, Location.Right, 1.4);
//     MinWait();

//     CreateHudText(player, null, null, <"Holding PrimaryFire: <0>", IsButtonHeld(player, Button.PrimaryFire)>, Location.Right, 1.6);
//     CreateHudText(player, null, null, <"IsFiringPrimary(): <0>\n", IsFiringPrimary()>, Location.Right, 1.7);

//     CreateHudText(player, null, null, <"Holding SecondayFire: <0>", IsButtonHeld(player, Button.SecondaryFire)>, Location.Right, 1.8);
//     CreateHudText(player, null, null, <"IsFiringSecondary(): <0>\n", IsFiringSecondary()>, Location.Right, 1.9);

//     CreateHudText(player, null, null, <"Holding Ability1: <0>", IsButtonHeld(player, Button.Ability1)>, Location.Right, 2);
//     CreateHudText(player, null, null, <"IsUsingAbility1(): <0>\n", IsUsingAbility1()>, Location.Right, 2.1);
//     MinWait();

//     CreateHudText(player, null, null, <"Holding Ability2: <0>", IsButtonHeld(player, Button.Ability2)>, Location.Right, 2.2);
//     CreateHudText(player, null, null, <"IsUsingAbility2(): <0>\n", IsUsingAbility2()>, Location.Right, 2.3);

//     CreateHudText(player, null, null, <"Holding Jump: <0>", IsButtonHeld(player, Button.Jump)>, Location.Right, 2.4);
//     CreateHudText(player, null, null, <"IsJumping(): <0>\n", IsJumping()>, Location.Right, 2.5);

//     CreateHudText(player, null, null, <"Holding Crouch: <0>", IsButtonHeld(player, Button.Crouch)>, Location.Right, 2.6);
//     CreateHudText(player, null, null, <"IsCrouching(): <0>\n", IsCrouching()>, Location.Right, 2.7);
//     MinWait();

//     CreateHudText(player, null, null, <"Holding Melee: <0>", IsButtonHeld(player, Button.Melee)>, Location.Right, 2.8);
//     CreateHudText(player, null, null, <"IsMeleeing(): <0>\n", IsMeleeing()>, Location.Right, 2.9);

//     CreateHudText(player, null, null, <"Holding Reload: <0>", IsButtonHeld(player, Button.Reload)>, Location.Right, 3);
//     CreateHudText(player, null, null, <"IsReloading(): <0>", IsReloading()>, Location.Right, 3.1);
//     }
