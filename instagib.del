import "macros.del";
import "instagibSettings.json";

// bhop
playervar define bhopSpeed;
playervar define speedAccumInAir;
playervar define isChasing;

// primary
playervar define primaryHit;
playervar define primaryStartPos;
// playervar define primaryBeam;

// secondary
playervar define secondaryHit;
playervar define secondaryEyePos;
playervar define secondaryOrb;
playervar define secondaryStartPos;

// grapple
playervar define grappleEyePos;
playervar define grappleBeamEffect;
playervar define usingGrapple;
playervar define grappleHit;
playervar define grappleHitSphere;
playervar define grapplePlayerBeamEffect;
playervar define grappleHitPlayer;
playervar define grappleHitPlayerSphere;

// misc
playervar define livingEnemies;

// constants :: bhop
globalvar define BHOP_MAX_SPEED;
globalvar define BHOP_SPEED_RATE;

// constants :: grapple
globalvar define GRAPPLE_PULL_SPEED;

// constants :: secondary
globalvar define SECONDARY_PROJECTILE_SPEED;

// constants: misc
globalvar define MATCH_TIME_LIMIT;

// toggle
globalvar define matchStarted;

// dodge
globalvar define DODGE_FORCE;
playervar define throttleOf;
playervar define canDodge;

/////////////////////
/////// buffs ///////
/////////////////////

// global :: workshop settings
globalvar define buffsEnabled;
globalvar define buffsSpawnImmediately;
// global
globalvar define validBuffMap;
globalvar define buffEffect;
globalvar define buffPos;
globalvar define buffIcon;
globalvar define cdText;
// player
playervar define hudText;
playervar define lifeKills;
playervar define spreeInWorld;
playervar define spreeEffects;
playervar define spreeHud;
playervar define killsHud;

//// wallbang ////

// global :: workshop settings
globalvar define spawnWallbang;
globalvar define spawnWithWallbang;
globalvar define wallbangDbg;
// global :: constants
globalvar define NUM_WALLBANGS;
globalvar define WALLBANG_DUR;
globalvar define WALLBANG_CD;
// global
globalvar define canPickupWallbang;
globalvar define wallbangCD;
globalvar define wallbangUser;
// player
playervar define wallbangEffect;
playervar define wallbangEnabled;
playervar define wallbangDur;
playervar define wallbangBuffEffect;
playervar define wbDbgEffects;
playervar define wbDbgBeam;

//// ricochet ////

// global :: workshop settings
globalvar define spawnRicochet;
globalvar define spawnWithRicochet;
globalvar define ricochetDbg;
// global :: constants
globalvar define NUM_RICOCHETS;
globalvar define RICOCHET_CD;
globalvar define RICOCHET_DUR;
// global
globalvar define canPickupRicochet;
globalvar define ricochetCD;
globalvar define ricochetUser;
// player
playervar define ricochetEnabled;
playervar define ricochetDur;
playervar define ricochetBuffEffect;
playervar define rDbgEffects;
playervar define rDbgBeam;

// logic

playervar define eyePos;
playervar define facing;

//// buckshot ////

// global :: workshop settings
globalvar define spawnBuckshot;
globalvar define spawnWithBuckshot;
// globalvar define randomSpread;
globalvar define buckshotDbg;
// global :: constants
globalvar define BUCKSHOT_SPREAD;
globalvar define BUCKSHOT_CD;
globalvar define BUCKSHOT_DUR;
// global
globalvar define canPickupBuckshot;
globalvar define buckshotCD; 
globalvar define buckshotUser;
// player
playervar define buckshotHitPos;
playervar define buckshotHitPlayer;
playervar define buckshotCenter;
playervar define buckshotEnabled;
playervar define buckshotDur;
playervar define buckshotBuffEffect;
playervar define bDbgEffects;
playervar define bDbgBeam;
// logic
globalvar define spreadDiag;
globalvar define spreadHori;
// playervar define randomizedSpreadHori;
// playervar define randomizedSpreadDiag;

//// extra life ////

// global :: workshop settings
globalvar define spawnLife;
globalvar define spawnWithLife;
// global :: constants
globalvar define LIFE_CD;
// global
globalvar define canPickupLife;
globalvar define lifeCD;
// player
playervar define extraLife;
playervar define extraLifeIcon;
playervar define lifeBuffEffect;

/////////////////////////////////////////////////////////////////////////////// todo + notes: ///////////////////////////////////////////////////////////////////////////////
//  todo:
//  general optimizations
//  fix buff cooldown in-world text disappearing upon player leaving, internal timer doesnt break, only the in-world text
//  drop whichever buff(s) the player has upon death (orb(s) will only be up for 20 seconds, then will disappear then use the normal cooldown at its map determined spot)
//  option for extra lives to "stack"
//  new buff: wallbang and ricochet properties all within shotgun pellets; will work on this once i figure out a more efficient spread
//  randomize weapon buff map locations upon match start
//  improve secondary fire (use UpdateEveryFrame())
//
//  world events, lasts for 30 seconds, and has a 3 minute cooldown
//
//  faster fire rate (not sure how i'll do this)
//  low grav
//  wallhacks
//  explosive secondary
//  melee enabled
//  
//  notes:
//  dont use EntityExists() with effects
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

disabled rule: "---------------- Main ----------------"{}

rule: "[Main] :: Initial Global"
    {
        DisableInspectorRecording();
        DisableCompletion();
        DisableAnnouncer();

        CreateHudText(all, null, "Instagib: | Created by scort#11221ㅤ", " v1.8.0 | Share Code: APPPXㅤ", Location.Right, 0);
        CreateHudText(all, null, null, " ", Location.Right, 0.1);

        cdText = [];
        buffEffect = [];
        buffPos = [];
        buffIcon = [];
        telePos = [];

        matchStarted = false;

        BHOP_MAX_SPEED = WorkshopSettingInteger("BHop", "​Maximum Speed Possible From Hops (100 = bhops off) (320)", 320, 100, 10000, 1);
        BHOP_SPEED_RATE = WorkshopSettingReal("BHop", "​​Speed gain rate (12.5)", 12.5, 1, 100, 2);

        buffsSpawnImmediately = WorkshopSettingToggle("Buff General", "​Buffs Spawn Immediately When Match Starts (Off)", false, 1);
        buffsEnabled = WorkshopSettingToggle("Buff General", "​​Spawn Buffs and Teleporters (On)", true, 2);

        NUM_WALLBANGS = WorkshopSettingInteger("Wallbang Settings", "​Wallbang Amount (5)", 5, 2, 100, 1);
        WALLBANG_CD = WorkshopSettingInteger("Wallbang Settings", "​​Wallbang Spawn Time (65)", 65, 1, 500, 2);
        WALLBANG_DUR = WorkshopSettingInteger("Wallbang Settings", "​​​Wallbang Duration (25)", 25, 1, 500, 3);
        spawnWallbang = WorkshopSettingToggle("Wallbang Settings", "​​​​Spawn Wallbang (On)", true, 4);
        spawnWithWallbang = WorkshopSettingToggle("Wallbang Settings", "​​​​​Spawn With Wallbang (Lasts Forever) (Off)", false, 5);

        RICOCHET_CD = WorkshopSettingInteger("Ricochet Settings", "​Ricochet Spawn Time (55)", 55, 1, 500, 1);
        RICOCHET_DUR = WorkshopSettingInteger("Ricochet Settings", "​​Ricochet Duration (30)", 30, 1, 500, 2);
        NUM_RICOCHETS = WorkshopSettingInteger("Ricochet Settings", "​​​Ricochet Amount (4)", 4, 1, 32, 3);
        spawnRicochet = WorkshopSettingToggle("Ricochet Settings", "​​​​Spawn Ricochet (On)", true, 4);
        spawnWithRicochet = WorkshopSettingToggle("Ricochet Settings", "​​​​​Spawn With Ricochet (Lasts Forever) (Off)", false, 5);

        BUCKSHOT_CD = WorkshopSettingInteger("Buckshot Settings", "​Buckshot Spawn Time (85)", 85, 1, 500, 1);
        BUCKSHOT_DUR = WorkshopSettingInteger("Buckshot Settings", "​​Buckshot Duration (20)", 20, 1, 500, 2);
        BUCKSHOT_SPREAD = WorkshopSettingReal("Buckshot Settings", "​​​Buckshot Spread (Lower is Tighter) (3.5)", 3.5, 0.1, 20, 2);
        // randomSpread = WorkshopSettingToggle("Buckshot Settings", "​​​​Randomized Buckshot Spread (Off)", false, 3);
        spawnBuckshot = WorkshopSettingToggle("Buckshot Settings", "​​​​​Spawn Buckshot (On)", true, 4);
        spawnWithBuckshot = WorkshopSettingToggle("Buckshot Settings", "​​​​​Spawn With Buckshot (Lasts Forever) (Off)", false, 5);

        LIFE_CD = WorkshopSettingInteger("Extra Life Settings", "​Extra Life Spawn Time (140)", 140, 1, 500, 1);
        spawnLife = WorkshopSettingToggle("Extra Life Settings", "​​Spawn Extra Life (On)", true, 2);
        spawnWithLife = WorkshopSettingToggle("Extra Life Settings", "​​​Spawn With Extra Life (Off)", false, 3);

        // REDEEMER_CD = WorkshopSettingInteger("Redeemer Settings", "​Redeemer Spawn Time (240)", 240, 1, 500, 1);
        // REDEEMER_DUR = WorkshopSettingInteger("Redeemer Settings", "​​Redeemer Duration (20)", 20, 1, 500, 2);
        // spawnRedeemer = WorkshopSettingToggle("Redeemer Settings", "​​​​​Spawn Redeemer (On)", true, 3);
        // spawnWithRedeemer = WorkshopSettingToggle("Redeemer Settings", "​​​​​Spawn With Redeemer (Lasts Forever) (Off)", false, 4);

        MATCH_TIME_LIMIT = WorkshopSettingInteger("Miscellaneous", "​Match Time (Minutes) (20)", 20, 1, 60, 1) * 60;
        GRAPPLE_PULL_SPEED = WorkshopSettingReal("Miscellaneous", "​​Grapple Pull Speed (3.5)", 3.5, 0.5, 10, 2);
        SECONDARY_PROJECTILE_SPEED = WorkshopSettingInteger("Miscellaneous", "​​​Secondary Projectile Speed (110)", 110, 10, 500, 3);
        DODGE_FORCE = WorkshopSettingReal("Miscellaneous", "​​​​​Dodge Force (14)", 14, 1, 100, 4);

        wallbangDbg = WorkshopSettingToggle("Debug", "Show Wallbang Hits", false, 1);
        ricochetDbg = WorkshopSettingToggle("Debug", "Show Ricochet Hits", false, 2);
        buckshotDbg = WorkshopSettingToggle("Debug", "Show Buckshot Hits", false, 3);

        if (!buffsEnabled)
        {
            spawnWallbang = false;
            spawnRicochet = false;
            spawnBuckshot = false;
            spawnLife = false;
        }
    }

rule: "[Main] :: Player Join"
    Event.OnPlayerJoin
    {
        DisallowButton(player, Button.Ability1);
        DisallowButton(player, Button.Ability2);

        wallbangDur = WALLBANG_DUR;
        ricochetDur = RICOCHET_DUR;
        buckshotDur = BUCKSHOT_DUR;
        // redeemerDur = REDEEMER_DUR;

        hudText = [];
        spreeInWorld = [];
        spreeEffects = [];

        PreloadHero(player, Hero.Mccree); // no idea if this will actually do anything
    }

rule: "[Main] :: Start Match"
    if (!matchStarted && CountOf(AllLivingPlayers()) > 0 && !IsWaitingForPlayers())
    {
        SetMatchTime(10);
        Wait(10.5);
        SetMatchTime(MATCH_TIME_LIMIT);
        matchStarted = true;

        if (validBuffMap && !buffsSpawnImmediately && buffsEnabled && !IsWaitingForPlayers())
        {
            WallbangCooldown();
            RicochetCooldown();
            BuckshotCooldown();
            LifeCooldown();
            // RedeemerCooldown();
        }

        if (buffsEnabled && validBuffMap)
        {
            if (!spawnWithWallbang && spawnWallbang)
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Baptiste, Button.Ultimate)>, null, 
                wallbangCD != 0 ? <"<0>", RoundToInteger(wallbangCD, Rounding.Up)> : canPickupWallbang ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", wallbangUser>, 
                Location.Left, 1, Color.Yellow);
            
            if (!spawnWithRicochet && spawnRicochet)
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Winston, Button.Ability1)>, null,
                ricochetCD != 0 ? <"<0>", RoundToInteger(ricochetCD, Rounding.Up)> : canPickupRicochet ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", ricochetUser>,
                Location.Left, 2, Color.Purple);

            if (!spawnWithBuckshot && spawnBuckshot)
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Ashe, Button.Ability1)>, null,
                buckshotCD != 0 ? <"<0>", RoundToInteger(buckshotCD, Rounding.Up)> : canPickupBuckshot ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", buckshotUser>,
                Location.Left, 3, Color.Green);

            if (!spawnWithLife && spawnLife)
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Mercy, Button.Ability2)>, null, 
                lifeCD != 0 ? <"<0>", RoundToInteger(lifeCD, Rounding.Up)> : <"<0>", IconString(Icon.Checkmark)>, 
                Location.Left, 4, Color.SkyBlue);

            // if (!spawnWithRedeemer && spawnRedeemer)
            // {
            //     CreateHudText(all, null, null, " ", Location.Left, 5);
            //     CreateHudText(all, <"<0>", IconString(Icon.Skull)>, null,
            //     redeemerCD != 0 ? <"<0>", RoundToInteger(redeemerCD, Rounding.Up)> : canPickupRedeemer ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", redeemerUser>,
            //     Location.Left, 6, Color.Blue);
            // }
        }
    }

rule: "[Main] :: Player Spawned"
    Event.OngoingPlayer
    if (HasSpawned() && matchStarted)
    {
        SmallMessage(player, "Welcome!");
        Wait(3);
        SmallMessage(player, <"Holding down <0> will let you gain speed by bunny hopping", InputBindingString(Button.Jump)>);
        Wait(3);
        SmallMessage(player, <"Press <0> to throw out a grappling hook to pull you towards a surface or to pull players towards you", InputBindingString(Button.Ability2)>);
        Wait(3);
        SmallMessage(player, <"Press <0> to fire a projectile that knocks players back, including yourself allowing for extra mobility", InputBindingString(Button.SecondaryFire)>);
        Wait(3);
        SmallMessage(player, <"Press <0> to dodge in any direction", InputBindingString(Button.Ability1)>);
        Wait(3);
        SmallMessage(player, "Buffs are littered thorughout the map that give you special changes to your weapon");
    }

rule: "[Main] :: Speedometer"
    Event.OngoingPlayer
    {
        CreateHudText(player, null, null, <" \n<0> M/S\n<1>% Modifier", HorizontalSpeedOf(), RoundToInteger(bhopSpeed - 100, Rounding.Up)>, Location.Left, 10);
    }

rule: "[Main] :: End Game"
    if (matchStarted && MatchTime() == 0)
    {
        EnableCompletion();
    }

rule: "[Main] :: Primary Effect"
    Event.OngoingPlayer
    if (!wallbangEnabled && !ricochetEnabled && !buckshotEnabled && IsFiringPrimary())
    {
        define primaryBeam = [];
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
        primaryStartPos = WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        primaryHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, livingEnemies, player);
        
        // PlayEffect(player, PlayEffect.GoodExplosion, Color.Aqua, EyePosition() + Facing() + primaryStartPos, 0.2);
        // PlayEffect(RemoveFromArray(EnemyPlayers(), player), PlayEffect.GoodExplosion, Color.Red, EyePosition() + Facing() + primaryStartPos, 0.2);

        PlayEffect(player, PlayEffect.GoodExplosion, Color.Aqua, primaryHit, 0.2);
        PlayEffect(RemoveFromArray(EnemyPlayers(), player), PlayEffect.GoodExplosion, Color.Red, primaryHit, 0.2);

        CreateBeamEffect(player, BeamType.BadBeam, EyePosition() + Facing() + primaryStartPos, primaryHit, Color.Aqua, EffectRev.None);
        primaryBeam[0] = LastCreatedEntity();
        CreateBeamEffect(RemoveFromArray(EnemyPlayers(), player), BeamType.BadBeam, EyePosition() + Facing() + primaryStartPos, primaryHit, Color.Red, EffectRev.None);
        primaryBeam[1] = LastCreatedEntity();

        Wait(0.15);
        DestroyEffect(primaryBeam[0]);
        DestroyEffect(primaryBeam[1]);
    }


disabled rule: "---------------- Killing Spree Notifs ----------------"{}

rule: "[Killspree] :: Record Kills While Alive"
    Event.OnFinalBlow
    {
        lifeKills++;
    }

rule: "[Killspree] :: Reset Kills on death"
    Event.OnDeath
    {
        DestroyHudText(killsHud);

        if (lifeKills > 5)
        {
            BigMessage(all, !EventWasEnvironment() ? <"<0>'s <1> player spree was ended by <2>!", Victim(), lifeKills, Attacker()> : 
                                                       <"<0>'s <1> player spree was ended by the world!", Victim(), lifeKills>);
            SmallMessage(player, <"<0> player kill spree!", lifeKills>);
        }

        for (define i = 0; i < 7; i++)
        {
            DestroyEffect(spreeEffects[i]);
            DestroyInWorldText(spreeInWorld[i]);
            DestroyHudText(spreeHud[i]);
        }

        Wait(0.032);
        lifeKills = 0;
        spreeInWorld = [];
        spreeEffects = [];
        spreeHud = [];
    }

// @wang - could probably use a subroutine on these killspree rules
// ^ maybe
rule: "[Killspree] :: Killing Spree"
    Event.OnFinalBlow
    if (lifeKills == 6)
    {
        BigMessage(all, <"<0> is on a Killing Spree!", player>);
        CreateInWorldText(player, "Killing Spree!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.White);
        spreeInWorld[0] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.White, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[0] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Killing Spree", Location.Left, 15, Color.White, Color.White, Color.White);
        spreeHud[0] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[0]);
    }

rule: "[Killspree] :: Rampage"
    Event.OnFinalBlow
    if (lifeKills == 8)
    {
        DestroyEffect(spreeEffects[0]);
        DestroyHudText(spreeHud[0]);
        BigMessage(all, <"<0> is on a Rampage!", player>);
        CreateInWorldText(player, "Rampage!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.LimeGreen);
        spreeInWorld[1] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.LimeGreen, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[1] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Rampage", Location.Left, 15, Color.White, Color.White, Color.LimeGreen);
        spreeHud[1] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[1]);
    }

rule: "[Killspree] :: Dominating"
    Event.OnFinalBlow
    if (lifeKills == 11)
    {
        DestroyEffect(spreeEffects[1]);
        DestroyHudText(spreeHud[1]);
        BigMessage(all, <"<0> is Dominating!", player>);
        CreateInWorldText(player, "Dominating!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.SkyBlue);
        spreeInWorld[2] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.SkyBlue, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[2] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Dominating", Location.Left, 15, Color.White, Color.White, Color.SkyBlue);
        spreeHud[2] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[2]);
    }

rule: "[Killspree] :: Unstoppable"
    Event.OnFinalBlow
    if (lifeKills == 14)
    {
        DestroyEffect(spreeEffects[2]);
        DestroyHudText(spreeHud[2]);
        BigMessage(all, <"<0> is Unstoppable!", player>);
        CreateInWorldText(player, "Unstoppable!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Purple);
        spreeInWorld[3] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Purple, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[3] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Unstoppable", Location.Left, 15, Color.White, Color.White, Color.Purple);
        spreeHud[3] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[3]);
    }

rule: "[Killspree] :: Godlike"
    Event.OnFinalBlow
    if (lifeKills == 17)
    {
        DestroyEffect(spreeEffects[3]);
        DestroyHudText(spreeHud[3]);
        BigMessage(all, <"<0> is Godlike!", player>);
        CreateInWorldText(player, "Godlike!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Yellow);
        spreeInWorld[4] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Yellow, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[4] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Godlike", Location.Left, 15, Color.White, Color.White, Color.Yellow);
        spreeHud[4] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[4]);
    }

rule: "[Killspree] :: Divine"
    Event.OnFinalBlow
    if (lifeKills == 21)
    {
        DestroyEffect(spreeEffects[4]);
        DestroyHudText(spreeHud[4]);
        BigMessage(all, <"<0> is Divine!", player>);
        CreateInWorldText(player, "Divine!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Orange);
        spreeInWorld[5] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Orange, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[5] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Divine", Location.Left, 15, Color.White, Color.White, Color.Orange);
        spreeHud[5] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[5]);
    }

rule: "[Killspree] :: Empyreal"
    Event.OnFinalBlow
    if (lifeKills == 24)
    {
        DestroyEffect(spreeEffects[5]);
        DestroyHudText(spreeHud[5]);
        BigMessage(all, <"<0> is Empyreal!", player>);
        CreateInWorldText(player, "Empyreal!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Red);
        spreeInWorld[6] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Red, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[6] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Empyreal", Location.Left, 15, Color.White, Color.White, Color.Red);
        spreeHud[6] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[6]);
    }

disabled rule: "---------------- Bhop ----------------"{}

rule: "[Bhop] :: Auto Hop"
    Event.OngoingPlayer
    if (IsOnGround() && IsJumpHeld())
    {
        DisableJump();
        Wait();
        AllowJump();
    }

rule: "[Bhop] :: Starting Speed"
    Event.OngoingPlayer
    {
        bhopSpeed = 100;
    }

rule: "[Bhop] :: If Airborne"
    Event.OngoingPlayer
    if ((!usingGrapple && IsJumping() && HorizontalSpeedOf() > 5.14) || (usingGrapple && IsInAir() && DistanceBetween(grappleEyePos, grappleHit) < 40))
    {
        speedAccumInAir = HorizontalSpeedOf();
        Wait(0.05);
        ChaseVariableAtRate(bhopSpeed, BHOP_MAX_SPEED, BHOP_SPEED_RATE, RateChaseReevaluation.DestinationAndRate);

        isChasing = true;
    }

rule: "[Bhop] :: Update Speed"
    Event.OngoingPlayer
    if (isChasing)
    {
        speedAccumInAir = HorizontalSpeedOf();
        SetMoveSpeed(player, bhopSpeed);
        Wait(0.032);
        LoopIfConditionIsTrue();
    }

rule: "[Bhop] :: Update isChasing"
    Event.OngoingPlayer
    if (isChasing && bhopSpeed == BHOP_MAX_SPEED || bhopSpeed == 100)
    {
        StopChasingVariable(bhopSpeed);
        isChasing = false;
    }

rule: "[Bhop] :: Stop chasing if too slow"
    Event.OngoingPlayer
    if (!usingGrapple && (isChasing || bhopSpeed == BHOP_MAX_SPEED) && HorizontalSpeedOf() < 5.14)
    {
        StopChasingVariable(bhopSpeed);
        isChasing = false;
        bhopSpeed = 100;
        SetMoveSpeed(player, bhopSpeed);
        Wait(0.032);
        LoopIfConditionIsTrue();
    }

rule: "[Bhop] :: Stop if player is on ground"
    Event.OngoingPlayer
    if ((IsOnGround() && !usingGrapple) && (bhopSpeed > 100))
    {
        WaitIfTrue(0.2);
        StopChasingVariable(bhopSpeed);
        bhopSpeed = 100;
        // ChaseVariableAtRate(bhopSpeed, 100, 325, RateChaseReevaluation.DestinationAndRate);
        // isChasing = true;
        SetMoveSpeed(player, bhopSpeed);
    }

disabled rule: "---------------- Dodge ----------------"{}

rule: "[Dodge] :: Action"
    Event.OngoingPlayer
    if (canDodge && IsAbility1Held())
    {
        throttleOf = ThrottleOf() + Vector(0, 0.5, 0);

        if (throttleOf == Vector(0, 0.5, 0))
            throttleOf = Vector(0, 0.5, 1);

        ApplyImpulse(player, throttleOf, DODGE_FORCE, Relative.ToPlayer, ContraryMotion.Cancel);

        if (bhopSpeed < 120)
            bhopSpeed += BHOP_SPEED_RATE * 3;

        canDodge = false;
    }

rule: "[Dodge] :: On Ground"
    Event.OngoingPlayer
    if (IsOnGround())
    {
        canDodge = true;
    }


disabled rule: "---------------- Secondary Fire ----------------"{}

playervar define secondaryInAir;
rule: "[Secondary Fire] :: Projectile"
    Event.OngoingPlayer
    if (matchStarted && IsSecondaryHeld() && IsAlive())
    {
        DestroyEffect(secondaryOrb);
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
        secondaryHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, livingEnemies, player);
        secondaryEyePos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;

        secondaryInAir = true;
        PlayEffect(all, PlayEffect.RingExplosionSound, Color.White, player, 50);

        // projectile
        CreateEffect(all, Effect.Orb, Color.Red, secondaryEyePos, 0.1);
        secondaryOrb = LastCreatedEntity();

        ChaseVariableAtRate(secondaryEyePos, secondaryHit, SECONDARY_PROJECTILE_SPEED, RateChaseReevaluation.DestinationAndRate);

        Wait(0.75);
        LoopIfConditionIsTrue();
    }

rule: "[Secondary Fire] :: Impulse"
    Event.OngoingPlayer
    if (DistanceBetween(secondaryEyePos, secondaryHit) < 0.1 || RayCastHitPlayer(EyePosition(), secondaryEyePos, AllLivingPlayers(), player) != null)
    {
        secondaryInAir = false;
        StopChasingVariable(secondaryEyePos);
        define players = FilteredArray(AllLivingPlayers(), DistanceBetween(Curr(), secondaryEyePos) <= 4.5);
        for (define loop = 0; CountOf(players); 1)
        {
            ApplyImpulse(players[loop], DirectionTowards(secondaryEyePos, players[loop] + Vector(0, YOf(EyePosition(players[loop])- players[loop]) / 2, 0) + Up()), 15, Relative.ToWorld, ContraryMotion.Incorporate);
        }
        
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Red, secondaryHit, 2.5);
        // PlayEffect(VisibleTo: all, Type: PlayEffect.RingExplosionSound, Position: player, Radius: 15);
        DestroyEffect(secondaryOrb);
    }

rule: "[Secondary Fire] :: Effect Loop"
    Event.OngoingPlayer
    if (secondaryInAir)
    {
        while (secondaryInAir)
        {
            PlayEffect(all, PlayEffect.BadExplosion, Color.Red, secondaryEyePos, 0.05);
            Wait(0.016);
        }
    }

disabled rule: "---------------- Grapple ----------------"{}
playervar define grappleBeam;
playervar define grappleSphere;

rule: "[Grapple] :: Grapple Start"
    Event.OngoingPlayer
    if (matchStarted && IsAbility2Held() && IsAlive())
    {
        grappleSphere = [];
        grappleBeam = [];
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
        grappleHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 40, livingEnemies, player);
        grappleHitPlayer = RayCastHitPlayer(EyePosition(), EyePosition() + Facing() * 40, livingEnemies, player, true);
        grappleEyePos = EyePosition();

        if (grappleHitPlayer)
        {
            CreateBeamEffect(all, BeamType.GrappleBeam, player, grappleHitPlayer, Color.Yellow, EffectRev.VisibleToPositionAndRadius);
            grappleBeam[0] = LastCreatedEntity();
            
            if (DistanceBetween(grappleEyePos, grappleHit) != 40)
            {
                CreateEffect(all, Effect.Sphere, Color.Yellow, grappleHitPlayer, 0.2);
                grappleSphere[0] = LastCreatedEntity();
            }
        }
        else 
        {
            CreateBeamEffect(all, BeamType.GrappleBeam, player, grappleHit, Color.Yellow, EffectRev.VisibleToPositionAndRadius);
            grappleBeam[0] = LastCreatedEntity();
            
            if (DistanceBetween(grappleEyePos, grappleHit) != 40)
            {
                CreateEffect(all, Effect.Sphere, Color.Yellow, grappleHit, 0.2);
                grappleSphere[0] = LastCreatedEntity();
            }
        }

        usingGrapple = true;

        if (DistanceBetween(grappleEyePos, grappleHit) == 40)
        {
            Wait(0.25);
            usingGrapple = false;
            DestroyEffect(grappleSphere[0]);
            DestroyEffect(grappleSphere[1]);
            DestroyEffect(grappleBeam[0]);
            DestroyEffect(grappleBeam[1]);
            // StopForcingThrottle();
        }
        else
        {
            PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, grappleHit, 0.2);
            PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, player, 0.33);
            PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 100);
        }

        Wait(0.5);
        LoopIf(IsAbility2Held() && IsAlive() && DistanceBetween(grappleEyePos, grappleHit) == 40);
    }

rule: "[Grapple] :: Pull"
    Event.OngoingPlayer
    if (usingGrapple && DistanceBetween(grappleEyePos, grappleHit) < 40)
    {
        ForceThrottle(player, 0, 0.05, 0, 0.05, 0, 0.05);

        if (grappleHitPlayer && IsAlive(grappleHitPlayer))
            ApplyImpulse(grappleHitPlayer, Vector(0, 0.3, 0) + DirectionTowards(grappleHitPlayer, EyePosition()), GRAPPLE_PULL_SPEED / 1.25, Relative.ToWorld, ContraryMotion.Incorporate);
        else if (IsJumpHeld()) 
            ApplyImpulse(player, Vector(0, 0.3, 0) + DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);
        else
            ApplyImpulse(player, DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);

        Wait(0.064);
        LoopIfConditionIsTrue();
    }

rule: "[Grapple] :: Grapple End"
    Event.OngoingPlayer
    if ((!IsAbility2Held() || IsDead() || IsDead(grappleHitPlayer)) || (!IsInLineOfSight(player, grappleHitPlayer) || !IsInViewAngle(player, grappleHitPlayer, 105)) || usingTele)
    {
        usingGrapple = false;
        StopForcingThrottle();
        DestroyEffect(grappleSphere[0]);
        DestroyEffect(grappleSphere[1]);
        DestroyEffect(grappleBeam[0]);
        DestroyEffect(grappleBeam[1]);
    }

rule: "[Grapple] :: !usingGrapple"
    Event.OngoingPlayer
    if (!usingGrapple)
    {
        DestroyEffect(grappleSphere[0]);
        DestroyEffect(grappleSphere[1]);
        DestroyEffect(grappleBeam[0]);
        DestroyEffect(grappleBeam[1]);
        StopForcingThrottle();
    }

rule: "[Grapple] :: On Death: Destroy Effects"
    Event.OnDeath
    {
        usingGrapple = false;
        DestroyEffect(grappleSphere[0]);
        DestroyEffect(grappleSphere[1]);
        DestroyEffect(grappleBeam[0]);
        DestroyEffect(grappleBeam[1]);
        StopForcingThrottle();
    }

disabled rule: "---------------- Buff + Tele ----------------"{}

void WallbangCooldown() globalvar "[Sub] :: Wallbang Cooldown"
    {
        if (!spawnWithWallbang && spawnWallbang)
        {
            wallbangCD = WALLBANG_CD;
            CreateInWorldText(all, <"<0>", RoundToInteger(wallbangCD, Rounding.Up)>, buffPos[0], 2, Clipping.ClipAgainstSurfaces);
            cdText[0] = LastTextID();
            ChaseVariableAtRate(wallbangCD, 0, 1, RateChaseReevaluation.None);
        }
    }

void RicochetCooldown() globalvar "[Sub] :: Ricochet Cooldown"
    {
        if (!spawnWithRicochet && spawnRicochet)
        {
            ricochetCD = RICOCHET_CD;
            CreateInWorldText(all, <"<0>", RoundToInteger(ricochetCD, Rounding.Up)>, buffPos[1], 2, Clipping.ClipAgainstSurfaces);
            cdText[1] = LastTextID();
            ChaseVariableAtRate(ricochetCD, 0, 1, RateChaseReevaluation.None);
        }
    }

void BuckshotCooldown() globalvar "[Sub] :: Buckshot Cooldown"
    {
        if (!spawnWithBuckshot && spawnBuckshot)
        {
            buckshotCD = BUCKSHOT_CD;
            CreateInWorldText(all, <"<0>", RoundToInteger(buckshotCD, Rounding.Up)>, buffPos[2], 2, Clipping.ClipAgainstSurfaces);
            cdText[2] = LastTextID();
            ChaseVariableAtRate(buckshotCD, 0, 1, RateChaseReevaluation.None);
        }
    }

void LifeCooldown() globalvar "[Sub] :: Life Cooldown"
    {
        if (!spawnWithLife && spawnLife)
        {
            lifeCD = LIFE_CD;
            CreateInWorldText(all, <"<0>", RoundToInteger(lifeCD, Rounding.Up)>, buffPos[3], 2, Clipping.ClipAgainstSurfaces);
            cdText[3] = LastTextID();
            ChaseVariableAtRate(lifeCD, 0, 1, RateChaseReevaluation.None);
        }
    }

// void RedeemerCooldown() globalvar "[Sub] :: Redeemer Cooldown"
//     {
//         if (!spawnWithRedeemer && spawnRedeemer)
//         {
//             redeemerCD = REDEEMER_CD;
//             CreateInWorldText(all, <"<0>", RoundToInteger(redeemerCD, Rounding.Up)>, buffPos[4], 2, Clipping.ClipAgainstSurfaces);
//             cdText[4] = LastTextID();
//             ChaseVariableAtRate(redeemerCD, 0, 1, RateChaseReevaluation.None);
//         }
//     }


rule: "[Buff] :: Player With Buff Doesn't Exist"
    Event.OnPlayerLeave
    {
        if ((!EntityExists(wallbangUser) && !EntityExists(buffEffect[0]) && wallbangUser != null) && !spawnWithWallbang)
        {
            wallbangUser.wallbangEnabled = false;
            wallbangUser.wallbangDur = 0;
            Wait(1);
            WallbangCooldown();
        }

        if ((!EntityExists(ricochetUser) && !EntityExists(buffEffect[1]) && ricochetUser != null) && !spawnWithRicochet)
        {
            ricochetUser.ricochetEnabled = false;
            ricochetUser.ricochetDur = 0;
            Wait(1);
            RicochetCooldown();
        }

        if ((!EntityExists(buckshotUser) && !EntityExists(buffEffect[2]) && buckshotUser != null) && !spawnWithBuckshot)
        {
            buckshotUser.buckshotEnabled = false;
            buckshotUser.buckshotDur = 0;
            Wait(1);
            BuckshotCooldown();
        }

        // if ((!EntityExists(redeemerUser) && !EntityExists(buffEffect[4]) && redeemerUser != null) && !spawnWithRedeemer)
        // {
        //     redeemerUser.redeemerEnabled = false;
        //     redeemerUser.redeemerDur = 0;
        //     Wait(1);
        //     RedeemerCooldown();
        // }
    }

rule: "[Buff + Tele] :: Map Locations"
    {
        
        // [0]: wallbang
        // [1]: bullet bouncy bouncy go go
        // [2]: buckshot
        // [3]: extra 'life'
        // [4]: redeemer

        // teles:
        // [0] -> [1]
        // [1] -> [0]
        // [2] -> [3]
        // [3] -> [2]

        validBuffMap = false;

        switch (buffsEnabled)
        {
            case (CurrentMap() == Map.Workshop_Chamber || CurrentMap() == Map.Workshop_Expanse || CurrentMap() == Map.Workshop_Expanse_Night || CurrentMap() == Map.Workshop_Island || CurrentMap() == Map.Workshop_Island_Night):
                validBuffMap = true;
                buffPos[0] = Vector(0, 1, 2);
                buffPos[1] = Vector(0, 1, -2);
                buffPos[2] = Vector(0, 1, -6);
                buffPos[3] = Vector(0, 1, 6);
                buffPos[4] = Vector(12, 1, 0);

                telePos[0] = Vector(19, 2, 0);
                telePos[1] = Vector(-19, 2, 0);
                telePos[2] = Vector(0, 2, 19);
                telePos[3] = Vector(0, 2, -19);
                break;
            case (CurrentMap() == Map.Black_Forest || CurrentMap() == Map.Black_Forest_Winter):
                validBuffMap = true;
                buffPos[0] = Vector(16.79, 12.44, 29.48);
                buffPos[1] = Vector(4.66, 18.28, 5.00);
                buffPos[2] = Vector(16.18, 12.36, -20.11);
                buffPos[3] = Vector(-25.49, 13.09, 5.00);
                buffPos[4] = Vector(21.00, 10.00, 5.00);

                telePos[0] = Vector(-29.00, 13.98, 5.00);
                telePos[1] = Vector(29.09, 11.00, 5.00);
                telePos[2] = Vector(19.84, 19.07, 38.53);
                telePos[3] = Vector(20.34, 19.07, -27.57);
                break;
            case (CurrentMap() == Map.Blizzard_World || CurrentMap() == Map.Blizzard_World_Winter):
                validBuffMap = true;
                buffPos[0] = Vector(-32.50, 0.61, 73.15);
                buffPos[1] = Vector(-77.28, 5.88, 66.15);
                buffPos[2] = Vector(-54.50, 0.61, 110.20);
                buffPos[3] = Vector(-67.55, 1.75, 138.74);
                buffPos[4] = Vector(-25.04, 1.29, 109.95);

                telePos[0] = Vector(-30.01, -0.21, 148.68);
                telePos[1] = Vector(-80.46, 6.88, 63.05);
                telePos[2] = Vector(-13.32, 3.92, 89.04);
                telePos[3] = Vector(-101.22, 2.75, 90.24);
                break;
            case (CurrentMap() == Map.Castillo):
                validBuffMap = true;
                buffPos[0] = Vector(-106.18, 40.56, 43.20);
                buffPos[1] = Vector(-128.20, 35.38, 63.40);
                buffPos[2] = Vector(-100.35, 40.56, 73.75);
                buffPos[3] = Vector(-74.82, 33.00, 52.93);
                buffPos[4] = Vector(-85.65, 39.64, 55.00);

                telePos[0] = Vector(-112.58, 34.61, 22.57);
                telePos[1] = Vector(-99.91, 35.74, 93.71);
                telePos[2] = Vector(-131.30, 36.38, 63.91);
                telePos[3] = Vector(-70.64, 34.51, 52.10);
                break;
            case (CurrentMap() == Map.Chateau_Guillard || CurrentMap() == Map.Chateau_Guillard_Halloween):
                validBuffMap = true;
                buffPos[0] = Vector(206.31, 9.03, 101.90);
                buffPos[1] = Vector(206.31, 9.00, 61.91);
                buffPos[2] = Vector(180.60, 10, 101.93);
                buffPos[3] = Vector(206.19, 1, 77.96);
                buffPos[4] = Vector(229.12, 14.00, 61.97);

                telePos[0] = Vector(206.25, 2, 84.50);
                telePos[1] = Vector(205.46, 10, 48.77);
                telePos[2] = Vector(165.75, 7, 81.00);
                telePos[3] = Vector(238.63, 4, 90.23);
                break;
            case (CurrentMap() == Map.Dorado):
                validBuffMap = true;
                buffPos[0] = Vector(115.66, 8.73, -7.08);
                buffPos[1] = Vector(85.30, 13.75, 29.84);
                buffPos[2] = Vector(98.04, 19.01, 15.26);
                buffPos[3] = Vector(131.27, 12.05, 26.12);
                buffPos[4] = Vector(76.87, 9.00, 7.34);

                telePos[0] = Vector(137.98, 13.05, 28.00);
                telePos[1] = Vector(81.34, 8.70, -5.31);
                telePos[2] = Vector(85.19, 16.30, 40.64);
                telePos[3] = Vector(130.89, 11.02, -26.94);
                break;
            case (CurrentMap() == Map.Ecopoint_Antarctica || CurrentMap() == Map.Ecopoint_Antarctica_Winter):
                validBuffMap = true;
                buffPos[0] = Vector(1.66, 12.63, -25.00);
                buffPos[1] = Vector(-19.50, 13.00, 0.00);
                buffPos[2] = Vector(1.66, 12.63, 25.00);
                buffPos[3] = Vector(20.50, 10.00, 0.00);
                buffPos[4] = Vector(18.70, 5.00, 0.00);

                telePos[0] = Vector(23.36, 5.00, 0);
                telePos[1] = Vector(-35.11, 11.00, 0);
                telePos[2] = Vector(12.20, 10.16, -54.15);
                telePos[3] = Vector(12.20, 10.18, 54.15);
                break;
            case (CurrentMap() == Map.Eichenwalde || CurrentMap() == Map.Eichenwalde_Halloween):
                validBuffMap = true;
                buffPos[0] = Vector(55.70, 22.00, -67.84);
                buffPos[1] = Vector(58.33, 5.72, -90.39);
                buffPos[2] = Vector(76.03, 11.69, -109.66);
                buffPos[3] = Vector(88.13, 13.67, -67.39);
                buffPos[4] = Vector(30.76, 15.00, -81.88);

                telePos[0] = Vector(89.16, 14.83, -63.61);
                telePos[1] = Vector(36.43, 14.72, -106.73);
                telePos[2] = Vector(35.92, 6.93, -63.80);
                telePos[3] = Vector(105.89, 14.72, -110.79);
                break;
            case (CurrentMap() == Map.Havana):
                validBuffMap = true;
                buffPos[0] = Vector(9.50, 7.00, -79.23);
                buffPos[1] = Vector(37.64, 11.00, -94.23);
                buffPos[2] = Vector(27.92, 13.00, -61.96);
                buffPos[3] = Vector(64.50, 13.00, -83.33);
                buffPos[4] = Vector(40.74, 6.82, -83.33);

                telePos[0] = Vector(-1.84, 8, -79.20);
                telePos[1] = Vector(66.15, 8, -83.20);
                telePos[2] = Vector(34.05, 8, -59.83);
                telePos[3] = Vector(30.60, 6, -102.45);
                break;
            case (CurrentMap() == Map.Hollywood || CurrentMap() == Map.Hollywood_Halloween):
                validBuffMap = true;
                buffPos[0] = Vector(-11.91, 2.73, -74.64);
                buffPos[1] = Vector(-4.09, 2.60, -15.87);
                buffPos[2] = Vector(20.67, 2.60, -51.82);
                buffPos[3] = Vector(7.87, 13.90, -48.38);
                buffPos[4] = Vector(18.51, 5.69, -28.41);

                telePos[0] = Vector(-1.17, 3.60, -83.00);
                telePos[1] = Vector(16.14, 3.75, -8.47);
                telePos[2] = Vector(-25.64, 7.75, -37.56);
                telePos[3] = Vector(53.00, 4.75, -57.91);
                break;
            case (CurrentMap() == Map.Kings_Row || CurrentMap() == Map.Kings_Row_Winter):
                validBuffMap = true;
                buffPos[0] = Vector(-49.46, 1.00, 2.69);
                buffPos[1] = Vector(-31.19, 10.00, -13.40);
                buffPos[2] = Vector(-93.67, 8.50, -29.38);
                buffPos[3] = Vector(-48.85, 10.12, -37.62);
                buffPos[4] = Vector(-92.15, 2.10, 7.65);

                telePos[0] = Vector(-33.63, 1.86, -24.44);
                telePos[1] = Vector(-99.90, 3.01, -8.52);
                telePos[2] = Vector(-91.95, 3.12, 12.03);
                telePos[3] = Vector(-36.35, 4, -52.21);
                break;
            case (CurrentMap() == Map.Lijiang_Control_Center || CurrentMap() == Map.Lijiang_Control_Center_Lunar):
                validBuffMap = true;
                buffPos[0] = Vector(-26.80, 268.00, 308.00);
                buffPos[1] = Vector(0.00, 271.00, 323.00);
                buffPos[2] = Vector(26.80, 268.00, 308.00);
                buffPos[3] = Vector(0.00, 271.00, 260.65);
                buffPos[4] = Vector(0.00, 279.00, 291.85);

                telePos[0] = Vector(0, 269.17, 269.69);
                telePos[1] = Vector(0, 272, 329.50);
                telePos[2] = Vector(0, -10000, 0);
                telePos[3] = Vector(0, -10000, 0);
                break;
            case (CurrentMap() == Map.Necropolis):
                validBuffMap = true;
                buffPos[0] = Vector(1.68, 12.70, 17.25);
                buffPos[1] = Vector(-21.05, 13.71, 0);
                buffPos[2] = Vector(1.80, 12.70, -16.41);
                buffPos[3] = Vector(8.50, 2.01, 0.00);
                buffPos[4] = Vector(23.08, 5.99, 0.00);

                telePos[0] = Vector(-49.21, 7, 0);
                telePos[1] = Vector(31.59, 3, -0.20);
                telePos[2] = Vector(5.5, 12.33, -28.76);
                telePos[3] = Vector(5.5, 12.02, 28.39);
                break;
            case (CurrentMap() == Map.Paris):
                validBuffMap = true;
                buffPos[0] = Vector(-104.10, 16.00, -100.65);
                buffPos[1] = Vector(-109.18, 11.00, -60.60);
                buffPos[2] = Vector(-57.19, 14.00, -82.00);
                buffPos[3] = Vector(-73.39, 11.02, -38.23);
                buffPos[4] = Vector(-85.93, 13.00, -64.09);

                telePos[0] = Vector(-125.47, 12, -57.00);
                telePos[1] = Vector(-53.72, 15.00, -84.20);
                telePos[2] = Vector(-68.33, 13.35, -27.94);
                telePos[3] = Vector(-105.96, 17, -104.23);
                break;
        }
    }

globalvar define telePos;
playervar define usingTele;
rule: "[Tele] :: Create Tele Effects"
    if (validBuffMap && matchStarted && buffsEnabled)
    {
        for (define i = 0; i < 4; i++)
        {
            CreateEffect(all, Effect.BadAura, Color.Blue, telePos[i], 2, EffectRev.None);
        }
        // CreateEffect(all, Effect.BadAura, Color.Blue, telePos[0], 2, EffectRev.VisibleToPositionAndRadius);
        // CreateEffect(all, Effect.BadAura, Color.Blue, telePos[1], 2, EffectRev.VisibleToPositionAndRadius);
        // CreateEffect(all, Effect.BadAura, Color.Blue, telePos[2], 2, EffectRev.VisibleToPositionAndRadius);
        // CreateEffect(all, Effect.BadAura, Color.Blue, telePos[3], 2, EffectRev.VisibleToPositionAndRadius);
    }

rule: "[Tele] :: 0 to 1"
    Event.OngoingPlayer
    if (!usingTele && validBuffMap && DistanceBetween(telePos[0], player) < 3)
    {
        usingTele = true;
        Teleport(player, telePos[1]);
        PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, player, 1);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, telePos[0], 3);
        Wait();
        ApplyImpulse(player, Forward(), 20, Relative.ToPlayer, ContraryMotion.Cancel);
        Wait(1);
        usingTele = false;
    }

rule: "[Tele] :: 1 to 0"
    Event.OngoingPlayer
    if (!usingTele && validBuffMap && DistanceBetween(telePos[1], player) < 3)
    {
        usingTele = true;
        Teleport(player, telePos[0]);
        PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, player, 1);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, telePos[1], 3);
        Wait();
        ApplyImpulse(player, Forward(), 20, Relative.ToPlayer, ContraryMotion.Cancel);
        Wait(1);
        usingTele = false;
    }

rule: "[Tele] :: 2 to 3"
    Event.OngoingPlayer
    if (!usingTele && validBuffMap && DistanceBetween(telePos[2], player) < 3)
    {
        usingTele = true;
        Teleport(player, telePos[3]);
        PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, player, 1);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, telePos[2], 3);
        Wait();
        ApplyImpulse(player, Forward(), 20, Relative.ToPlayer, ContraryMotion.Cancel);
        Wait(1);
        usingTele = false;
    }

rule: "[Tele] :: 3 to 2"
    Event.OngoingPlayer
    if (!usingTele && validBuffMap && DistanceBetween(telePos[3], player) < 3)
    {
        usingTele = true;
        Teleport(player, telePos[2]);
        PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, player, 1);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, telePos[3], 3);
        Wait();
        ApplyImpulse(player, Forward(), 20, Relative.ToPlayer, ContraryMotion.Cancel);
        Wait(1);
        usingTele = false;
    }


disabled rule: "---------------- Wallbang ----------------"{}

rule: "[Buff] :: Wallbang : Create Orb"
    if (validBuffMap && !spawnWithWallbang && spawnWallbang && wallbangCD == 0 && (matchStarted || buffsSpawnImmediately))
    {
        canPickupWallbang = true;

        CreateEffect(all, Effect.Orb, Color.Yellow, buffPos[0], 2);
        buffEffect[0] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Yellow, buffPos[0], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Baptiste, Button.Ultimate), buffPos[0], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[0] = LastTextID();

        DestroyInWorldText(cdText[0]);
    }

rule: "[Buff] :: Wallbang : Collect"
    Event.OngoingPlayer
    if ((matchStarted && canPickupWallbang && DistanceBetween(buffPos[0], player) < 2.5 && HasSpawned() && IsAlive()) || spawnWithWallbang)
    {
        canPickupWallbang = false;
        wallbangEnabled = true;
        wallbangUser = player;

        if (!spawnWithWallbang)
        {
            // destroy inworld text / icon / orb
            DestroyInWorldText(cdText[0]);
            DestroyInWorldText(buffIcon[0]);
            DestroyEffect(buffEffect[0]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Yellow, buffPos[0], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Yellow, buffPos[0], 200);

            // start timer
            wallbangDur = WALLBANG_DUR;
            ChaseVariableAtRate(wallbangDur, 0, 1, RateChaseReevaluation.None);

            // toasts
            CreateHudText(player, null, null, <"<1> Wallbang: <0> <1>", RoundToInteger(wallbangDur, Rounding.Up), AbilityIconString(Hero.Baptiste, Button.Ultimate)>, Location.Right, 0.3, Color.White, Color.White, Color.Yellow);
            hudText[0] = LastTextID();
            SmallMessage(player, "Your bullets go through walls!");
            BigMessage(player, "Wallbang");

            // create effect
            CreateEffect(IsAlive() ? all : null, Effect.GoodAura, Color.Yellow, player, 0.75, EffectRev.VisibleToPositionAndRadius);
            wallbangBuffEffect = LastCreatedEntity();

            // sound when buff is about to run out
            Wait(WALLBANG_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
                Wait(1);
            }
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Wallbang: Forever <0>", AbilityIconString(Hero.Baptiste, Button.Ultimate)>, Location.Right, 0.3, Color.White, Color.White, Color.Yellow);
            hudText[0] = LastTextID();
        }
    }

rule: "[Buff] :: Wallbang : Remove"
    Event.OngoingPlayer
    if (!spawnWithWallbang && wallbangDur == 0)
    {
        Wait(0.128);

        // destroy hud timer and player effect
        DestroyHudText(hudText[0]);
        DestroyEffect(wallbangBuffEffect);
        StopChasingVariable(wallbangDur);

        wallbangEnabled = false;
        wallbangUser = null;
        wallbangDur = WALLBANG_DUR;

        // start in world cooldown
        WallbangCooldown(); 
    }

rule: "[Buff] :: Wallbang : Action"
    Event.OngoingPlayer
    if (wallbangEnabled && IsFiringPrimary())
    {
        define gunPos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        define wallbangHitPos = EyePosition();

        define wallbangLivingEnemies;
        define wallbangHitPlayer;

        for (define wallbangCount = 0; DistanceBetween(gunPos, wallbangHitPos) < 100 && wallbangCount < NUM_WALLBANGS; wallbangCount++)
        {
            wallbangLivingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
            wallbangHitPos = RayCastHitPosition(wallbangHitPos + Facing(), wallbangHitPos + Facing() * (100 - DistanceBetween(gunPos, wallbangHitPos)), wallbangLivingEnemies, player, true);
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, wallbangHitPos, 0.2);
            wallbangHitPlayer = RayCastHitPlayer(wallbangHitPos, wallbangHitPos + Facing() * (100 - DistanceBetween(gunPos, wallbangHitPos)), wallbangLivingEnemies, player, true);
            if (wallbangHitPlayer != null && wallbangHitPlayer != player)
            {
                Damage(wallbangHitPlayer, player, 10000);
            }

            if (wallbangDbg)
            {
                DestroyEffect(wbDbgEffects[wallbangCount]);
                DestroyEffect(wbDbgBeam[wallbangCount]);
                CreateEffect(all, Effect.Sphere, Color.Yellow, wallbangHitPos, 0.25, EffectRev.None);
                wbDbgEffects[wallbangCount] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, EyePosition(), wallbangHitPos, Color.Yellow, EffectRev.None);
                wbDbgBeam[wallbangCount] = LastCreatedEntity();
            }
        }

        CreateBeamEffect(all, BeamType.BadBeam, gunPos, wallbangHitPos, Color.Yellow, EffectRev.None);
        wallbangEffect[0] = LastCreatedEntity();
        // PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, gunPos, 0.2);

        Wait(0.25);
        DestroyEffect(wallbangEffect[0]);
    }

disabled rule: "---------------- Ricochet ----------------"{}

rule: "[Buff] :: Ricochet : Create Orb"
    if (validBuffMap && !spawnWithRicochet && spawnRicochet && ricochetCD == 0 && (matchStarted || buffsSpawnImmediately))
    {
        canPickupRicochet = true;

        CreateEffect(all, Effect.Orb, Color.Purple, buffPos[1], 2);
        buffEffect[1] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Purple, buffPos[1], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Winston, Button.Ability1), buffPos[1], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[1] = LastTextID();

        DestroyInWorldText(cdText[1]);
    }

rule: "[Buff] :: Ricochet : Collect"
    Event.OngoingPlayer
    if ((matchStarted && canPickupRicochet && DistanceBetween(buffPos[1], player) < 2.5 && HasSpawned() && IsAlive()) || spawnWithRicochet)
    {
        canPickupRicochet = false;
        ricochetEnabled = true;
        ricochetUser = player;

        if (!spawnWithRicochet)
        {
            // destroy inworld text / icon / orb
            DestroyInWorldText(cdText[1]);
            DestroyInWorldText(buffIcon[1]);
            DestroyEffect(buffEffect[1]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Purple, buffPos[1], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Purple, buffPos[1], 200);

            // start timer
            ricochetDur = RICOCHET_DUR;
            ChaseVariableAtRate(ricochetDur, 0, 1, RateChaseReevaluation.None);

            // toasts
            CreateHudText(player, null, null, <"<1> Ricochet: <0> <1>", RoundToInteger(ricochetDur, Rounding.Up), AbilityIconString(Hero.Winston, Button.Ability1)>, Location.Right, 0.4, Color.White, Color.White, Color.Purple);
            hudText[1] = LastTextID();
            SmallMessage(player, "Your bullets ricochet off walls!");
            BigMessage(player, "Ricochet");

            // create effect
            CreateEffect(IsAlive() ? all : null, Effect.GoodAura, Color.Purple, player, 0.75, EffectRev.VisibleToPositionAndRadius);
            ricochetBuffEffect = LastCreatedEntity();

            // sound when buff is about to run out
            Wait(RICOCHET_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
                Wait(1);
            }
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Ricochet: Forever <0>", AbilityIconString(Hero.Winston, Button.Ability1)>, Location.Right, 0.4, Color.White, Color.White, Color.Purple);
            hudText[1] = LastTextID();
        }
    }

rule: "[Buff] :: Ricochet : Remove"
    Event.OngoingPlayer
    if (ricochetDur == 0 && !spawnWithRicochet)
    {
        Wait(0.128);
        // destroy hud timer and player effect
        DestroyHudText(hudText[1]);
        DestroyEffect(ricochetBuffEffect);
        StopChasingVariable(ricochetDur);

        ricochetEnabled = false;
        ricochetUser = null;
        ricochetDur = RICOCHET_DUR;

        // start in world cooldown
        RicochetCooldown(); 
    }


rule: "[Buff] :: Ricochet : Action"
    Event.OngoingPlayer
    if (ricochetEnabled && IsFiringPrimary())
    {
        // https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector
        define normals = [];
        define hitPos = [];
        define hitPosPlayer = [];
        define ricochets = [];
        define hitPosRicochets = [];
        define hitPosPlayerRicochets = [];
        define ricochetEffects = [];
        define ricochetEffect = [];

        eyePos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        facing = Facing();

        for (define loop = 0; loop < NUM_RICOCHETS; loop++)
        {
            if (loop > 0)
            {
                eyePos = hitPos[loop - 1];
                facing = ricochets[loop - 1];
            }

            normals[loop] = RayCastHitNormal(eyePos, eyePos + facing * 100, all, player, true);
            hitPos[loop] = RayCastHitPosition(eyePos, eyePos + facing * 100, all, player, true);
            hitPosPlayer[loop] = RayCastHitPlayer(eyePos, eyePos + facing * 100, all, player, true);
            ricochets[loop] = facing - (2 * (normals[loop] * DotProduct(facing, normals[loop])));
            hitPosRicochets[loop] = RayCastHitPosition(hitPos[loop], hitPos[loop] + ricochets[loop] * 100, AllLivingPlayers(), player, true);
            hitPosPlayerRicochets[loop] = RayCastHitPlayer(hitPos[loop], hitPos[loop] + ricochets[loop] * 100, AllLivingPlayers(), player, true);

            CreateBeamEffect(all, BeamType.BadBeam, eyePos, hitPos[loop], Color.Purple, EffectRev.None); // first raycast hit
            ricochetEffect[loop] = LastCreatedEntity();

            CreateBeamEffect(all, BeamType.BadBeam, hitPos[loop], hitPosRicochets[loop], Color.Purple, EffectRev.None); // ricochets
            ricochetEffects[loop] = LastCreatedEntity();

            // PlayEffect(all, PlayEffect.GoodExplosion, Color.Purple, eyePos, 0.2); // muzzle flash
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Purple, hitPos[loop], 0.2); // first raycast hit
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Purple, hitPosRicochets[loop], 0.2); // ricochets

            Damage(hitPosPlayer[loop], player, 10000);
            Damage(hitPosPlayerRicochets[loop], player, 10000);

            if (ricochetDbg)
            {
                DestroyEffect(rDbgEffects[0][loop]);
                DestroyEffect(rDbgEffects[1][loop]);
                DestroyEffect(rDbgBeam[0][loop]);
                DestroyEffect(rDbgBeam[1][loop]);
                CreateEffect(all, Effect.Sphere, Color.Purple, hitPos[loop], 0.25, EffectRev.None);
                rDbgEffects[0][loop] = LastCreatedEntity();
                CreateEffect(all, Effect.Sphere, Color.Purple, hitPosRicochets[loop], 0.25, EffectRev.None);
                rDbgEffects[1][loop] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, eyePos, hitPos[loop], Color.Purple, EffectRev.None);
                rDbgBeam[0][loop] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, hitPos[loop], hitPosRicochets[loop], Color.Purple, EffectRev.None);
                rDbgBeam[1][loop] = LastCreatedEntity();
            }
        }

        Wait(0.15);
        for (define i = 0; i < NUM_RICOCHETS; i++)
        {
            DestroyEffect(ricochetEffect[i]);
            DestroyEffect(ricochetEffects[i]);
        }
    }

disabled rule: "---------------- Buckshot ----------------"{}

rule: "[Buff] :: Buckshot : Create Orb"
    if (validBuffMap && !spawnWithBuckshot && spawnBuckshot && buckshotCD == 0 && (matchStarted || buffsSpawnImmediately))
    {
        canPickupBuckshot = true;

        CreateEffect(all, Effect.Orb, Color.Green, buffPos[2], 2);
        buffEffect[2] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Green, buffPos[2], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Ashe, Button.Ability1), buffPos[2], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[2] = LastTextID();

        DestroyInWorldText(cdText[2]);
    }

rule: "[Buff] :: Buckshot : Collect"
    Event.OngoingPlayer
    if ((matchStarted && canPickupBuckshot && DistanceBetween(buffPos[2], player) < 2.5 && HasSpawned() && IsAlive()) || spawnWithBuckshot)
    {
        canPickupBuckshot = false;
        buckshotEnabled = true;
        buckshotUser = player;

        if (!spawnWithBuckshot)
        {
            // destroy inworld text / icon / orb
            DestroyInWorldText(cdText[2]);
            DestroyInWorldText(buffIcon[2]);
            DestroyEffect(buffEffect[2]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Green, buffPos[2], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Green, buffPos[2], 200);

            // start timer
            buckshotDur = BUCKSHOT_DUR;
            ChaseVariableAtRate(buckshotDur, 0, 1, RateChaseReevaluation.DestinationAndRate);
        
            // toasts
            CreateHudText(player, null, null, <"<1> Buckshot: <0> <1>", RoundToInteger(buckshotDur, Rounding.Up), AbilityIconString(Hero.Ashe, Button.Ability1)>, Location.Right, 0.5, Color.White, Color.White, Color.Green);
            hudText[2] = LastTextID();
            BigMessage(player, "Buckshot");
            SmallMessage(player, "Your bullets spread like a shotgun!");

            // create effect
            CreateEffect(IsAlive() ? all : null, Effect.GoodAura, Color.Green, player, 0.75, EffectRev.VisibleToPositionAndRadius);
            buckshotBuffEffect = LastCreatedEntity();

            // sound when buff is about to run out
            Wait(BUCKSHOT_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
                Wait(1);
            }
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Buckshot: Forever <0>", AbilityIconString(Hero.Ashe, Button.Ability1)>, Location.Right, 0.5, Color.White, Color.White, Color.Green);
            hudText[2] = LastTextID();
        }
    }

rule: "[Buff] :: Buckshot : Remove"
    Event.OngoingPlayer
    if (!spawnWithBuckshot && buckshotDur == 0)
    {
        Wait(0.128);
        // destroy hud timer and player effect
        DestroyHudText(hudText[2]);
        DestroyEffect(buckshotBuffEffect);
        StopChasingVariable(buckshotDur);

        buckshotEnabled = false;
        buckshotUser = null;
        buckshotDur = BUCKSHOT_DUR;

        // start in world cooldown
        BuckshotCooldown(); 
    }

rule: "[Buff] :: Buckshot : Action"
    Event.OngoingPlayer
    if (buckshotEnabled && IsFiringPrimary())
    {
        buckshotHitPos = [];
        buckshotHitPlayer = [];
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
        define gunPos = WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        define buckshotBeam = [];
        define centerBeam;

        spreadDiag = BUCKSHOT_SPREAD - (BUCKSHOT_SPREAD * 0.33);
        spreadHori = BUCKSHOT_SPREAD;

        // center
        buckshotCenter = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, livingEnemies, player);

        // if (!randomSpread)
        // {
            // hitpos
            {
                // lower left
                buckshotHitPos[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
                * 100, AllLivingPlayers(), player, false);

                // upper left
                buckshotHitPos[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag) 
                * 100, AllLivingPlayers(), player, false);

                // lower right
                buckshotHitPos[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
                * 100, AllLivingPlayers(), player, false);

                // upper right
                buckshotHitPos[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag) 
                * 100, AllLivingPlayers(), player, false);

                // lower mid
                buckshotHitPos[4] = RayCastHitPosition(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadHori) 
                * 100, AllLivingPlayers(), player, false);

                // upper mid
                buckshotHitPos[5] = RayCastHitPosition(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadHori) 
                * 100, AllLivingPlayers(), player, false);

                // mid left
                buckshotHitPos[6] = RayCastHitPosition(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(spreadHori) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
                * 100, AllLivingPlayers(), player, false);

                // mid right
                buckshotHitPos[7] = RayCastHitPosition(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(-spreadHori) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
                * 100, AllLivingPlayers(), player, false);
            }
            // player
            {
                buckshotHitPlayer[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
                * 100, AllLivingPlayers(), player, false);

                buckshotHitPlayer[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag)
                * 100, AllLivingPlayers(), player, false);

                buckshotHitPlayer[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
                * 100, AllLivingPlayers(), player, false);

                buckshotHitPlayer[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag)
                * 100, AllLivingPlayers(), player, false);

                buckshotHitPlayer[4] = RayCastHitPlayer(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadHori) 
                * 100, AllLivingPlayers(), player, false);

                buckshotHitPlayer[5] = RayCastHitPlayer(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadHori) 
                * 100, AllLivingPlayers(), player, false);

                buckshotHitPlayer[6] = RayCastHitPlayer(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(spreadHori) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
                * 100, AllLivingPlayers(), player, false);

                buckshotHitPlayer[7] = RayCastHitPlayer(EyePosition(), EyePosition() + 
                WorldVectorOf(Vector(TangentFromDegrees(-spreadHori) * 100, 0, 0), player) + 
                DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
                * 100, AllLivingPlayers(), player, false);
            }
        // }
        // else
        // {
        //     define randomizedSpreadHori = [];
        //     define randomizedSpreadDiag = [];

        //     for (define i = 0; i < 4; i++)
        //     {
        //         randomizedSpreadHori[i] = RandomReal(spreadHori / 5, spreadHori + 1.5);
        //         randomizedSpreadDiag[i] = RandomReal(spreadDiag / 5, spreadDiag + 1.5);
        //     }

        //     // hitpos
        //     {
        //         // lower left
        //         buckshotHitPos[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadDiag[0]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadDiag[0]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         // upper left
        //         buckshotHitPos[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadDiag[1]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - randomizedSpreadDiag[1]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         // lower right
        //         buckshotHitPos[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadDiag[2]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadDiag[2]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         // upper right
        //         buckshotHitPos[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadDiag[3]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - randomizedSpreadDiag[3]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         // lower mid
        //         buckshotHitPos[4] = RayCastHitPosition(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadHori[0]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         // upper mid
        //         buckshotHitPos[5] = RayCastHitPosition(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - randomizedSpreadHori[1]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         // mid left
        //         buckshotHitPos[6] = RayCastHitPosition(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadHori[2]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        //         * 100, AllLivingPlayers(), player, false);

        //         // mid right
        //         buckshotHitPos[7] = RayCastHitPosition(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadHori[3]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        //         * 100, AllLivingPlayers(), player, false);
        //     }
        //     // player
        //     {
        //         buckshotHitPlayer[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadDiag[0]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadDiag[0]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         buckshotHitPlayer[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadDiag[1]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - randomizedSpreadDiag[1]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         buckshotHitPlayer[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadDiag[2]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadDiag[2]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         buckshotHitPlayer[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadDiag[3]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - randomizedSpreadDiag[3]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         buckshotHitPlayer[4] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadHori[0]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         buckshotHitPlayer[5] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - randomizedSpreadHori[1]) 
        //         * 100, AllLivingPlayers(), player, false);

        //         buckshotHitPlayer[6] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadHori[2]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        //         * 100, AllLivingPlayers(), player, false);

        //         buckshotHitPlayer[7] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        //         WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadHori[3]) * 100, 0, 0), player) + 
        //         DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        //         * 100, AllLivingPlayers(), player, false);
        //     }
        // }

        // PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, EyePosition() + Facing() + gunPos, 0.2); // muzzle flash
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotCenter, 0.2);

        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotCenter, Color.Green, EffectRev.None);
        centerBeam = LastCreatedEntity();

        for (define pellets = 0; pellets < 8; pellets++)
        {
            Damage(buckshotHitPlayer[pellets], player, 10000);

            PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotHitPos[pellets], 0.2);
    
            if (buckshotDbg)
            {
                DestroyEffect(bDbgEffects[pellets]);
                DestroyEffect(bDbgBeam[pellets]);
                CreateEffect(all, Effect.Sphere, Color.Green, buckshotHitPos[pellets], 0.25, EffectRev.None);
                bDbgEffects[pellets] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, EyePosition(), buckshotHitPos[pellets], Color.Green, EffectRev.None);
                bDbgBeam[pellets] = LastCreatedEntity();
            }

            CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotHitPos[pellets], Color.Green, EffectRev.None);
            buckshotBeam[pellets] = LastCreatedEntity();

        }

        Wait(0.15);
        DestroyEffect(centerBeam);
        for (define beams = 0; beams < 8; beams++)
        {
            DestroyEffect(buckshotBeam[beams]);
        }
    }

disabled rule: "---------------- Extra Life ----------------"{}

rule: "[Buff] :: Extra Life : Create Orb"
    if (validBuffMap && !spawnWithLife && spawnLife && lifeCD == 0 && (matchStarted || buffsSpawnImmediately))
    {
        canPickupLife = true;

        CreateEffect(all, Effect.Orb, Color.SkyBlue, buffPos[3], 2);
        buffEffect[3] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.SkyBlue, buffPos[3], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Mercy, Button.Ability2), buffPos[3], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[3] = LastTextID();

        DestroyInWorldText(cdText[3]);
    }

rule: "[Buff] :: Extra Life : Collect"
    Event.OngoingPlayer
    if ((matchStarted && !extraLife && canPickupLife && DistanceBetween(buffPos[3], player) < 2.5 && HasSpawned() && IsAlive()) || (spawnWithLife && IsAlive()))
    {
        canPickupLife = false;
        extraLife = true;

        SetStatus(player, null, Status.Unkillable, 10000);

        if (!spawnWithLife)
        {
            // destroy inworld text / icon / orb
            DestroyInWorldText(cdText[3]);
            DestroyInWorldText(buffIcon[3]); 
            DestroyEffect(buffEffect[3]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.SkyBlue, buffPos[3], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.SkyBlue, buffPos[3], 200);

            // toasts
            SmallMessage(player, "Extra Life");
            BigMessage(player, "Extra Life");

            // start in world cooldown
            LifeCooldown();
        }

        // hud text
        CreateHudText(player, null, null, <"<0> Extra Life <0>", AbilityIconString(Hero.Mercy, Button.Ability2)>, Location.Right, 0.2, Color.White, Color.White, Color.SkyBlue);
        hudText[3] = LastTextID();

        // create icon above player
        CreateInWorldText(all, AbilityIconString(Hero.Mercy, Button.Ability2), player, 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString);
        extraLifeIcon = LastTextID();

        // create effect
        CreateEffect(all, Effect.BadAura, Color.SkyBlue, player, 0.75, EffectRev.VisibleToPositionAndRadius);
        lifeBuffEffect = LastCreatedEntity();
    }

rule: "[Buff] :: Extra Life : Remove"
    Event.OngoingPlayer
    if (extraLife && (Health() == 1 || IsDead()))
    {
        extraLife = false;

        ClearStatus(player, Status.Unkillable);

        if (!spawnWithLife)
        {
            SmallMessage(player, "Extra life used");
            PlayEffect(player, PlayEffect.DebuffImpactSound, Color.White, player, 200);
        }
        
        DestroyInWorldText(extraLifeIcon);
        DestroyEffect(lifeBuffEffect);
        DestroyHudText(hudText[3]);

        Wait(1);
        SetPlayerHealth(player, MaxHealth());
    }

// disabled rule: "---------------- Redeemer ----------------"{}

// //// redeemer ////

// // global :: workshop settings
// globalvar define spawnRedeemer;
// globalvar define spawnWithRedeemer;
// // global :: constants
// globalvar define REDEEMER_CD;
// globalvar define REDEEMER_DUR;
// // global
// globalvar define canPickupRedeemer;
// globalvar define redeemerCD; 
// globalvar define redeemerUser;
// // player
// playervar define redeemerEnabled;
// playervar define redeemerDur;
// playervar define redeemerBuffEffect;

// rule: "[Buff] :: Redeemer : Create Orb"
//     if (validBuffMap && !spawnWithRedeemer && spawnRedeemer && redeemerCD == 0 && (matchStarted || buffsSpawnImmediately))
//     {
//         canPickupRedeemer = true;

//         CreateEffect(all, Effect.Orb, Color.Blue, buffPos[4], 2);
//         buffEffect[4] = LastCreatedEntity();
//         PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Blue, buffPos[4], 1);

//         CreateInWorldText(all, IconString(Icon.Skull), buffPos[4], 2, Clipping.ClipAgainstSurfaces);
//         buffIcon[4] = LastTextID();

//         DestroyInWorldText(cdText[4]);
//     }

// rule: "[Buff] :: Redeemer : Collect"
//     Event.OngoingPlayer
//     if ((matchStarted && canPickupRedeemer && DistanceBetween(buffPos[4], player) < 2.5 && HasSpawned() && IsAlive()) || spawnWithRedeemer)
//     {
//         canPickupRedeemer = false;
//         redeemerEnabled = true;

//         redeemerUser = player;

//         if (!spawnWithRedeemer)
//         {
//             // destroy inworld text / icon / orb
//             DestroyInWorldText(cdText[4]);
//             DestroyInWorldText(buffIcon[4]);
//             DestroyEffect(buffEffect[4]);

//             // pickup effects
//             PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Blue, buffPos[4], 1);
//             PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Blue, buffPos[4], 200);

//             // start timer
//             redeemerDur = REDEEMER_DUR;
//             ChaseVariableAtRate(redeemerDur, 0, 1, RateChaseReevaluation.DestinationAndRate)
        
//             // toasts
//             CreateHudText(player, null, null, <"<1> something lol idk yet: <0> <1>", RoundToInteger(redeemerDur, Rounding.Up), IconString(Icon.Skull)>, Location.Right, 0.6);
//             hudText[4] = LastTextID();
//             BigMessage(player, "something");
//             SmallMessage(player, "fsadsa");

//             // create effect
//             CreateEffect(IsAlive() ? all : null, Effect.GoodAura, Color.Blue, player, 0.75, EffectRev.VisibleToPositionAndRadius);
//             redeemerBuffEffect = LastCreatedEntity();

//             // sound when buff is about to run out
//             Wait(REDEEMER_DUR - 4);
//             for (define sound; 4; 1)
//             {
//                 PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
//                 Wait(1);
//             }
//         }
//         else
//         {
//             CreateHudText(player, null, null, <"<0> something: Forever <0>", IconString(Icon.Skull)>, Location.Right, 0.6);
//             hudText[4] = LastTextID();
//         }
//     }

// rule: "[Buff] :: Redeemer : Remove"
//     Event.OngoingPlayer
//     if (!spawnWithRedeemer && redeemerDur == 0)
//     {
//         Wait(0.128);
//         // destroy hud timer and player effect
//         DestroyHudText(hudText[4]);
//         DestroyEffect(redeemerBuffEffect);
//         StopChasingVariable(redeemerDur);

//         redeemerEnabled = false;
//         redeemerUser = null;
//         redeemerDur = REDEEMER_DUR;

//         // start in world cooldown
//         RedeemerCooldown(); 
//     }

// rule: "[Buff] :: Redeemer : Action"
//     Event.OngoingPlayer
//     if (redeemerEnabled && IsFiringPrimary())
//     {
//         define primaryBeam;
//         primaryStartPos = WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
//         primaryHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);

//         PlayEffect(player, PlayEffect.GoodExplosion, Color.Blue, primaryHit, 0.2);
//         CreateBeamEffect(player, BeamType.BadBeam, EyePosition() + Facing() + primaryStartPos, primaryHit, Color.Blue, EffectRev.None);
//         primaryBeam = LastCreatedEntity();

//         Wait(0.15);
//         DestroyEffect(primaryBeam);
//     }

// rule: "[Debug] :: Kill"
//     Event.OngoingPlayer
//     if (player == host && IsInteractHeld())
//     {
//         Kill();
//     }

// rule: "[Debug] :: hud text"
//     {
//         CreateHudText(host, null, null, <"Pos: <0>", PositionOf(host)>, Location.Top, 10);
//         CreateHudText(host, null, null, <"Facing: <0>", FacingDirectionOf(host)>, Location.Top, 10);
//     }

// rule: "[Debug] :: Bots"
//     Event.OngoingPlayer
//     if (player == host && IsInteractHeld() && !IsCrouchHeld())
//     {
//         CreateDummyBot(HeroOf(), OppositeTeamOf(TeamOf()), -1, RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100), Facing() * -1);
//     }

// rule: "[Debug] :: Destroy Bots"
//     Event.OngoingPlayer
//     if (player == host && IsCrouchHeld() && IsInteractHeld())
//     {
//         DestroyAllDummyBots();
//     }

// rule: "[Degug] :: Bots Hold Left Click"
//     Event.OngoingPlayer
//     if (IsDummyBot())
//     {
//         StartHoldingButton(player, Button.PrimaryFire);
//     }
