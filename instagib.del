import "macros.del";
import "instagibSettings.json";

// bhop
playervar define bhopSpeed;
playervar define speedAccumInAir;
playervar define isChasing;

// primary
playervar define primaryHit;
playervar define startPos;
// playervar define primaryBeam;

// secondary
playervar define secondaryHit;
playervar define secondaryEyePos;
playervar define secondaryOrb;

// grapple
playervar define grappleEyePos;
playervar define usingGrapple;
playervar define grappleHit;
playervar define grappleHitPlayer;

// misc
playervar define livingEnemies;

// constants :: bhop
globalvar define BHOP_MAX_SPEED;
globalvar define BHOP_SPEED_RATE;

// constants :: grapple
globalvar define GRAPPLE_PULL_SPEED;
globalvar define GRAPPLE_RANGE;

// constants :: secondary
globalvar define SECONDARY_PROJECTILE_SPEED;

// constants: misc
globalvar define MATCH_TIME_LIMIT;

// toggle
globalvar define matchStarted;

// dodge
globalvar define DODGE_FORCE;
playervar define throttleOf;
playervar define canDodge;

/////////////////////
/////// buffs ///////
/////////////////////

globalvar define buffsEnabled;
globalvar define teleEnabled;
globalvar define buffsSpawnImmediately;
globalvar define validMap;
globalvar define buffEffect;
globalvar define buffPos;
globalvar define buffIcon;
globalvar define cdText;
globalvar define cdType;
playervar define hudText;
playervar define lifeKills;
playervar define spreeInWorld;
playervar define spreeEffects;
playervar define spreeHud;
playervar define killsHud;
globalvar define grappleEnabled;
globalvar define dodgeEnabled;
globalvar define secondaryEnabled;
globalvar define primaryFxEnabled;
globalvar define bhopEnabled;
globalvar define buffHudText;
// globalvar define cdIP;

//// wallbang ////

globalvar define spawnWallbang;
globalvar define spawnWithWallbang;
globalvar define wallbangDbg;
globalvar define NUM_WALLBANGS;
globalvar define WALLBANG_DUR;
globalvar define WALLBANG_CD;
globalvar define wallbangCD;
playervar define wallbangEnabled;
playervar define wallbangEffect;
playervar define wallbangDur;
playervar define wbDbgEffects;
playervar define wbDbgBeam;

//// ricochet ////

globalvar define spawnRicochet;
globalvar define spawnWithRicochet;
globalvar define ricochetDbg;
globalvar define NUM_RICOCHETS;
globalvar define RICOCHET_CD;
globalvar define RICOCHET_DUR;
globalvar define ricochetCD;
playervar define ricochetEnabled;
playervar define ricochetDur;
playervar define rDbgEffects;
playervar define rDbgBeam;
playervar define eyePos;
playervar define facing;

//// buckshot ////

globalvar define spawnBuckshot;
globalvar define spawnWithBuckshot;
globalvar define BUCKSHOT_SPREAD;
globalvar define BUCKSHOT_CD;
globalvar define BUCKSHOT_DUR;
globalvar define buckshotCD;
playervar define buckshotEnabled;
playervar define buckshotHitPos;
playervar define buckshotHitPlayer;
playervar define buckshotCenter;
playervar define buckshotDur;
globalvar define spreadDiag;
globalvar define spreadHori;

//// extra life ////

globalvar define spawnLife;
globalvar define spawnWithLife;
globalvar define LIFE_CD;
globalvar define LIFE_DUR;
globalvar define lifeCD;
playervar define lifeEnabled;
// playervar define extraLife;
playervar define extraLifeIcon;
playervar define lifeBuffEffect;
playervar define lifeDur;

globalvar define serverLoad;

/* ------------------------------------------------------------------------------- todo + notes: -------------------------------------------------------------------------------
todo:
general optimizations
drop whichever buff(s) the player has upon death (orb(s) will only be up for 20 seconds, then will disappear then use the normal cooldown at its map determined spot)
option for extra lives to "stack"
new buff: wallbang and ricochet properties all within shotgun pellets
randomize weapon buff map locations upon match start

random world events: lasts for 30 seconds, has a 2 minute cooldown

low grav
wallhacks
explosive secondary
ratz mode (everyone is 35% scale)

notes:
dont use EntityExists() with effects
setting the buffUser to null will most likely break cooldown effects, doesnt break the timer, only the effects
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */

// cancer cuz why the FUCK not
define loadColor: CustomColor(rL, gL, 0, 250);
define avgColor: CustomColor(rA, gA, 0, 250);
define peakColor: CustomColor(rP, gP, 0, 250);

define percentageL: (ServerLoad());
define percentageA: (ServerLoadAverage());
define percentageP: (ServerLoadPeak());

define gL: (percentageL <= 127.5) ? 255 : RoundToInteger(256 - (percentageL - 127.5) * 5.12, Rounding.Down);
define rL: (percentageL >= 127.5) ? 255 : RoundToInteger(percentageL * 5.12, Rounding.Down);
define gA: (percentageA <= 127.5) ? 255 : RoundToInteger(256 - (percentageA - 127.5) * 5.12, Rounding.Down);
define rA: (percentageA >= 127.5) ? 255 : RoundToInteger(percentageP * 5.12, Rounding.Down);
define gP: (percentageP <= 127.5) ? 255 : RoundToInteger(256 - (percentageP - 127.5) * 5.12, Rounding.Down);
define rP: (percentageP >= 127.5) ? 255 : RoundToInteger(percentageP * 5.12, Rounding.Down);

disabled rule: "---------------- Main ----------------"{}

rule: "[Main] :: Initial Global"
    {
        // DisableInspectorRecording();
        DisableCompletion();
        DisableAnnouncer();

        CreateHudText(all, null, "Instagib | Created by scort#11221ㅤ", " v2.0.0 | Share Code: APPPXㅤ", Location.Right, 0, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
        CreateHudText(all, null, null, " ", Location.Right, 0.1);

        if (serverLoad)
        {
            CreateHudText(host, null, null, "Server Load", Location.Right, 10);
            CreateHudText(host, null, null, <"Current: <0>%", RoundToInteger(ServerLoad() / 2.55, Rounding.Nearest)>, Location.Right, 11, Color.White, Color.White, loadColor, HudTextRev.VisibleToSortOrderStringAndColor);
            CreateHudText(host, null, null, <"Average: <0>%", RoundToInteger(ServerLoadAverage() / 2.55, Rounding.Nearest)>, Location.Right, 12, Color.White, Color.White, avgColor, HudTextRev.VisibleToSortOrderStringAndColor);
            CreateHudText(host, null, null, <"Peak: <0>%", RoundToInteger(ServerLoadPeak() / 2.55, Rounding.Nearest)>, Location.Right, 13, Color.White, Color.White, peakColor, HudTextRev.VisibleToSortOrderStringAndColor);
        }

        SetMatchTime(10);

        cdText = [];
        buffEffect = [];
        buffPos = [];
        buffIcon = [];
        telePos = [];
        teleFacing = [];

        matchStarted = false;

        MATCH_TIME_LIMIT = WorkshopSettingInteger("General", "​Match Time (Minutes) (20)", 20, 1, 60, 1) * 60;
        buffsEnabled = WorkshopSettingToggle("General", "​​Spawn Buffs (On)", true, 2);
        teleEnabled = WorkshopSettingToggle("General", "​​Spawn Teleporters (On)", true, 3);
        buffsSpawnImmediately = WorkshopSettingToggle("General", "​Buffs Spawn Immediately When Match Starts (Off)", false, 4);
        primaryFxEnabled = WorkshopSettingToggle("General", "Enable Primary Fire Effects (On)", true, 5);
        cdType = WorkshopSettingCombo("General", "Buff Cooldown Visual Type (Progress Bar)", 0, ["Progress Bar", "Countdown", "None"], 6);
        // cdIP = WorkshopSettingToggle("General", "Show buff cooldown visuals (On)", true, 7);
        buffHudText = WorkshopSettingToggle("General", "Show Buff Cooldown HUD Text (On)", true, 8);

        grappleEnabled = WorkshopSettingToggle("Grapple", "Enable Grapple (On)", true, 1);
        GRAPPLE_PULL_SPEED = WorkshopSettingReal("Grapple", "Grapple ​​Pull Speed (3.5)", 3.5, 0.5, 10, 2);
        GRAPPLE_RANGE = WorkshopSettingReal("Grapple", "​​Grapple Range (40)", 40, 3.5, 100, 3);

        secondaryEnabled = WorkshopSettingToggle("Secondary Fire", "Enable Secondary (On)", true, 1);
        SECONDARY_PROJECTILE_SPEED = WorkshopSettingInteger("Secondary Fire", "​​​Projectile Speed (90)", 90, 10, 500, 2);

        dodgeEnabled = WorkshopSettingToggle("Dodge", "Enable Dodge (On)", true, 1);
        DODGE_FORCE = WorkshopSettingReal("Dodge", "Dodge ​​​​​Force (14)", 14, 1, 100, 2);

        bhopEnabled = WorkshopSettingToggle("BHop", "Enable BHops (On)", true, 1);
        BHOP_MAX_SPEED = WorkshopSettingInteger("BHop", "​Maximum Speed Possible From Hops (320)", 320, 110, 10000, 2);
        BHOP_SPEED_RATE = WorkshopSettingReal("BHop", "​​Speed gain rate (12.5)", 12.5, 1, 100, 3);

        WALLBANG_CD = WorkshopSettingInteger("Wallbang", "​​Wallbang Spawn Time (65)", 65, 1, 500, 1);
        WALLBANG_DUR = WorkshopSettingInteger("Wallbang", "Wallbang ​​​Duration (25)", 25, 1, 500, 2);
        NUM_WALLBANGS = WorkshopSettingInteger("Wallbang", "​Wallbang Amount (5)", 5, 2, 100, 3);
        spawnWallbang = WorkshopSettingToggle("Wallbang", "​​​​Spawn Wallbang (On)", true, 4);
        spawnWithWallbang = WorkshopSettingToggle("Wallbang", "​​​​​Spawn With Wallbang (Lasts Forever) (Off)", false, 5);

        RICOCHET_CD = WorkshopSettingInteger("Ricochet", "Ricochet ​Spawn Time (55)", 55, 1, 500, 1);
        RICOCHET_DUR = WorkshopSettingInteger("Ricochet", "​​Ricochet Duration (30)", 30, 1, 500, 2);
        NUM_RICOCHETS = WorkshopSettingInteger("Ricochet", "​​​Ricochet Amount (4)", 4, 1, 32, 3);
        spawnRicochet = WorkshopSettingToggle("Ricochet", "Spawn Ricochet (On)", true, 4);
        spawnWithRicochet = WorkshopSettingToggle("Ricochet", "​​​​​Spawn With Ricochet (Lasts Forever) (Off)", false, 5);

        BUCKSHOT_CD = WorkshopSettingInteger("Buckshot", "Buckshot ​Spawn Time (85)", 85, 1, 500, 1);
        BUCKSHOT_DUR = WorkshopSettingInteger("Buckshot", "​​Buckshot Duration (20)", 20, 1, 500, 2);
        BUCKSHOT_SPREAD = WorkshopSettingReal("Buckshot", "​​​Buckshot Spread (Lower is Tighter) (3.5)", 3.5, 0.1, 20, 2);
        spawnBuckshot = WorkshopSettingToggle("Buckshot", "​​​​​Spawn Buckshot (On)", true, 3);
        spawnWithBuckshot = WorkshopSettingToggle("Buckshot", "​​​​​Spawn With Buckshot (Lasts Forever) (Off)", false, 4);

        LIFE_CD = WorkshopSettingInteger("Extra Life", "​Extra Life Spawn Time (95)", 95, 1, 500, 1);
        LIFE_DUR = WorkshopSettingInteger("Extra Life", "​​​Extra Life Duration (45)", 45, 1, 500, 3);
        spawnLife = WorkshopSettingToggle("Extra Life", "​​Spawn Extra Life (On)", true, 2);
        spawnWithLife = WorkshopSettingToggle("Extra Life", "​​​Spawn With Extra Life (Off)", false, 3);

        REDEEMER_CD = WorkshopSettingInteger("Redeemer", "Redeemer Spawn Time (145)", 150, 1, 500, 1);
        REDEEMER_DUR = WorkshopSettingInteger("Redeemer", "Redeemer Duration (30)", 30, 1, 500, 2);
        REDEEMER_ESIZE = WorkshopSettingReal("Redeemer", "Redeemer Explosion Size (18.5)", 18.5, 1, 50, 3);
        REDEEMER_DELAY = WorkshopSettingReal("Redeemer", "Redeemer Explosion and Weapon Fire Delay (1)", 1, 0.25, 20, 4);
        spawnRedeemer = WorkshopSettingToggle("Redeemer", "​​​​​Spawn Redeemer (On)", true, 5);
        spawnWithRedeemer = WorkshopSettingToggle("Redeemer", "​​​​​Spawn With Redeemer (Lasts Forever) (Off)", false, 6);

        wallbangDbg = WorkshopSettingToggle("Debug", "Show Wallbang Hits", false, 2);
        ricochetDbg = WorkshopSettingToggle("Debug", "Show Ricochet Hits", false, 3);
        serverLoad = WorkshopSettingToggle("Debug", "Show Server Load", false, 4);

        if (!buffsEnabled)
        {
            spawnWallbang = false;
            spawnRicochet = false;
            spawnBuckshot = false;
            spawnLife = false;
            spawnRedeemer = false;
        }
    }

rule: "[Main] :: Player Join"
    Event.OnPlayerJoin
    {
        DisallowButton(player, Button.Ability1);
        DisallowButton(player, Button.Ability2);
        SetProjectileSpeed(player, 10000);

        hudText = [];
        spreeInWorld = [];
        spreeEffects = [];
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
    }

rule: "[Main] :: Start Match"
    if (!matchStarted/*  && IsGameInProgress() */)
    if (IsGameInProgress())
    {
        LogToInspector("Match Started");
        SetMatchTime(MATCH_TIME_LIMIT);
        matchStarted = true;

        if (validMap && buffsEnabled)
        {
            if (!buffsSpawnImmediately)
            {
                wallbangCD = WALLBANG_CD;
                ricochetCD = RICOCHET_CD;
                buckshotCD = BUCKSHOT_CD;
                lifeCD = LIFE_CD;
                redeemerCD = REDEEMER_CD;

                WallbangCooldown();
                RicochetCooldown();
                BuckshotCooldown();
                LifeCooldown();
                RedeemerCooldown();
            }
            else
            {
                wallbangCD = 0;
                ricochetCD = 0;
                buckshotCD = 0;
                lifeCD = 0;
                redeemerCD = 0;
            }

            if (buffHudText)
            {
                if (!spawnWithWallbang && spawnWallbang)
                {
                    CreateHudText(all, <"<0>", AbilityIconString(Hero.Baptiste, Button.Ultimate)>, null, 
                    wallbangCD != 0 ? <"<0>", wallbangCD> : canPickupBuff[0] ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", buffUser[0]>, 
                    Location.Left, 1, Color.Yellow);
                }
                if (!spawnWithRicochet && spawnRicochet)
                {
                    CreateHudText(all, <"<0>", AbilityIconString(Hero.Winston, Button.Ability1)>, null,
                    ricochetCD != 0 ? <"<0>", ricochetCD> : canPickupBuff[1] ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", buffUser[1]>,
                    Location.Left, 2, Color.Purple);
                }
                if (!spawnWithBuckshot && spawnBuckshot)
                {
                    CreateHudText(all, <"<0>", AbilityIconString(Hero.Ashe, Button.Ability1)>, null,
                    buckshotCD != 0 ? <"<0>", buckshotCD> : canPickupBuff[2] ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", buffUser[2]>,
                    Location.Left, 3, Color.Green);
                }
                if (!spawnWithLife && spawnLife)
                {
                    CreateHudText(all, <"<0>", AbilityIconString(Hero.Mercy, Button.Ability2)>, null,
                    lifeCD != 0 ? <"<0>", lifeCD> : canPickupBuff[3] ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", buffUser[3]>,
                    Location.Left, 4, Color.SkyBlue);
                }
                if (!spawnWithRedeemer && spawnRedeemer)
                {
                    CreateHudText(all, <"<0>", AbilityIconString(Hero.Symmetra, Button.Ultimate)>, null,
                    redeemerCD != 0 ? <"<0>", redeemerCD> : canPickupBuff[4] ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", buffUser[4]>,
                    Location.Left, 5, Color.Rose);
                }
            }
        }
    }

rule: "[Main] :: Player Spawned"
    Event.OngoingPlayer
    if (HasSpawned() /* && matchStarted */)
    if (matchStarted)
    {
        SmallMessage(player, "Welcome!");
        Wait(3);
        SmallMessage(player, <"Holding down <0> will let you gain speed by bunny hopping", InputBindingString(Button.Jump)>);
        Wait(3);
        SmallMessage(player, <"Press <0> to throw out a grappling hook to pull you towards a surface or to pull players towards you", InputBindingString(Button.Ability2)>);
        Wait(3);
        SmallMessage(player, <"Press <0> to fire a projectile that knocks yourself, and enemy players back", IsHero(Hero.Mccree) ? InputBindingString(Button.SecondaryFire) : InputBindingString(Button.Reload)>);
        Wait(3);
        SmallMessage(player, <"Press <0> to dodge in any direction", InputBindingString(Button.Ability1)>);
        Wait(3);
        SmallMessage(player, "Lastly, buffs are littered thorughout the map that give you special changes to your weapon. Have fun!");
    }

rule: "[Main] :: Ashe Primary Cooldown"
    Event.OngoingPlayer
    Player.Ashe
    if (IsFiringPrimary())
    {
        DisallowButton(player, Button.PrimaryFire);
        Wait(1.5);
        AllowButton(player, Button.PrimaryFire);
    }

rule: "[Main] :: Force Respawn"
    Event.OngoingPlayer
    if (IsButtonHeld(player, Button.Jump) /* && IsDead() */)
    if (IsDead())
    {
        Respawn();
    }

rule: "[Main] :: Speedometer & Accuracy HUD Text"
    Event.OngoingPlayer
    if (bhopEnabled && BHOP_MAX_SPEED > 100)
    {
        CreateHudText(player, null, null, <" \n<0> M/S\n<1>% Modifier\n \nAccuracy: <2>%", HorizontalSpeedOf(), RoundToInteger(bhopSpeed - 100, Rounding.Up), RoundToInteger(PlayerStat(player, PlayerStat.WeaponAccuracy) * 100, Rounding.Nearest)>, Location.Left, 10);
    }

rule: "[Main] :: End Game"
    if (matchStarted /* && MatchTime() == 0 */)
    if (MatchTime() == 0)
    {
        EnableCompletion();
    }

rule: "[Main] :: Primary Effect"
    Event.OngoingPlayer
    if (IsFiringPrimary())
    if (primaryFxEnabled) 
    if (!spawnWithWallbang)
    if (!spawnWithRicochet)
    if (!spawnWithBuckshot)
    if (!spawnWithRedeemer)
    if (!wallbangEnabled) 
    if (!ricochetEnabled)
    if (!buckshotEnabled) 
    if (!redeemerEnabled) 
    {
        primaryHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, livingEnemies, player);
        startPos = !IsFiringSecondary() ? WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18 : WorldVectorOf(Right() - Vector(0, 5, 0), player) * 0.1;

        PlayEffect(player, PlayEffect.GoodExplosion, Color.Aqua, primaryHit, 0.2);
        PlayEffect(RemoveFromArray(EnemyPlayers(), player), PlayEffect.GoodExplosion, Color.Red, primaryHit, 0.2);

        define primaryBeam = [];
        CreateBeamEffect(player, BeamType.BadBeam, EyePosition() + Facing() + startPos, primaryHit, Color.Aqua, EffectRev.None);
        primaryBeam[0] = LastCreatedEntity();
        CreateBeamEffect(RemoveFromArray(EnemyPlayers(), player), BeamType.BadBeam, EyePosition() + Facing() + startPos, primaryHit, Color.Red, EffectRev.None);
        primaryBeam[1] = LastCreatedEntity();

        Wait(0.15);
        DestroyEffect(primaryBeam[0]);
        DestroyEffect(primaryBeam[1]);
    }


disabled rule: "---------------- Killing Spree Notifs ----------------"{}

rule: "[Killspree] :: Record Kills"
    Event.OnFinalBlow
    {
        lifeKills++;
    }

rule: "[Killspree] :: Reset Kills on death"
    Event.OnDeath
    {
        DestroyHudText(killsHud);

        if (lifeKills > 5)
        {
            BigMessage(all, !EventWasEnvironment() ? <"<0>'s <1> player spree was ended by <2>!", Victim(), lifeKills, Attacker()> : 
                                                       <"<0>'s <1> player spree was ended by the world!", Victim(), lifeKills>);
            SmallMessage(player, <"<0> player kill spree!", lifeKills>);
        }

        for (define i = 0; i < 7; i++)
        {
            DestroyEffect(spreeEffects[i]);
            DestroyInWorldText(spreeInWorld[i]);
            DestroyHudText(spreeHud[i]);
        }

        Wait(0.032);
        lifeKills = 0;
        spreeInWorld = [];
        spreeEffects = [];
        spreeHud = [];
    }

// @wang - could probably use a subroutine on these killspree rules
// ^ maybe
rule: "[Killspree] :: Killing Spree"
    Event.OnFinalBlow
    if (lifeKills == 6)
    {
        BigMessage(all, <"<0> is on a Killing Spree!", player>);
        CreateInWorldText(player, "Killing Spree!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.White);
        spreeInWorld[0] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.White, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[0] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Killing Spree", Location.Left, 15, Color.White, Color.White, Color.White);
        spreeHud[0] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[0]);
    }

rule: "[Killspree] :: Rampage"
    Event.OnFinalBlow
    if (lifeKills == 8)
    {
        DestroyEffect(spreeEffects[0]);
        DestroyHudText(spreeHud[0]);
        BigMessage(all, <"<0> is on a Rampage!", player>);
        CreateInWorldText(player, "Rampage!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.LimeGreen);
        spreeInWorld[1] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.LimeGreen, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[1] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Rampage", Location.Left, 15, Color.White, Color.White, Color.LimeGreen);
        spreeHud[1] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[1]);
    }

rule: "[Killspree] :: Dominating"
    Event.OnFinalBlow
    if (lifeKills == 11)
    {
        DestroyEffect(spreeEffects[1]);
        DestroyHudText(spreeHud[1]);
        BigMessage(all, <"<0> is Dominating!", player>);
        CreateInWorldText(player, "Dominating!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.SkyBlue);
        spreeInWorld[2] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.SkyBlue, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[2] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Dominating", Location.Left, 15, Color.White, Color.White, Color.SkyBlue);
        spreeHud[2] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[2]);
    }

rule: "[Killspree] :: Unstoppable"
    Event.OnFinalBlow
    if (lifeKills == 14)
    {
        DestroyEffect(spreeEffects[2]);
        DestroyHudText(spreeHud[2]);
        BigMessage(all, <"<0> is Unstoppable!", player>);
        CreateInWorldText(player, "Unstoppable!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Purple);
        spreeInWorld[3] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Violet, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[3] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Unstoppable", Location.Left, 15, Color.White, Color.White, Color.Purple);
        spreeHud[3] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[3]);
    }

rule: "[Killspree] :: Godlike"
    Event.OnFinalBlow
    if (lifeKills == 17)
    {
        DestroyEffect(spreeEffects[3]);
        DestroyHudText(spreeHud[3]);
        BigMessage(all, <"<0> is Godlike!", player>);
        CreateInWorldText(player, "Godlike!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Yellow);
        spreeInWorld[4] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Yellow, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[4] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Godlike", Location.Left, 15, Color.White, Color.White, Color.Yellow);
        spreeHud[4] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[4]);
    }

rule: "[Killspree] :: Divine"
    Event.OnFinalBlow
    if (lifeKills == 21)
    {
        DestroyEffect(spreeEffects[4]);
        DestroyHudText(spreeHud[4]);
        BigMessage(all, <"<0> is Divine!", player>);
        CreateInWorldText(player, "Divine!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Orange);
        spreeInWorld[5] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Orange, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[5] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Divine", Location.Left, 15, Color.White, Color.White, Color.Orange);
        spreeHud[5] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[5]);
    }

rule: "[Killspree] :: Empyreal"
    Event.OnFinalBlow
    if (lifeKills == 24)
    {
        DestroyEffect(spreeEffects[5]);
        DestroyHudText(spreeHud[5]);
        BigMessage(all, <"<0> is Empyreal!", player>);
        CreateInWorldText(player, "Empyreal!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Red);
        spreeInWorld[6] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Red, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[6] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Empyreal", Location.Left, 15, Color.White, Color.White, Color.Red);
        spreeHud[6] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[6]);
    }

disabled rule: "---------------- Bhop ----------------"{}

rule: "[Bhop] :: Auto Hop"
    Event.OngoingPlayer
    if (bhopEnabled/*  && IsOnGround() && IsJumpHeld() */)
    if (IsOnGround())
    if (IsJumpHeld())
    {
        DisableJump();
        MinWait();
        AllowJump();
    }

rule: "[Bhop] :: Starting Speed"
    Event.OngoingPlayer
    {
        bhopSpeed = 100;
    }

rule: "[Bhop] :: If Airborne"
    Event.OngoingPlayer
    if (bhopEnabled && (!usingGrapple && IsJumping() && HorizontalSpeedOf() > 5.14) || (usingGrapple && IsInAir() && DistanceBetween(grappleEyePos, grappleHit) < GRAPPLE_RANGE))
    {
        speedAccumInAir = HorizontalSpeedOf();
        Wait(0.05);
        ChaseVariableAtRate(bhopSpeed, BHOP_MAX_SPEED, BHOP_SPEED_RATE, RateChaseReevaluation.DestinationAndRate);

        isChasing = true;
    }

rule: "[Bhop] :: Update Speed"
    Event.OngoingPlayer
    if (isChasing)
    {
        speedAccumInAir = HorizontalSpeedOf();
        SetMoveSpeed(player, bhopSpeed);
        Wait(0.032);
        LoopIfConditionIsTrue();
    }

rule: "[Bhop] :: Update isChasing"
    Event.OngoingPlayer
    if (isChasing && bhopSpeed == BHOP_MAX_SPEED || bhopSpeed == 100)
    {
        StopChasingVariable(bhopSpeed);
        isChasing = false;
    }

rule: "[Bhop] :: Stop chasing if too slow"
    Event.OngoingPlayer
    if (!usingGrapple && !usingTele && (isChasing || bhopSpeed == BHOP_MAX_SPEED) && HorizontalSpeedOf() < 5.14)
    {
        StopChasingVariable(bhopSpeed);
        isChasing = false;
        bhopSpeed = 100;
        SetMoveSpeed(player, bhopSpeed);
        Wait(0.032);
        LoopIfConditionIsTrue();
    }

rule: "[Bhop] :: Stop if player is on ground"
    Event.OngoingPlayer
    if ((IsOnGround() && !usingGrapple) && (bhopSpeed > 100))
    {
        WaitIfTrue(0.2);
        StopChasingVariable(bhopSpeed);
        bhopSpeed = 100;
        SetMoveSpeed(player, bhopSpeed);
    }

disabled rule: "---------------- Dodge ----------------"{}

rule: "[Dodge] :: Action"
    Event.OngoingPlayer
    if (dodgeEnabled/*  && canDodge && IsAbility1Held() */)
    if (canDodge)
    if (IsAbility1Held())
    {
        throttleOf = ThrottleOf() + Vector(0, 0.5, 0);

        if (throttleOf == Vector(0, 0.5, 0))
            throttleOf = Vector(0, 0.5, 1);

        ApplyImpulse(player, throttleOf, DODGE_FORCE, Relative.ToPlayer, ContraryMotion.Cancel);

        if (bhopSpeed < 120)
            bhopSpeed += BHOP_SPEED_RATE * 3;

        canDodge = false;
    }

rule: "[Dodge] :: On Ground"
    Event.OngoingPlayer
    if (IsOnGround())
    {
        canDodge = true;
    }


disabled rule: "---------------- Secondary Fire ----------------"{}

// playervar define secondaryInAir;
rule: "[Secondary Fire] :: Projectile"
    Event.OngoingPlayer
    if (matchStarted/*  && secondaryEnabled && IsSecondaryHeld() && IsAlive() */)
    if (secondaryEnabled)
    if (IsHero(Hero.Mccree) && IsSecondaryHeld() || !IsHero(Hero.Mccree) && IsReloadHeld())
    if (IsAlive())
    {
        DestroyEffect(secondaryOrb[0]);
        DestroyEffect(secondaryOrb[1]);
        secondaryHit = RayCastHitPosition(EyePosition(), UpdateEveryFrame(EyePosition() + Facing() * 100), AllLivingPlayers(), player);
        secondaryEyePos = UpdateEveryFrame(EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18);

        // secondaryInAir = true;
        PlayEffect(all, PlayEffect.RingExplosionSound, Color.White, player, 50);

        // projectile
        CreateEffect(all, Effect.Orb, Color.Red, secondaryEyePos, 0.1);
        secondaryOrb[0] = LastCreatedEntity();
        CreateEffect(all, Effect.BadAura, Color.Red, secondaryEyePos, 0.5);
        secondaryOrb[1] = LastCreatedEntity();

        ChaseVariableAtRate(secondaryEyePos, secondaryHit, SECONDARY_PROJECTILE_SPEED, RateChaseReevaluation.DestinationAndRate);

        Wait(0.75);
        LoopIfConditionIsTrue();
    }

rule: "[Secondary Fire] :: Impulse"
    Event.OngoingPlayer
    if (DistanceBetween(secondaryEyePos, secondaryHit) < 0.1 || RayCastHitPlayer(EyePosition(), secondaryEyePos, AllLivingPlayers(), player) != null)
    {
        // secondaryInAir = false;
        StopChasingVariable(secondaryEyePos);
        define players = FilteredArray(AllLivingPlayers(), DistanceBetween(Curr(), secondaryEyePos) <= 4.5);
        for (define i = 0; i < CountOf(players); i++)
        {
            ApplyImpulse(players[i], DirectionTowards(secondaryEyePos, players[i] + Up()), 15, Relative.ToWorld, ContraryMotion.Incorporate);
        }
        
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Red, secondaryHit, 2.5);
        // PlayEffect(VisibleTo: all, Type: PlayEffect.RingExplosionSound, Position: player, Radius: 15);
        DestroyEffect(secondaryOrb[0]);
        DestroyEffect(secondaryOrb[1]);
    }

// rule: "[Secondary Fire] :: Effect Loop"
//     Event.OngoingPlayer
//     if (secondaryInAir)
//     {
//         while (secondaryInAir)
//         {
//             PlayEffect(all, PlayEffect.BadExplosion, Color.Red, secondaryEyePos, 0.05);
//             Wait(0.016);
//         }
//     }

disabled rule: "---------------- Grapple ----------------"{}
playervar define grappleBeam;
playervar define grappleSphere;

void EndGrapple() playervar "[Sub] :: End Grapple"
    {
        usingGrapple = false;
        StopForcingThrottle();
        DestroyEffect(grappleSphere);
        DestroyEffect(grappleBeam);
        grappleHitPlayer = null;
    }

rule: "[Grapple] :: Grapple Start"
    Event.OngoingPlayer
    if (matchStarted/*  && grappleEnabled && IsAbility2Held() && IsAlive() */)
    if (grappleEnabled)
    if (IsAbility2Held())
    {
        grappleHit = RayCastHitPosition(EyePosition(), UpdateEveryFrame(EyePosition() + Facing() * GRAPPLE_RANGE), AllLivingPlayers(), player);
        grappleHitPlayer = RayCastHitPlayer(EyePosition(), UpdateEveryFrame(EyePosition() + Facing() * GRAPPLE_RANGE), AllLivingPlayers(), player, true);
        grappleEyePos = EyePosition();

        if (grappleHitPlayer)
        {
            CreateBeamEffect(all, BeamType.GrappleBeam, player, grappleHitPlayer, Color.Yellow, EffectRev.VisibleToPositionAndRadius);
            grappleBeam = LastCreatedEntity();
            
            if (DistanceBetween(grappleEyePos, grappleHit) != GRAPPLE_RANGE)
            {
                CreateEffect(all, Effect.Sphere, Color.Yellow, grappleHitPlayer, 0.2);
                grappleSphere = LastCreatedEntity();
            }
        }
        else 
        {
            CreateBeamEffect(all, BeamType.GrappleBeam, player, grappleHit, Color.Yellow, EffectRev.VisibleToPositionAndRadius);
            grappleBeam = LastCreatedEntity();
            
            if (DistanceBetween(grappleEyePos, grappleHit) != GRAPPLE_RANGE)
            {
                CreateEffect(all, Effect.Sphere, Color.Yellow, grappleHit, 0.2);
                grappleSphere = LastCreatedEntity();
            }
        }

        usingGrapple = true;

        if (DistanceBetween(grappleEyePos, grappleHit) == GRAPPLE_RANGE)
        {
            Wait(0.25);
            EndGrapple();
        }
        else if (DistanceBetween(player, grappleHit) < 3)
        {
            Wait(0.25);
            EndGrapple();
        }
        else
        {
            PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, grappleHit, 0.2);
            PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, player, 0.33);
            PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 100);
        }

        Wait(0.5);
        LoopIf(IsAbility2Held() && IsAlive() && DistanceBetween(grappleEyePos, grappleHit) == GRAPPLE_RANGE);
    }

rule: "[Grapple] :: Pull"
    Event.OngoingPlayer
    if (usingGrapple/*  && DistanceBetween(grappleEyePos, grappleHit) < GRAPPLE_RANGE */)
    if (DistanceBetween(grappleEyePos, grappleHit) < GRAPPLE_RANGE)
    {
        ForceThrottle(player, 0, 0.05, 0, 0.05, 0, 0.05);

        if (grappleHitPlayer && IsAlive(grappleHitPlayer))
            ApplyImpulse(grappleHitPlayer, Vector(0, 0.3, 0) + DirectionTowards(grappleHitPlayer, EyePosition()), GRAPPLE_PULL_SPEED / 1.25, Relative.ToWorld, ContraryMotion.Incorporate);
        else if (IsJumpHeld()) 
            ApplyImpulse(player, Vector(0, 0.3, 0) + DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);
        else
            ApplyImpulse(player, DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);

        Wait(0.064);
        LoopIfConditionIsTrue();
    }

rule: "[Grapple] :: Grapple End Ability 2"
    Event.OngoingPlayer
    if (!IsAbility2Held())
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End On Death"
    Event.OnDeath
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Grappled Player Dead"
    Event.OngoingPlayer
    if (IsDead(grappleHitPlayer))
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Grappled Player Too Close"
    Event.OngoingPlayer
    if (DistanceBetween(player, grappleHitPlayer) < 3)
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Too Close"
    Event.OngoingPlayer
    if (DistanceBetween(player, grappleHit) < 3)
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Out of LOS"
    Event.OngoingPlayer
    if (!IsInLineOfSight(player, grappleHitPlayer))
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Grappled Player out of sight"
    Event.OngoingPlayer
    if (!IsInViewAngle(player, grappleHitPlayer, 105))
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Using Teleporter"
    Event.OngoingPlayer
    if (usingTele)
    {
        EndGrapple();
    }

disabled rule: "---------------- Buff + Tele ----------------"{}

rule: "[Buff + Tele] :: Map Locations"
    {
        // [0]: wallbang
        // [1]: bullet bouncy bouncy go go
        // [2]: buckshot
        // [3]: extra 'life'
        // [4]: redeemer

        // teles:
        // [0] -> [1]
        // [1] -> [0]
        // [2] -> [3]
        // [3] -> [2]

        validMap = false;

        switch (buffsEnabled)
        {
            case (CurrentMap() == Map.Workshop_Chamber || CurrentMap() == Map.Workshop_Expanse || CurrentMap() == Map.Workshop_Expanse_Night || CurrentMap() == Map.Workshop_Island || CurrentMap() == Map.Workshop_Island_Night || CurrentMap() == Map.Workshop_Green_Screen):
                validMap = true;
                buffPos[0] = Vector(0, 1, 2);
                buffPos[1] = Vector(0, 1, -2);
                buffPos[2] = Vector(0, 1, -6);
                buffPos[3] = Vector(0, 1, 6);
                buffPos[4] = Vector(12, 1, 0);

                telePos[0] = Vector(0, -10000, 0);
                teleFacing[0] = Vector(0, 0, 0);
                telePos[1] = Vector(0, -10000, 0);
                teleFacing[1] = Vector(0, 0, 0);
                telePos[2] = Vector(0, -10000, 0);
                teleFacing[2] = Vector(0, 0, 0);
                telePos[3] = Vector(0, -10000, 0);
                teleFacing[3] = Vector(0, 0, 0);
                break;
            case (CurrentMap() == Map.Black_Forest || CurrentMap() == Map.Black_Forest_Winter):
                validMap = true;
                buffPos[0] = Vector(16.79, 12.44, 29.48);
                buffPos[1] = Vector(4.66, 18.28, 5.00);
                buffPos[2] = Vector(16.18, 12.36, -20.11);
                buffPos[3] = Vector(-25.49, 13.09, 5.00);
                buffPos[4] = Vector(21.00, 10.00, 5.00);
                
                telePos[0] = Vector(29.09, 11, 4.97);
                teleFacing[0] = Vector(-1, 0, 0);
                telePos[1] = Vector(-31.25, 14.96, 5.00);
                teleFacing[1] = Vector(1, 0, 0);
                telePos[2] = Vector(35.92, 14, -26.70);
                teleFacing[2] = Vector(-0.85, 0, 0.52);
                telePos[3] = Vector(37.47, 14, 37.26);
                teleFacing[3] = Vector(-0.87, 0, -0.50);
                break;
            case (CurrentMap() == Map.Blizzard_World || CurrentMap() == Map.Blizzard_World_Winter):
                validMap = true;
                buffPos[0] = Vector(-32.50, 0.61, 73.15);
                buffPos[1] = Vector(-77.28, 5.88, 66.15);
                buffPos[2] = Vector(-54.50, 0.61, 110.20);
                buffPos[3] = Vector(-67.55, 1.75, 138.74);
                buffPos[4] = Vector(-25.04, 1.29, 109.95);
                
                telePos[0] = Vector(-82.73, 2.46, 60.72);
                teleFacing[0] = Vector(0.71, 0, 0.71);
                telePos[1] = Vector(-72.27, 3.75, 157.62);
                teleFacing[1] = Vector(0.27, 0, -0.96);
                telePos[2] = Vector(-15.39, 4, 63.37);
                teleFacing[2] = Vector(-0.71, 0, 0.71);
                telePos[3] = Vector(-101.27, 2.75, 90.34);
                teleFacing[3] = Vector(0.96, 0, 0.29);
                break;
            case (CurrentMap() == Map.Castillo):
                validMap = true;
                buffPos[0] = Vector(-106.18, 40.56, 43.20);
                buffPos[1] = Vector(-115.85, 39.57, 60.92);
                buffPos[2] = Vector(-100.35, 40.56, 73.75);
                buffPos[3] = Vector(-74.82, 33.00, 52.93);
                buffPos[4] = Vector(-85.65, 39.64, 55.00);
                
                telePos[0] = Vector(-131.30, 36.38, 63.88);
                teleFacing[0] = Vector(0.98, 0, -0.20);
                telePos[1] = Vector(-72.11, 34.59, 48.36);
                teleFacing[1] = Vector(-0.53, 0, 0.85);
                telePos[2] = Vector(-86.30, 34.56, 85.75);
                teleFacing[2] = Vector(-0.22, 0, -0.97);
                telePos[3] = Vector(-97.60, 34.56, 27.19);
                teleFacing[3] = Vector(0.15, 0, 0.98);
                break;
            case (CurrentMap() == Map.Chateau_Guillard || CurrentMap() == Map.Chateau_Guillard_Halloween):
                validMap = true;
                buffPos[0] = Vector(206.31, 9.03, 101.90);
                buffPos[1] = Vector(206.31, 9.00, 61.91);
                buffPos[2] = Vector(180.60, 10, 101.93);
                buffPos[3] = Vector(206.19, 1, 77.96);
                buffPos[4] = Vector(229.12, 14.00, 61.97);

                telePos[0] = Vector(193.14, 11, 117.07);
                teleFacing[0] = Vector(0, 0, -1);
                telePos[1] = Vector(201.08, 10, 44.50);
                teleFacing[1] = Vector(0, 0, 1);
                telePos[2] = Vector(165.76, 7, 81.01);
                teleFacing[2] = Vector(1, 0, 0);
                telePos[3] = Vector(206.26, 2, 84.50);
                teleFacing[3] = Vector(0, 0, -1);
                break;
            case (CurrentMap() == Map.Dorado):
                validMap = true;
                buffPos[0] = Vector(115.66, 8.73, -7.08);
                buffPos[1] = Vector(85.30, 13.75, 29.84);
                buffPos[2] = Vector(98.04, 19.01, 15.26);
                buffPos[3] = Vector(131.27, 12.05, 26.12);
                buffPos[4] = Vector(76.87, 9.00, 7.34);

                telePos[0] = Vector(137.96, 13, 28.06);
                teleFacing[0] = Vector(-0.96, 0, -0.28);
                telePos[1] = Vector(92.75, 11, -23.05);
                teleFacing[1] = Vector(0.57, 0, 0.82);
                telePos[2] = Vector(112.44, 13, 50.55);
                teleFacing[2] = Vector(0.27, 0, -0.96);
                telePos[3] = Vector(165.12, 12.01, -5.92);
                teleFacing[3] = Vector(-1, 0, -0.05);
                break;
            case (CurrentMap() == Map.Ecopoint_Antarctica || CurrentMap() == Map.Ecopoint_Antarctica_Winter):
                validMap = true;
                buffPos[0] = Vector(1.66, 12.63, -25.00);
                buffPos[1] = Vector(-19.50, 13.00, 0.00);
                buffPos[2] = Vector(1.66, 12.63, 25.00);
                buffPos[3] = Vector(20.50, 10.00, 0.00);
                buffPos[4] = Vector(18.70, 5.00, 0.00);

                telePos[0] = Vector(24.30, 11, 0);
                teleFacing[0] = Vector(-1, 0, 0);
                telePos[1] = Vector(-35.11, 11, 0);
                teleFacing[1] = Vector(1, 0, 0);
                telePos[2] = Vector(12.20, 10.18, 54.16);
                teleFacing[2] = Vector(-0.29, 0, -0.96);
                telePos[3] = Vector(12.21, 10.16, -54.15);
                teleFacing[3] = Vector(-0.29, 0, 0.96);
                break;
            case (CurrentMap() == Map.Eichenwalde || CurrentMap() == Map.Eichenwalde_Halloween):
                validMap = true;
                buffPos[0] = Vector(55.70, 22.00, -67.84);
                buffPos[1] = Vector(58.33, 5.72, -90.39);
                buffPos[2] = Vector(76.03, 11.69, -109.66);
                buffPos[3] = Vector(88.13, 13.67, -67.39);
                buffPos[4] = Vector(30.76, 15.00, -81.88);

                telePos[0] = Vector(89.08, 14.81, -63.58);
                teleFacing[0] = Vector(-0.30, 0, -0.95);
                telePos[1] = Vector(35.93, 6.93, -63.79);
                teleFacing[1] = Vector(0.92, 0, -0.39);
                telePos[2] = Vector(53.57, 12.72, -124.58);
                teleFacing[2] = Vector(0.24, 0, 0.97);
                telePos[3] = Vector(105.83, 14.72, -110.91);
                teleFacing[3] = Vector(-0.90, 0, 0.44);
                break;
            case (CurrentMap() == Map.Havana):
                validMap = true;
                buffPos[0] = Vector(9.50, 7.00, -79.23);
                buffPos[1] = Vector(37.64, 11.00, -94.23);
                buffPos[2] = Vector(27.92, 13.00, -61.96);
                buffPos[3] = Vector(64.50, 13.00, -83.33);
                buffPos[4] = Vector(40.74, 6.82, -83.33);

                telePos[0] = Vector(0, -10000, 0);
                teleFacing[0] = Vector(0, 0, 0);
                telePos[1] = Vector(0, -10000, 0);
                teleFacing[1] = Vector(0, 0, 0);
                telePos[2] = Vector(0, -10000, 0);
                teleFacing[2] = Vector(0, 0, 0);
                telePos[3] = Vector(0, -10000, 0);
                teleFacing[3] = Vector(0, 0, 0);
                break;
            case (CurrentMap() == Map.Hollywood || CurrentMap() == Map.Hollywood_Halloween):
                validMap = true;
                buffPos[0] = Vector(-11.91, 2.73, -74.64);
                buffPos[1] = Vector(-4.09, 2.60, -15.87);
                buffPos[2] = Vector(20.67, 2.60, -51.82);
                buffPos[3] = Vector(7.87, 13.90, -48.38);
                buffPos[4] = Vector(18.51, 5.69, -28.41);

                telePos[0] = Vector(2.18, 3.75, -2.50);
                teleFacing[0] = Vector(0.78, 0, -0.63);
                telePos[1] = Vector(-1.11, 3.60, -83.00);
                teleFacing[1] = Vector(0.25, 0, 0.97);
                telePos[2] = Vector(-27.85, 7.75, -38.88);
                teleFacing[2] = Vector(0.52, 0, -0.86);
                telePos[3] = Vector(53.28, 4.75, -56.83);
                teleFacing[3] = Vector(-0.98, 0, 0.22);
                break;
            case (CurrentMap() == Map.Kings_Row || CurrentMap() == Map.Kings_Row_Winter):
                validMap = true;
                buffPos[0] = Vector(-49.46, 1.00, 2.69);
                buffPos[1] = Vector(-31.19, 10.00, -13.40);
                buffPos[2] = Vector(-93.67, 8.50, -29.38);
                buffPos[3] = Vector(-48.85, 10.12, -37.62);
                buffPos[4] = Vector(-92.15, 2.10, 7.65);

                telePos[0] = Vector(-91.81, 3.12, 11.97);
                teleFacing[0] = Vector(0.07, 0, -1);
                telePos[1] = Vector(-30.90, 8, -51.25);
                teleFacing[1] = Vector(-0.17, 0, 0.97);
                telePos[2] = Vector(-36.75, 2.07, -34.78);
                teleFacing[2] = Vector(-1, 0, 0.09);
                telePos[3] = Vector(-99.91, 3.01, -8.54);
                teleFacing[3] = Vector(0.99, 0, -0.16);
                break;
            case (CurrentMap() == Map.Lijiang_Control_Center || CurrentMap() == Map.Lijiang_Control_Center_Lunar):
                validMap = true;
                buffPos[0] = Vector(-26.80, 268.00, 308.00);
                buffPos[1] = Vector(0.00, 271.00, 323.00);
                buffPos[2] = Vector(26.80, 268.00, 308.00);
                buffPos[3] = Vector(0.00, 271.00, 260.65);
                buffPos[4] = Vector(0.00, 279.00, 291.85);

                telePos[0] = Vector(0, 272, 329.50);
                teleFacing[0] = Vector(0, 0, -1);
                telePos[1] = Vector(0, 272, 266.10);
                teleFacing[1] = Vector(0, 0, 1);
                telePos[2] = Vector(-26.78, 269, 333.84);
                teleFacing[2] = Vector(-0.71, 0, -0.71);
                telePos[3] = Vector(26.78, 269, 333.84);
                teleFacing[3] = Vector(0.71, 0, -0.71);
                break;
            case (CurrentMap() == Map.Necropolis):
                validMap = true;
                buffPos[0] = Vector(1.68, 12.70, 17.25);
                buffPos[1] = Vector(-21.05, 13.71, 0);
                buffPos[2] = Vector(1.80, 12.70, -16.41);
                buffPos[3] = Vector(8.50, 2.01, 0.00);
                buffPos[4] = Vector(23.08, 5.99, 0.00);

                telePos[0] = Vector(0, -10000, 0);
                teleFacing[0] = Vector(0, 0, 0);
                telePos[1] = Vector(0, -10000, 0);
                teleFacing[1] = Vector(0, 0, 0);
                telePos[2] = Vector(0, -10000, 0);
                teleFacing[2] = Vector(0, 0, 0);
                telePos[3] = Vector(0, -10000, 0);
                teleFacing[3] = Vector(0, 0, 0);
                break;
            case (CurrentMap() == Map.Paris):
                validMap = true;
                buffPos[0] = Vector(-104.10, 16.00, -100.65);
                buffPos[1] = Vector(-109.18, 11.00, -60.60);
                buffPos[2] = Vector(-57.19, 14.00, -82.00);
                buffPos[3] = Vector(-73.39, 11.02, -38.23);
                buffPos[4] = Vector(-85.93, 13.00, -64.09);

                telePos[0] = Vector(-50.33, 11.27, -43.73);
                teleFacing[0] = Vector(-0.84, 0, -0.54);
                telePos[1] = Vector(-105.87, 17, -104.22);
                teleFacing[1] = Vector(0.44, 0, 0.90);
                telePos[2] = Vector(-53.82, 15, -84.22);
                teleFacing[2] = Vector(-0.90, 0, 0.44);
                telePos[3] = Vector(-109.57, 13.06, -29.32);
                teleFacing[3] = Vector(-0.15, 0, -0.99);
                break;
            case (CurrentMap() == Map.Oasis_City_Center):
                validMap = true;
                buffPos[0] = Vector(154.48, 12.52, 258.48);
                buffPos[1] = Vector(122.22, 5, 268.75);
                buffPos[2] = Vector(164.76, 5, 226.22);
                buffPos[3] = Vector(118.01, 2, 221.96);
                buffPos[4] = Vector(143.48, 3.15, 247.50);

                telePos[0] = Vector(91.77, 3, 306.13);
                teleFacing[0] = Vector(0.80, 0, -0.52);
                telePos[1] = Vector(201.98, 3, 195.90);
                teleFacing[1] = Vector(-0.52, 0, 0.80);
                telePos[2] = Vector(166.19, 22.5, 270.22);
                teleFacing[2] = Vector(-0.71, 0, -0.71);
                telePos[3] = Vector(114.92, 2.80, 218.92);
                teleFacing[3] = Vector(0.71, 0, 0.71);
                break; 
            case (CurrentMap() == Map.Oasis_University):
                validMap = true;
                buffPos[0] = Vector(-172, 18, 0);
                buffPos[1] = Vector(-188, 16, 38);
                buffPos[2] = Vector(-188, 16, -38);
                buffPos[3] = Vector(-188, 10.40, 0);
                buffPos[4] = Vector(-217.72, 20, 0);

                telePos[0] = Vector(-165.00, 18, -12.75);
                teleFacing[0] = Vector(0.06, 0, -1);
                telePos[1] = Vector(-165.00, 18, 12.75);
                teleFacing[1] = Vector(0.04, 0, 1);
                telePos[2] = Vector(-188, 21.83, 69.32);
                teleFacing[2] = Vector(0, 0, -0.25);
                telePos[3] = Vector(188, 21.88, -69.44);
                teleFacing[3] = Vector(0, 0, 0.25);
                break; 
            case (CurrentMap() == Map.Nepal_Sanctum):
                validMap = true;
                buffPos[0] = Vector(83.25, 129.45, 0);
                buffPos[1] = Vector(81, 132.65, -24);
                buffPos[2] = Vector(81, 132.65, 24);
                buffPos[3] = Vector(51.38, 130.71, 0);
                buffPos[4] = Vector(104.83, 129, 0);

                telePos[0] = Vector(81, 133.38, -84.31);
                teleFacing[0] = Vector(0, 0, 1);
                telePos[1] = Vector(81, 133.38, 84.31);
                teleFacing[1] = Vector(0, 0, -1);
                telePos[2] = Vector(106.25, 134, -25.50);
                teleFacing[2] = Vector(-1, 0, 0);
                telePos[3] = Vector(106.25, 134, 25.50);
                teleFacing[3] = Vector(-1, 0, 0);
                break;
            case (CurrentMap() == Map.Nepal_Village):
                validMap = true;
                buffPos[0] = Vector(-178.37, -89, 35.49);
                buffPos[1] = Vector(-178.37, -89, -35.49);
                buffPos[2] = Vector(-213.90, -87, 0);
                buffPos[3] = Vector(-215.90, -93, 0);
                buffPos[4] = Vector(-174, -87.11, 0);

                telePos[0] = Vector(-194.36, -91.93, 33.31);
                teleFacing[0] = Vector(0, 0, 1);
                telePos[1] = Vector(-194.37, -91.91, -33.16);
                teleFacing[1] = Vector(0, 0, -1);
                telePos[2] = Vector(-157.27, -86.74, 0);
                teleFacing[2] = Vector(-1, 0, 0);
                telePos[3] = Vector(-222.50, -86.20, 0);
                teleFacing[3] = Vector(1, 0, 0);
                break;
            case (CurrentMap() == Map.Petra):
                validMap = true;
                buffPos[0] = Vector(-6.39, -0.21, 49.19);
                buffPos[1] = Vector(2, -10, 23);
                buffPos[2] = Vector(2, 2, -7.40);
                buffPos[3] = Vector(42.53, 14.31, 33.58);
                buffPos[4] = Vector(-38.43, -11.84, 18);

                telePos[0] = Vector(15.28, -10.48, 63.09);
                teleFacing[0] = Vector(-0.27, 0, -0.96);
                telePos[1] = Vector(-17.87, 2.10, -14.80);
                teleFacing[1] = Vector(0, 0, 1);
                telePos[2] = Vector(38.19, -8.04, 27.57);
                teleFacing[2] = Vector(-0.93, 0, 0.35);
                telePos[3] = Vector(-36.19, -10.45, 21);
                teleFacing[3] = Vector(-0.46, 0, -0.89);
                break;
        }
    }

globalvar define telePos;
globalvar define teleFacing;
playervar define usingTele;
playervar define teleThrottle;

void TeleImpulse() playervar "[Sub] :: Teleporter Impulse"
    {
        SetGravity(player, 0);

        ApplyImpulse(player, Up(), 0.001);
        ApplyImpulse(player, Down(), 0.001);
        ApplyImpulse(player, Forward(), 0.001);
        ApplyImpulse(player, Backward(), 0.001);
        ApplyImpulse(player, Left(), 0.001);
        ApplyImpulse(player, Right(), 0.001);

        teleThrottle = ThrottleOf() + Vector(0, 0.25, 1);

        if (ThrottleOf() == Vector(XOf(ThrottleOf()), 0, -1))
            teleThrottle = Vector(0, 0.25, 1);

        Wait(0.08);
        SetGravity(player, 100);
        ApplyImpulse(player, teleThrottle, 20, Relative.ToPlayer, ContraryMotion.Cancel);

        Wait(1.5);
        usingTele = false;
    }

void TeleportSub() playervar "[Sub] :: Teleport"
    {
        if (IsInLineOfSight(player, telePos[enIndex]))
        {
            usingTele = true;
            Teleport(player, telePos[exIndex]);
            SetFacing(player, teleFacing[exIndex] + Vector(0, YOf(Facing()), 0));
            PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, player, 1);
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, telePos[enIndex], 3);

            TeleImpulse();
        }
    }

globalvar define enIndex;
globalvar define exIndex;

rule: "[Tele] :: Create Tele Effects"
    if (validMap)
    if (matchStarted)
    if (teleEnabled)
    {
        for (define i = 0; i < 4; i++)
        {
            CreateEffect(all, Effect.BadAura, Color.Violet, telePos[i], 2, EffectRev.None);
        }
    }

rule: "[Tele] :: 0 to 1"
    Event.OngoingPlayer
    // if (!usingTele && teleEnabled && validMap && IsInLineOfSight(player, telePos[0]) && DistanceBetween(telePos[0], player) < 3)
    if (!usingTele && teleEnabled && validMap)
    if (DistanceBetween(telePos[0], player) < 3)
    {
        enIndex = 0;
        exIndex = 1;
        TeleportSub();
    }

rule: "[Tele] :: 1 to 0"
    Event.OngoingPlayer
    // if (!usingTele && teleEnabled && validMap && IsInLineOfSight(player, telePos[1]) && DistanceBetween(telePos[1], player) < 3)
    if (!usingTele && teleEnabled && validMap)
    if (DistanceBetween(telePos[1], player) < 3)
    {
        enIndex = 1;
        exIndex = 0;
        TeleportSub();
    }

rule: "[Tele] :: 2 to 3"
    Event.OngoingPlayer
    // if (!usingTele && teleEnabled && validMap && IsInLineOfSight(player, telePos[2]) && DistanceBetween(telePos[2], player) < 3)
    if (!usingTele && teleEnabled && validMap)
    if (DistanceBetween(telePos[2], player) < 3)
    {
        enIndex = 2;
        exIndex = 3;
        TeleportSub();
    }

rule: "[Tele] :: 3 to 2"
    Event.OngoingPlayer
    // if (!usingTele && teleEnabled && validMap && IsInLineOfSight(player, telePos[3]) && DistanceBetween(telePos[3], player) < 3)
    if (!usingTele && teleEnabled && validMap)
    if (DistanceBetween(telePos[3], player) < 3)
    {
        enIndex = 3;
        exIndex = 2;
        TeleportSub();
    }

rule: "[Buff] :: Buff Owner Leave"
    Event.OnPlayerLeave
    {
        if (player == buffUser[0])
        {
            LogToInspector("Wallbang user no longer exists");
            WallbangCooldown();
        }

        if (player == buffUser[1])
        {
            LogToInspector("Riochet user no longer exists");
            RicochetCooldown();
        }

        if (player == buffUser[2])
        {
            LogToInspector("Buckshot user no longer exists");
            BuckshotCooldown();
        }

        if (player == buffUser[3])
        {
            LogToInspector("Extra life user no longer exists");
            LifeCooldown();
        }

        if (player == buffUser[4])
        {
            LogToInspector("Redeemer user no longer exists");
            RedeemerCooldown();
        }
    }

// globalvar define sphereInProgressEffect;
// globalvar define ringInProgressEffect;
globalvar define wallbangPBar;
// globalvar define wallbangSphereSize;
globalvar define ricochetPBar;
// globalvar define ricochetSphereSize;
globalvar define buckshotPBar;
// globalvar define buckshotSphereSize;
globalvar define lifePBar;
// globalvar define lifeSphereSize;
globalvar define redeemerPBar;
// globalvar define redeemerSphereSize;

globalvar define wallbangTimer;
globalvar define ricochetTimer;
globalvar define buckshotTimer;
globalvar define lifeTimer;
globalvar define redeemerTimer;

void WallbangCooldown() "[Sub] :: Wallbang Cooldown" 
    {
        if (!spawnWithWallbang && spawnWallbang)
        {
            if (!EntityExists(buffUser[0]) && wallbangCD == 0)
                    wallbangCD = WALLBANG_CD;
    
            if (wallbangCD == WALLBANG_CD)
            {
                LogToInspector("Wallbang cooldown started");
                wallbangPBar = 0;
                wallbangTimer = true;

                if (cdType == 0)
                    ChaseVariableOverTime(wallbangPBar, 100, WALLBANG_CD, TimeChaseReevaluation.None);
            }

            // destroy and recreate the effects, just in case
            // DestroyEffect(sphereInProgressEffect[0]);
            // DestroyEffect(ringInProgressEffect[0]);
            DestroyProgressBarInWorldText(cdText[0]);
            DestroyInWorldText(cdText[0]);

            MinWait();

            // if (cdIP)
            // {
            //     CreateEffect(all, Effect.Sphere, Color.Yellow, buffPos[0], wallbangPBar * 0.004, EffectRev.PositionAndRadius);
            //     sphereInProgressEffect[0] = LastCreatedEntity();

            //     CreateEffect(all, Effect.Ring, Color.Yellow, buffPos[0] - Vector(0, 1, 0), wallbangPBar * 0.004, EffectRev.PositionAndRadius);
            //     ringInProgressEffect[0] = LastCreatedEntity();
            // }

            if (cdType == 0)
            {
                CreateProgressBarInWorldText(all, wallbangPBar, null, buffPos[0]/*  + Vector(0, wallbangPBar * 0.004, 0) */, 0, Clipping.ClipAgainstSurfaces, Color.Yellow, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
                cdText[0] = LastTextID();
            }
            else if (cdType == 1)
            {
                CreateInWorldText(all, wallbangCD, buffPos[0], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
                cdText[0] = LastTextID();
            }
        }
    }

void RicochetCooldown() "[Sub] :: Ricochet Cooldown"
    {
        if (!spawnWithRicochet && spawnRicochet)
        {
            if (!EntityExists(buffUser[1]) && ricochetCD == 0)
                ricochetCD = RICOCHET_CD;

            if (ricochetCD == RICOCHET_CD)
            {
                LogToInspector("Riochet cooldown started");
                ricochetPBar = 0;
                ricochetTimer = true;

                if (cdType == 0)
                    ChaseVariableOverTime(ricochetPBar, 100, RICOCHET_CD, TimeChaseReevaluation.None);
            }
            
            // destroy and recreate the effects, just in case
            // DestroyEffect(sphereInProgressEffect[1]);
            // DestroyEffect(ringInProgressEffect[1]);
            DestroyProgressBarInWorldText(cdText[1]);
            DestroyInWorldText(cdText[1]);

            MinWait();

            // if (cdIP)
            // {
            //     CreateEffect(all, Effect.Sphere, Color.Violet, buffPos[1], ricochetPBar * 0.004, EffectRev.PositionAndRadius);
            //     sphereInProgressEffect[1] = LastCreatedEntity();

            //     CreateEffect(all, Effect.Ring, Color.Violet, buffPos[1] - Vector(0, 1, 0), ricochetPBar * 0.004, EffectRev.PositionAndRadius);
            //     ringInProgressEffect[1] = LastCreatedEntity();
            // }

            if (cdType == 0)
            {
                CreateProgressBarInWorldText(all, ricochetPBar, null, buffPos[1]/*  + Vector(0, ricochetPBar * 0.004, 0) */, 0, Clipping.ClipAgainstSurfaces, Color.Violet, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
                cdText[1] = LastTextID();
            }
            else if (cdType == 1)
            {
                CreateInWorldText(all, ricochetCD, buffPos[1], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
                cdText[1] = LastTextID();
            }
        }
    }

void BuckshotCooldown() "[Sub] :: Buckshot Cooldown"
    {
        if (!spawnWithBuckshot && spawnBuckshot)
        {
            if (!EntityExists(buffUser[2]) && buckshotCD == 0)
                buckshotCD = BUCKSHOT_CD;
    
            if (buckshotCD == BUCKSHOT_CD)
            {
                LogToInspector("Buckshot cooldown started");
                buckshotPBar = 0;
                buckshotTimer = true;

                if (cdType == 0)
                    ChaseVariableOverTime(buckshotPBar, 100, BUCKSHOT_CD, TimeChaseReevaluation.None);
            }

            // destroy and recreate the effects, just in case
            // DestroyEffect(sphereInProgressEffect[2]);
            // DestroyEffect(ringInProgressEffect[2]);
            DestroyProgressBarInWorldText(cdText[2]);
            DestroyInWorldText(cdText[2]);

            MinWait();

            // if (cdIP)
            // {
            //     CreateEffect(all, Effect.Sphere, Color.Green, buffPos[2], buckshotPBar * 0.004, EffectRev.PositionAndRadius);
            //     sphereInProgressEffect[2] = LastCreatedEntity();

            //     CreateEffect(all, Effect.Ring, Color.Green, buffPos[2] - Vector(0, 1, 0), buckshotPBar * 0.004, EffectRev.PositionAndRadius);
            //     ringInProgressEffect[2] = LastCreatedEntity();
            // }

            if (cdType == 0)
            {
                CreateProgressBarInWorldText(all, buckshotPBar, null, buffPos[2]/*  + Vector(0, buckshotPBar * 0.004, 0) */, 0, Clipping.ClipAgainstSurfaces, Color.Green, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
                cdText[2] = LastTextID();
            }
            else if (cdType == 1)
            {
                CreateInWorldText(all, buckshotCD, buffPos[2], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
                cdText[2] = LastTextID();
            }
        }
    }

void LifeCooldown() "[Sub] :: Life Cooldown"
    {
        if (!spawnWithLife && spawnLife)
        {
            if (!EntityExists(buffUser[3]) && lifeCD == 0)
                lifeCD = LIFE_CD;

            if (lifeCD == LIFE_CD)
            {
                LogToInspector("Extra Life cooldown started");
                lifePBar = 0;
                lifeTimer = true;

                if (cdType == 0)
                    ChaseVariableOverTime(lifePBar, 100, LIFE_CD, TimeChaseReevaluation.None);
            }

            // destroy and recreate the effects, just in case
            // DestroyEffect(sphereInProgressEffect[3]);
            // DestroyEffect(ringInProgressEffect[3]);
            DestroyProgressBarInWorldText(cdText[3]);
            DestroyInWorldText(cdText[3]);

            MinWait();

            // if (cdIP)
            // {
            //     CreateEffect(all, Effect.Sphere, Color.SkyBlue, buffPos[3], lifePBar * 0.004, EffectRev.PositionAndRadius);
            //     sphereInProgressEffect[3] = LastCreatedEntity();

            //     CreateEffect(all, Effect.Ring, Color.SkyBlue, buffPos[3] - Vector(0, 1, 0), lifePBar * 0.004, EffectRev.PositionAndRadius);
            //     ringInProgressEffect[3] = LastCreatedEntity();
            // }

            if (cdType == 0)
            {
                CreateProgressBarInWorldText(all, lifePBar, null, buffPos[3]/*  + Vector(0, lifePBar * 0.004, 0) */, 0, Clipping.ClipAgainstSurfaces, Color.Blue, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
                cdText[3] = LastTextID(); 
            }
            else if (cdType == 1)
            {
                CreateInWorldText(all, lifeCD, buffPos[3], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
                cdText[3] = LastTextID(); 
            }
        }
    }

void RedeemerCooldown() "[Sub] :: Redeemer Cooldown"
    {
        if (!spawnWithRedeemer && spawnRedeemer)
        {
            if (!EntityExists(buffUser[4]) && redeemerCD == 0)
                redeemerCD = REDEEMER_CD;

            if (redeemerCD == REDEEMER_CD)
            {
                LogToInspector("Redeemer cooldown started");
                redeemerPBar = 0;
                redeemerTimer = true;

                if (cdType == 0)
                    ChaseVariableOverTime(redeemerPBar, 100, REDEEMER_CD, TimeChaseReevaluation.None);
            }
            
            // destroy and recreate the effects, just in case
            // DestroyEffect(sphereInProgressEffect[4]);
            // DestroyEffect(ringInProgressEffect[4]);
            DestroyProgressBarInWorldText(cdText[4]);
            DestroyInWorldText(cdText[4]);

            MinWait();

            // if (cdIP)
            // {
            //     CreateEffect(all, Effect.Sphere, Color.Rose, buffPos[4], redeemerPBar * 0.004);
            //     sphereInProgressEffect[4] = LastCreatedEntity();

            //     CreateEffect(all, Effect.Ring, Color.Rose, buffPos[4] - Vector(0, 1, 0), redeemerPBar * 0.004);
            //     ringInProgressEffect[4] = LastCreatedEntity();
            // }
            
            if (cdType == 0)
            {
                CreateProgressBarInWorldText(all, redeemerPBar, null, buffPos[4]/*  + Vector(0, redeemerPBar * 0.004, 0) */, 0, Clipping.ClipAgainstSurfaces, Color.Rose, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
                cdText[4] = LastTextID();
            }
            else if (cdType == 1)
            {
                CreateInWorldText(all, redeemerCD, buffPos[4], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
                cdText[4] = LastTextID();
            }
        }
    }

rule: "[Buff] :: Wallbang Timer"
    if (wallbangTimer)
    {
        wallbangCD--;
        Wait(1);
        LoopIfConditionIsTrue();
    }

rule: "[Buff] :: Ricochet Timer"
    if (ricochetTimer)
    {
        ricochetCD--;
        Wait(1);
        LoopIfConditionIsTrue();
    }

rule: "[Buff] :: Buckshot Timer"
    if (buckshotTimer)
    {
        buckshotCD--;
        Wait(1);
        LoopIfConditionIsTrue();
    }

rule: "[Buff] :: Life Timer"
    if (lifeTimer)
    {
        lifeCD--;
        Wait(1);
        LoopIfConditionIsTrue();
    }

rule: "[Buff] :: Redeemer Timer"
    if (redeemerTimer)
    {
        redeemerCD--;
        Wait(1);
        LoopIfConditionIsTrue();
    }

playervar define bIndex;
globalvar define buffColor;
globalvar define collectedBuffEffect;
globalvar define canPickupBuff;
globalvar define buffUser;
// playervar define buffEnabled;

void CollectBuff() playervar "[Sub] :: Collect Buff"
    {
        canPickupBuff[bIndex] = false;
        buffUser[bIndex] = player;

        if (bIndex == 0)
        {
            LogToInspector(<"Wallbang Enabled for <0>", buffUser[0]>);
            canPickupBuff[0] = false;
            wallbangEnabled = true;

            // toasts
            CreateProgressBarHudText(player, wallbangDur, <"<0> Wallbang <0>", AbilityIconString(Hero.Baptiste, Button.Ultimate)>, Location.Right, 0.3, Color.Yellow, Color.Yellow);
            hudText[0] = LastTextID();
            SmallMessage(player, "Your bullets go through walls!");
            BigMessage(player, "Wallbang");

            // start timer
            wallbangDur = 100;
            ChaseVariableOverTime(wallbangDur, 0, WALLBANG_DUR, TimeChaseReevaluation.None);
        }
        else if (bIndex == 1)
        {
            LogToInspector(<"Ricochet Enabled for <0>", buffUser[1]>);
            canPickupBuff[1] = false;
            ricochetEnabled = true;

            // toasts
            CreateProgressBarHudText(player, ricochetDur, <"<0> Ricochet <0>", AbilityIconString(Hero.Winston, Button.Ability1)>, Location.Right, 0.4, Color.Violet, Color.Violet);
            hudText[1] = LastTextID();
            SmallMessage(player, "Your bullets ricochet off walls!");
            BigMessage(player, "Ricochet");

            // start timer
            ricochetDur = 100;
            ChaseVariableOverTime(ricochetDur, 0, RICOCHET_DUR, TimeChaseReevaluation.None);
        }
        else if (bIndex == 2)
        {
            LogToInspector(<"Buckshot Enabled for <0>", buffUser[2]>);
            canPickupBuff[2] = false;
            buckshotEnabled = true;

            // toasts
            CreateProgressBarHudText(player, buckshotDur, <"<0> Buckshot <0>", AbilityIconString(Hero.Ashe, Button.Ability1)>, Location.Right, 0.5, Color.Green, Color.Green);
            hudText[2] = LastTextID();
            BigMessage(player, "Buckshot");
            SmallMessage(player, "Your bullets spread like a shotgun!");

            // start timer
            buckshotDur = 100;
            ChaseVariableOverTime(buckshotDur, 0, BUCKSHOT_DUR, TimeChaseReevaluation.None);
        }
        else if (bIndex == 3)
        {
            LogToInspector(<"Extra Life Enabled for <0>", buffUser[3]>);
            canPickupBuff[3] = false;
            lifeEnabled = true;

            // toasts
            CreateProgressBarHudText(player, lifeDur, <"<0> Extra Life <0>", AbilityIconString(Hero.Mercy, Button.Ability2)>, Location.Right, 0.3, Color.Blue, Color.Blue);
            hudText[3] = LastTextID();
            SmallMessage(player, "Extra Life");
            BigMessage(player, "Extra Life");

            // start timer
            lifeDur = 100;
            ChaseVariableOverTime(lifeDur, 0, LIFE_DUR, TimeChaseReevaluation.None);
        }
        else if (bIndex == 4)
        {
            LogToInspector(<"Redeemer Enabled for <0>", buffUser[4]>);
            canPickupBuff[4] = false;
            redeemerEnabled = true;

            // toasts
            CreateProgressBarHudText(player, redeemerDur, <"<0> Redeemer <0>", AbilityIconString(Hero.Symmetra, Button.Ultimate)>, Location.Right, 0.5, Color.Rose, Color.Rose);
            hudText[4] = LastTextID();
            BigMessage(player, "Redeemer");
            SmallMessage(player, "Your bullets explode!");

            // start timer
            redeemerDur = 100;
            ChaseVariableOverTime(redeemerDur, 0, REDEEMER_DUR, TimeChaseReevaluation.None);
        }

        // destroy inworld text / icon / orb
        DestroyProgressBarInWorldText(cdText[bIndex]);
        DestroyInWorldText(cdText[bIndex]);
        // DestroyEffect(sphereInProgressEffect[bIndex]);
        // DestroyEffect(ringInProgressEffect[bIndex]);
        DestroyInWorldText(buffIcon[bIndex]);
        DestroyEffect(buffEffect[bIndex]);

        // pickup effects
        PlayEffect(all, PlayEffect.GoodPickupEffect, buffColor, buffPos[bIndex], 1);
        PlayEffect(all, PlayEffect.BuffExplosionSound, buffColor, buffPos[bIndex], 200);

        // create effect
        CreateEffect(IsAlive() ? all : null, Effect.GoodAura, buffColor, player, 0.5, EffectRev.None);
        collectedBuffEffect[bIndex] = LastCreatedEntity();

        bIndex = 99;
        buffColor = null;
    }

disabled rule: "---------------- Wallbang ----------------"{}

rule: "[Buff] :: Wallbang : Create Orb"
    if (matchStarted/*  && validMap && !spawnWithWallbang && spawnWallbang && wallbangCD == 0 */)
    if (validMap)
    if (!spawnWithWallbang)
    if (spawnWallbang)
    if (wallbangCD == 0)
    {
        canPickupBuff[0] = true;
        LogToInspector("Wallbang Orb Created");
        // DestroyEffect(sphereInProgressEffect[0]);
        CreateEffect(all, Effect.Orb, Color.Yellow, buffPos[0], 2, EffectRev.None);
        buffEffect[0] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Yellow, buffPos[0], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Baptiste, Button.Ultimate), buffPos[0] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, EffectRev.None);
        buffIcon[0] = LastTextID();

        DestroyProgressBarInWorldText(cdText[0]);
        DestroyInWorldText(cdText[0]);
        wallbangTimer = false;
        StopChasingVariable(wallbangPBar);
    }

rule: "[Buff] :: Wallbang : Collect"
    Event.OngoingPlayer
    if (matchStarted/*  && canPickupBuff[0] && DistanceBetween(buffPos[0], player) < 2.5 && IsAlive() */)
    if (canPickupBuff[0])
    if (DistanceBetween(buffPos[0], player) < 2.5)
    if (IsAlive())
    {
        bIndex = 0;
        buffColor = Color.Yellow;
        CollectBuff();

        Wait(WALLBANG_DUR - 4);
        for (define sound; 4; 1)
        {
            PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
            Wait(1);
        }
    }

rule: "[Buff] :: Wallbang : Remove"
    Event.OngoingPlayer
    if (wallbangEnabled/*  && wallbangDur == 0 */)
    if (wallbangDur == 0)
    {
        Wait(0.128);
        LogToInspector(<"Wallbang Disabled for <0>", buffUser[0]>);

        // destroy hud timer and player effect
        DestroyProgressBarHudText(hudText[0]);
        DestroyEffect(collectedBuffEffect[0]);
        StopChasingVariable(wallbangDur);

        wallbangEnabled = false;
        // buffUser[0] = null;
        wallbangCD = WALLBANG_CD;

        // start in world cooldown
        WallbangCooldown(); 
    }

rule: "[Buff] :: Wallbang : Action"
    Event.OngoingPlayer
    if ((wallbangEnabled || spawnWithWallbang)/*  && IsFiringPrimary() */)
    if (IsFiringPrimary())
    {
        define gunPos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        define wallbangHitPos = EyePosition();

        define wallbangHitPlayer;

        for (define wallbangCount = 0; DistanceBetween(gunPos, wallbangHitPos) < 100 && wallbangCount < NUM_WALLBANGS; wallbangCount++)
        {
            wallbangHitPos = RayCastHitPosition(wallbangHitPos + Facing(), UpdateEveryFrame(wallbangHitPos + Facing() * (100 - DistanceBetween(gunPos, wallbangHitPos))), AllLivingPlayers(), player, true);
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, wallbangHitPos, 0.2);
            wallbangHitPlayer = RayCastHitPlayer(wallbangHitPos, UpdateEveryFrame(wallbangHitPos + Facing() * (100 - DistanceBetween(gunPos, wallbangHitPos))), AllLivingPlayers(), player, true);

            if (wallbangHitPlayer != null && wallbangHitPlayer != player)
            {
                Damage(wallbangHitPlayer, player, 10000);
            }

            if (wallbangDbg)
            {
                DestroyEffect(wbDbgEffects[wallbangCount]);
                DestroyEffect(wbDbgBeam[wallbangCount]);
                CreateEffect(all, Effect.Sphere, Color.Yellow, wallbangHitPos, 0.25, EffectRev.None);
                wbDbgEffects[wallbangCount] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, EyePosition(), wallbangHitPos, Color.Yellow, EffectRev.None);
                wbDbgBeam[wallbangCount] = LastCreatedEntity();
            }
        }

        CreateBeamEffect(all, BeamType.BadBeam, gunPos, wallbangHitPos, Color.Yellow, EffectRev.None);
        wallbangEffect[0] = LastCreatedEntity();
        // PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, gunPos, 0.2);

        Wait(0.25);
        DestroyEffect(wallbangEffect[0]);
    }

disabled rule: "---------------- Ricochet ----------------"{}

rule: "[Buff] :: Ricochet : Create Orb"
    if (matchStarted/*  && validMap && !spawnWithRicochet && spawnRicochet && ricochetCD == 0 */)
    if (validMap)
    if (!spawnWithRicochet)
    if (spawnRicochet)
    if (ricochetCD == 0)
    {
        LogToInspector("Ricochet Orb Created");
        canPickupBuff[1] = true;

        // DestroyEffect(sphereInProgressEffect[1]);
        CreateEffect(all, Effect.Orb, Color.Violet, buffPos[1], 2, EffectRev.None);
        buffEffect[1] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Violet, buffPos[1], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Winston, Button.Ability1), buffPos[1] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, EffectRev.None);
        buffIcon[1] = LastTextID();

        DestroyProgressBarInWorldText(cdText[1]);
        DestroyInWorldText(cdText[1]);
        ricochetTimer = false;
        StopChasingVariable(ricochetPBar);
    }

rule: "[Buff] :: Ricochet : Collect"
    Event.OngoingPlayer
    if (matchStarted/*  && canPickupBuff[1] && DistanceBetween(buffPos[1], player) < 2.5 && IsAlive() */)
    if (canPickupBuff[1])
    if (DistanceBetween(buffPos[1], player) < 2.5)
    if (IsAlive())
    {
        bIndex = 1;
        buffColor = Color.Violet;
        CollectBuff();

        Wait(RICOCHET_DUR - 4);
        for (define sound; 4; 1)
        {
            PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
            Wait(1);
        }
    }

rule: "[Buff] :: Ricochet : Remove"
    Event.OngoingPlayer
    if (ricochetEnabled/*  && ricochetDur == 0 */)
    if (ricochetDur == 0)
    {
        Wait(0.128);
        LogToInspector(<"Riochet Disabled for <0>", buffUser[1]>);
        // destroy hud timer and player effect
        DestroyProgressBarHudText(hudText[1]);
        DestroyEffect(collectedBuffEffect[1]);
        StopChasingVariable(ricochetDur);

        ricochetEnabled = false;
        // buffUser[1] = null;
        ricochetCD = RICOCHET_CD;

        // start in world cooldown
        RicochetCooldown(); 
    }


rule: "[Buff] :: Ricochet : Action"
    Event.OngoingPlayer
    if ((ricochetEnabled || spawnWithRicochet)/*  && IsFiringPrimary() */)
    if (IsFiringPrimary())
    {
        // https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector
        define normals = [];
        define hitPos = [];
        define hitPosPlayer = [];
        define ricochets = [];
        define hitPosRicochets = [];
        define hitPosPlayerRicochets = [];
        define ricochetEffects = [];
        define ricochetEffect = [];

        eyePos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        facing = Facing();

        for (define i = 0; i < NUM_RICOCHETS; i++)
        {
            if (i > 0)
            {
                eyePos = hitPos[i - 1];
                facing = ricochets[i - 1];
            }

            normals[i] = RayCastHitNormal(eyePos, eyePos + facing * 100, AllLivingPlayers(), player, true);
            hitPos[i] = RayCastHitPosition(eyePos, UpdateEveryFrame(eyePos + facing * 100), AllLivingPlayers(), player, true);
            hitPosPlayer[i] = RayCastHitPlayer(eyePos, eyePos + facing * 100, AllLivingPlayers(), player, true);
            ricochets[i] = facing - (2 * (normals[i] * DotProduct(facing, normals[i])));
            hitPosRicochets[i] = RayCastHitPosition(hitPos[i], hitPos[i] + ricochets[i] * 100, AllLivingPlayers(), player, true);
            hitPosPlayerRicochets[i] = RayCastHitPlayer(hitPos[i], hitPos[i] + ricochets[i] * 100, AllLivingPlayers(), player, true);

            CreateBeamEffect(all, BeamType.BadBeam, eyePos, hitPos[i], Color.Violet, EffectRev.None); // first raycast hit
            ricochetEffect[i] = LastCreatedEntity();

            CreateBeamEffect(all, BeamType.BadBeam, hitPos[i], hitPosRicochets[i], Color.Violet, EffectRev.None); // ricochets
            ricochetEffects[i] = LastCreatedEntity();

            // PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, eyePos, 0.2); // muzzle flash
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, hitPos[i], 0.2); // first raycast hit
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, hitPosRicochets[i], 0.2); // ricochets

            Damage(hitPosPlayer[i], player, 10000);
            Damage(hitPosPlayerRicochets[i], player, 10000);

            if (ricochetDbg)
            {
                DestroyEffect(rDbgEffects[0][i]);
                DestroyEffect(rDbgEffects[1][i]);
                DestroyEffect(rDbgBeam[0][i]);
                DestroyEffect(rDbgBeam[1][i]);
                CreateEffect(all, Effect.Sphere, Color.Violet, hitPos[i], 0.25, EffectRev.None);
                rDbgEffects[0][i] = LastCreatedEntity();
                CreateEffect(all, Effect.Sphere, Color.Violet, hitPosRicochets[i], 0.25, EffectRev.None);
                rDbgEffects[1][i] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, eyePos, hitPos[i], Color.Violet, EffectRev.None);
                rDbgBeam[0][i] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, hitPos[i], hitPosRicochets[i], Color.Violet, EffectRev.None);
                rDbgBeam[1][i] = LastCreatedEntity();
            }
        }

        Wait(0.15);
        for (define i = 0; i < NUM_RICOCHETS; i++)
        {
            DestroyEffect(ricochetEffect[i]);
            DestroyEffect(ricochetEffects[i]);
        }
    }

disabled rule: "---------------- Buckshot ----------------"{}

rule: "[Buff] :: Buckshot : Create Orb"
    if (matchStarted/*  && validMap && !spawnWithBuckshot && spawnBuckshot && buckshotCD == 0 */)
    if (validMap)
    if (!spawnWithBuckshot)
    if (spawnBuckshot)
    if (buckshotCD == 0)
    {
        LogToInspector("Buckshot Orb Created");
        canPickupBuff[2] = true;

        // DestroyEffect(sphereInProgressEffect[2]);
        CreateEffect(all, Effect.Orb, Color.Green, buffPos[2], 2, EffectRev.None);
        buffEffect[2] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Green, buffPos[2], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Ashe, Button.Ability1), buffPos[2] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, EffectRev.None);
        buffIcon[2] = LastTextID();

        DestroyProgressBarInWorldText(cdText[2]);
        DestroyInWorldText(cdText[2]);
        buckshotTimer = false;
        StopChasingVariable(buckshotPBar);
    }

rule: "[Buff] :: Buckshot : Collect"
    Event.OngoingPlayer
    if (matchStarted/*  && canPickupBuff[2] && DistanceBetween(buffPos[2], player) < 2.5 && IsAlive() */)
    if (canPickupBuff[2])
    if (DistanceBetween(buffPos[2], player) < 2.5)
    if (IsAlive())
    {
        bIndex = 2;
        buffColor = Color.Green;
        CollectBuff();

        Wait(BUCKSHOT_DUR - 4);
        for (define sound; 4; 1)
        {
            PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
            Wait(1);
        }
    }

rule: "[Buff] :: Buckshot : Remove"
    Event.OngoingPlayer
    if (buckshotEnabled/*  && buckshotDur == 0 */)
    if (buckshotDur == 0)
    {
        Wait(0.128);

        LogToInspector(<"Buckshot Disabled for <0>", buffUser[2]>);

        // destroy hud timer and player effect
        DestroyProgressBarHudText(hudText[2]);
        DestroyEffect(collectedBuffEffect[2]);
        StopChasingVariable(buckshotDur);

        buckshotEnabled = false;
        // buffUser[2] = null;
        buckshotCD = BUCKSHOT_CD;

        // start in world cooldown
        BuckshotCooldown(); 
    }

rule: "[Buff] :: Buckshot : Action"
    Event.OngoingPlayer
    if ((buckshotEnabled || spawnWithBuckshot)/*  && IsFiringPrimary() */)
    if (IsFiringPrimary())
    {
        buckshotHitPos = [];
        buckshotHitPlayer = [];
        define gunPos = WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        define buckshotBeam = [];
        define centerBeam;

        spreadDiag = BUCKSHOT_SPREAD - (BUCKSHOT_SPREAD * 0.33);
        spreadHori = BUCKSHOT_SPREAD;

        // center
        buckshotCenter = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, livingEnemies, player);

        // lower left
        buckshotHitPos[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        // upper left
        buckshotHitPos[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        // lower right
        buckshotHitPos[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        // upper right
        buckshotHitPos[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        // lower mid
        buckshotHitPos[4] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadHori) 
        * 100, AllLivingPlayers(), player, false);

        // upper mid
        buckshotHitPos[5] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadHori) 
        * 100, AllLivingPlayers(), player, false);

        // mid left
        buckshotHitPos[6] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadHori) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        * 100, AllLivingPlayers(), player, false);

        // mid right
        buckshotHitPos[7] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadHori) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        * 100, AllLivingPlayers(), player, false);

        // player

        buckshotHitPlayer[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag)
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag)
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[4] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadHori) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[5] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadHori) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[6] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadHori) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[7] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadHori) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        * 100, AllLivingPlayers(), player, false);
        
        // PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, EyePosition() + Facing() + gunPos, 0.2); // muzzle flash
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotCenter, 0.2);

        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotCenter, Color.Green, EffectRev.None);
        centerBeam = LastCreatedEntity();

        for (define pellets = 0; pellets < 8; pellets++)
        {
            Damage(buckshotHitPlayer[pellets], player, 10000);

            PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotHitPos[pellets], 0.2);

            CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotHitPos[pellets], Color.Green, EffectRev.None);
            buckshotBeam[pellets] = LastCreatedEntity();
        }

        Wait(0.25);
        DestroyEffect(centerBeam);
        for (define beams = 0; beams < 8; beams++)
        {
            DestroyEffect(buckshotBeam[beams]);
        }
    }

disabled rule: "---------------- Extra Life ----------------"{}

rule: "[Buff] :: Extra Life : Create Orb"
    if (matchStarted/*  && validMap && !spawnWithLife && spawnLife && lifeCD == 0 */)
    if (validMap)
    if (!spawnWithLife)
    if (spawnLife)
    if (lifeCD == 0)
    {
        canPickupBuff[3] = true;

        // DestroyEffect(sphereInProgressEffect[3]);
        CreateEffect(all, Effect.Orb, Color.SkyBlue, buffPos[3], 2, EffectRev.None);
        buffEffect[3] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.SkyBlue, buffPos[3], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Mercy, Button.Ability2), buffPos[3] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, EffectRev.None);
        buffIcon[3] = LastTextID();

        DestroyProgressBarInWorldText(cdText[3]);
        DestroyInWorldText(cdText[3]);
        lifeTimer = false;
        StopChasingVariable(lifePBar);
    }

rule: "[Buff] :: Extra Life : Collect"
    Event.OngoingPlayer
    if (matchStarted/*  && !lifeEnabled && canPickupBuff[3] && DistanceBetween(buffPos[3], player) < 2.5 && IsAlive() */)
    if (!lifeEnabled)
    if (canPickupBuff[3])
    if (DistanceBetween(buffPos[3], player) < 2.5)
    if (IsAlive())
    {
        bIndex = 3;
        buffColor = Color.SkyBlue;
        CollectBuff();

        Wait(LIFE_DUR - 4);
        for (define sound; 4; 1)
        {
            PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
            Wait(1);
        }
    }

rule: "[Buff] :: Extra Life : Remove"
    Event.OngoingPlayer
    if (lifeEnabled/*  && (lifeDur == 0 || (Health() == 1 || IsDead())) */)
    if (lifeDur == 0 || (Health() == 1 || IsDead()))
    {
        ClearStatus(player, Status.Unkillable);
        Wait(0.128);

        LogToInspector(<"Extra Life Disabled for <0>", buffUser[3]>);

        if (Health() == 1 || IsDead())
        {
            SmallMessage(player, "Extra life used");
            PlayEffect(player, PlayEffect.DebuffImpactSound, Color.White, player, 200);
        }

        // destroy
        DestroyInWorldText(extraLifeIcon);
        DestroyProgressBarHudText(hudText[3]);
        DestroyEffect(lifeBuffEffect);
        StopChasingVariable(lifeDur);

        lifeEnabled = false;
        // buffUser[3] = null;
        lifeCD = LIFE_CD;

        // start in world cooldown
        LifeCooldown(); 

        Wait(1);
        SetPlayerHealth(player, MaxHealth());
    }

rule: "[Buff] :: Extra Life : Action"
    Event.OngoingPlayer
    if (lifeEnabled || (spawnWithLife && IsAlive()))
    {
        SetStatus(player, null, Status.Unkillable, 10000);

        // create effect
        CreateEffect(IsAlive() ? all : null, Effect.BadAura, Color.SkyBlue, player, 0.5, EffectRev.VisibleTo);
        lifeBuffEffect = LastCreatedEntity();

        // create icon above player
        CreateInWorldText(all, AbilityIconString(Hero.Mercy, Button.Ability2), player, 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
        extraLifeIcon = LastTextID();
    }

disabled rule: "---------------- Redeemer ----------------" {}

globalvar define spawnWithRedeemer;
globalvar define spawnRedeemer;
globalvar define redeemerCD;
globalvar define REDEEMER_CD;
globalvar define REDEEMER_DUR;
globalvar define REDEEMER_DELAY;
playervar define redeemerEnabled;
playervar define redeemerDur;

rule: "[Buff] :: Redeemer : Create Orb"
    if (matchStarted/*  && validMap && !spawnWithRedeemer && spawnRedeemer && redeemerCD == 0 */)
    if (validMap)
    if (!spawnWithRedeemer)
    if (spawnRedeemer)
    if (redeemerCD == 0)
    {
        LogToInspector("Redeemer Orb Created");
        canPickupBuff[4] = true;

        // DestroyEffect(sphereInProgressEffect[4]);
        CreateEffect(all, Effect.Orb, Color.Rose, buffPos[4], 2, EffectRev.None);
        buffEffect[4] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Rose, buffPos[4], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Symmetra, Button.Ultimate), buffPos[4] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, EffectRev.None);
        buffIcon[4] = LastTextID();

        DestroyProgressBarInWorldText(cdText[4]);
        DestroyInWorldText(cdText[4]);
        redeemerTimer = false;
        StopChasingVariable(redeemerPBar);
    }

rule: "[Buff] :: Redeemer : Collect"
    Event.OngoingPlayer
    if (matchStarted/*  && canPickupBuff[4] && DistanceBetween(buffPos[4], player) < 2.5 && IsAlive() */)
    if (canPickupBuff[4])
    if (DistanceBetween(buffPos[4], player) < 2.5)
    if (IsAlive())
    {
        bIndex = 4;
        buffColor = Color.Rose;
        CollectBuff();

        Wait(REDEEMER_DUR - 4);
        for (define sound; 4; 1)
        {
            PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
            Wait(1);
        }
    }

rule: "[Buff] :: Redeemer : Remove"
    Event.OngoingPlayer
    if (redeemerEnabled/*  && redeemerDur == 0 */)
    if (redeemerDur == 0)
    {
        AllowButton(player, Button.PrimaryFire);
        Wait(0.128);

        LogToInspector(<"Redeemer Disabled for <0>", buffUser[4]>);

        // destroy hud timer and player effect
        DestroyProgressBarHudText(hudText[4]);
        DestroyEffect(collectedBuffEffect[4]);
        StopChasingVariable(redeemerDur);

        redeemerEnabled = false;
        // buffUser[4] = null;
        redeemerCD = REDEEMER_CD;

        // start in world cooldown
        RedeemerCooldown(); 
    }

globalvar define REDEEMER_ESIZE;
playervar define redeemerHitPos;
playervar define redeemerS;
playervar define redeemerEBeams;
playervar define redeemerEffect;
playervar define redeemerRaycasts;
playervar define redeemerIcon;
define redeemerCheck: FilteredArray(RemoveFromArray(AllLivingPlayers(), player), (DistanceBetween(Curr(), redeemerHitPos) <= REDEEMER_ESIZE) && IsInLineOfSight(Curr(), redeemerHitPos));

rule: "[Buff] :: Redeemer : Action"
    Event.OngoingPlayer
    if ((redeemerEnabled || spawnWithRedeemer)/*  && IsFiringPrimary() */)
    if (IsFiringPrimary())
    {
        redeemerHitPos = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, livingEnemies, player);
        startPos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;

        CreateIcon(redeemerCheck, redeemerHitPos, Icon.Warning, IconRev.VisibleTo, Color.Red, true);
        redeemerIcon = LastCreatedEntity();

        CreateBeamEffect(all, BeamType.BadBeam, startPos, redeemerHitPos, Color.Rose, EffectRev.None);
        redeemerEffect[0] = LastCreatedEntity();

        CreateEffect(all, Effect.Orb, Color.Rose, redeemerHitPos, 1);
        redeemerEffect[1] = LastCreatedEntity();

        CreateEffect(all, Effect.GoodAura, Color.Rose, redeemerHitPos, redeemerS);
        redeemerEffect[2] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Rose, redeemerHitPos, 3);

        redeemerS = 5;
        ChaseVariableOverTime(redeemerS, 0.3, REDEEMER_DELAY);

        DisallowButton(player, Button.PrimaryFire);
        Wait(0.25);
        DestroyEffect(redeemerEffect[0]);

        Wait(REDEEMER_DELAY - 0.25);
        DestroyIcon(redeemerIcon);
        AllowButton(player, Button.PrimaryFire);

        StopChasingVariable(redeemerS);

        DestroyEffect(redeemerEffect[1]);
        DestroyEffect(redeemerEffect[2]);

        PlayEffect(all, PlayEffect.BadExplosion, Color.Rose, redeemerHitPos, REDEEMER_ESIZE);
        PlayEffect(all, PlayEffect.ExplosionSound, Position: redeemerHitPos, Radius: 200);

        // redeemerRaycasts[0] = RayCastHitPosition(redeemerHitPos, redeemerHitPos + Up() * 100);

        define players = redeemerCheck;
        for (define i = 0; i < CountOf(players); i++)
        {
            Damage(players[i], player, 10000);
        }
        // for (define i = 0; i < 5; i++)
        // {
        //     CreateBeamEffect(all, BeamType.BadBeam, redeemerHitPos, redeemerRaycasts[i], Color.Rose);
        //     redeemerEBeams[i] = LastCreatedEntity();
        // }

        // Wait(0.25);
        // for (define i = 0; i < 5; i++)
        // {
        //     DestroyEffect(redeemerEBeams[i]);
        // }
    }

// rule: "[Debug] :: Kill"
//     Event.OngoingPlayer
//     if (player == host && IsInteractHeld())
//     {
//         Kill();
//     }

// rule: "[Debug] :: Hud Text"
//     {
//         CreateHudText(host, null, null, <"Pos: <0>", PositionOf(host)>, Location.Top, 10);
//         CreateHudText(host, null, null, <"Facing: <0>", FacingDirectionOf(host)>, Location.Top, 10);
//     }

// rule: "[Debug] :: Bots"
//     Event.OngoingPlayer
//     if (player == host && IsInteractHeld() && !IsCrouchHeld())
//     {
//         CreateDummyBot(HeroOf(), OppositeTeamOf(TeamOf()), -1, RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100), Facing() * -1);
//     }

// rule: "[Debug] :: Destroy Bots"
//     Event.OngoingPlayer
//     if (player == host && IsCrouchHeld() && IsInteractHeld())
//     {
//         DestroyAllDummyBots();
//     }

// rule: "[Debug] :: Show OW Spawn Points"
//     if (matchStarted)
//     {
//         for (define i = 0; i < CountOf(SpawnPoints()); i++)
//             CreateEffect(all, Effect.Ring, Color.White, SpawnPoints()[i], 1, EffectRev.None);
//     }

// rule: "[Degug] :: Bots Hold Left Click"
//     Event.OngoingPlayer
//     if (IsDummyBot())
//     {
//         StartHoldingButton(player, Button.PrimaryFire);
//     }