import "macros.del";
import "instagibSettings.json";
import "jacob script\ruler.del";

any weapon_muzzle: WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;

// .########..##.....##..#######..########.
// .##.....##.##.....##.##.....##.##.....##
// .##.....##.##.....##.##.....##.##.....##
// .########..#########.##.....##.########.
// .##.....##.##.....##.##.....##.##.......
// .##.....##.##.....##.##.....##.##.......
// .########..##.....##..#######..##.......
globalvar num S_BHOP_MAX_SPEED;
globalvar num S_BHOP_SPEED_RATE;
playervar num bhop_speed;
playervar bool is_chasing;
// playervar vec horizontal_facing_vector;


// ..######...########.....###....########..########..##.......########
// .##....##..##.....##...##.##...##.....##.##.....##.##.......##......
// .##........##.....##..##...##..##.....##.##.....##.##.......##......
// .##...####.########..##.....##.########..########..##.......######..
// .##....##..##...##...#########.##........##........##.......##......
// .##....##..##....##..##.....##.##........##........##.......##......
// ..######...##.....##.##.....##.##........##........########.########
globalvar num S_GRAPPLE_PULL_SPEED;
globalvar num S_GRAPPLE_RANGE;
globalvar bool[] s_grapple_option;
playervar bool using_grapple;
playervar vec grapple_hit;
playervar player grapple_hit_player;
playervar any grapple_beam;
playervar any grapple_sphere;



// ..######..########..######...#######..##....##.########.....###....########..##....##
// .##....##.##.......##....##.##.....##.###...##.##.....##...##.##...##.....##..##..##.
// .##.......##.......##.......##.....##.####..##.##.....##..##...##..##.....##...####..
// ..######..######...##.......##.....##.##.##.##.##.....##.##.....##.########.....##...
// .......##.##.......##.......##.....##.##..####.##.....##.#########.##...##......##...
// .##....##.##.......##....##.##.....##.##...###.##.....##.##.....##.##....##.....##...
// ..######..########..######...#######..##....##.########..##.....##.##.....##....##...
globalvar num S_SEC_PSPEED;
globalvar num S_SEC_RADIUS;
playervar vec sec_eyepos;
playervar any sec_orb;
// playervar bool sec_in_air;
playervar vec sec_rc_start;
playervar vec sec_rc_end;


// .##.....##.####..######...######.
// .###...###..##..##....##.##....##
// .####.####..##..##.......##......
// .##.###.##..##...######..##......
// .##.....##..##........##.##......
// .##.....##..##..##....##.##....##
// .##.....##.####..######...######.
globalvar num S_MATCH_TIME_LIMIT;
// globalvar num S_PRI_DELAY;
globalvar num S_PICKUP_RAD;
playervar vec pri_hit;
playervar bool bhopping;
// globalvar bool s_use_cxhair;
// globalvar bool s_pri_delay;


// .##.....##....###....########..######..##.....##....########...#######...#######..##........######.
// .###...###...##.##......##....##....##.##.....##....##.....##.##.....##.##.....##.##.......##....##
// .####.####..##...##.....##....##.......##.....##....##.....##.##.....##.##.....##.##.......##......
// .##.###.##.##.....##....##....##.......#########....########..##.....##.##.....##.##........######.
// .##.....##.#########....##....##.......##.....##....##.....##.##.....##.##.....##.##.............##
// .##.....##.##.....##....##....##....##.##.....##....##.....##.##.....##.##.....##.##.......##....##
// .##.....##.##.....##....##.....######..##.....##....########...#######...#######..########..######.
globalvar bool match_started;
globalvar bool s_grapple_enabled;
globalvar bool s_dodge_enabled;
globalvar bool s_sec_enabled;
globalvar bool s_pri_fx_enabled;
globalvar bool s_bhop_enabled;


// .########...#######..########...######...########
// .##.....##.##.....##.##.....##.##....##..##......
// .##.....##.##.....##.##.....##.##........##......
// .##.....##.##.....##.##.....##.##...####.######..
// .##.....##.##.....##.##.....##.##....##..##......
// .##.....##.##.....##.##.....##.##....##..##......
// .########...#######..########...######...########
globalvar num S_DODGE_FORCE;
playervar vec throttle_of;
playervar bool can_dodge;


// .########..##.....##.########.########..######.
// .##.....##.##.....##.##.......##.......##....##
// .##.....##.##.....##.##.......##.......##......
// .########..##.....##.######...######....######.
// .##.....##.##.....##.##.......##.............##
// .##.....##.##.....##.##.......##.......##....##
// .########...#######..##.......##........######.
globalvar any[] sphere_ip_effect;
globalvar bool s_buffs_enabled;
globalvar bool s_buffs_spawn_at_start;
globalvar bool valid_map;
globalvar any buff_effect;
globalvar vec buff_pos;
globalvar any buff_icon;
globalvar any cd_txt;
globalvar num s_cd_type;
playervar any hud_txt;
globalvar bool s_buff_hud_txt;
globalvar bool s_cd_ip_timer;
playervar num b_index;
globalvar color buff_color;
globalvar any[] collected_buff_effect;
globalvar bool[] can_pickup_buff;
globalvar player[] buff_user;
playervar bool has_buff;


// .##....##.####.##.......##...........######..########..########..########.########
// .##...##...##..##.......##..........##....##.##.....##.##.....##.##.......##......
// .##..##....##..##.......##..........##.......##.....##.##.....##.##.......##......
// .#####.....##..##.......##...........######..########..########..######...######..
// .##..##....##..##.......##................##.##........##...##...##.......##......
// .##...##...##..##.......##..........##....##.##........##....##..##.......##......
// .##....##.####.########.########.....######..##........##.....##.########.########
playervar num life_kills;
playervar any spree_iwt;
playervar any spree_effect;
playervar any spree_hud;
playervar color streak_color;
playervar str streak_str;


// .##......##....###....##.......##.......########.....###....##....##..######..
// .##..##..##...##.##...##.......##.......##.....##...##.##...###...##.##....##.
// .##..##..##..##...##..##.......##.......##.....##..##...##..####..##.##.......
// .##..##..##.##.....##.##.......##.......########..##.....##.##.##.##.##...####
// .##..##..##.#########.##.......##.......##.....##.#########.##..####.##....##.
// .##..##..##.##.....##.##.......##.......##.....##.##.....##.##...###.##....##.
// ..###..###..##.....##.########.########.########..##.....##.##....##..######..

// setup
globalvar num S_WALLBANG_CD;
globalvar num S_WALLBANG_AMMO;
globalvar num wallbang_cd;
playervar num wallbang_ammo;
globalvar num wallbang_pb;
globalvar bool wallbang_timer;
globalvar bool s_spawn_wallbang;
globalvar bool s_always_wallbang;
playervar bool wallbang_enabled;
globalvar str wallbang_txt;

// logic
globalvar num S_NUM_WALLBANGS;
playervar any wallbang_effect;
// playervar str wh_txt;


// .########..####..######...#######...######..##.....##.########.########
// .##.....##..##..##....##.##.....##.##....##.##.....##.##..........##...
// .##.....##..##..##.......##.....##.##.......##.....##.##..........##...
// .########...##..##.......##.....##.##.......#########.######......##...
// .##...##....##..##.......##.....##.##.......##.....##.##..........##...
// .##....##...##..##....##.##.....##.##....##.##.....##.##..........##...
// .##.....##.####..######...#######...######..##.....##.########....##...

// setup
globalvar num S_RICOCHET_AMMO;
globalvar num S_RICOCHET_CD;
globalvar num ricochet_cd;
playervar num ricochet_ammo;
globalvar num ricochet_pb;
globalvar bool ricochet_timer;
globalvar bool s_spawn_ricochet;
globalvar bool s_always_ricochet;
playervar bool ricochet_enabled;
globalvar str ricochet_txt;

// logic
globalvar num S_NUM_RICOCHETS;
playervar vec eye_pos;
playervar vec facing;


// .########..##.....##..######..##....##..######..##.....##..#######..########
// .##.....##.##.....##.##....##.##...##..##....##.##.....##.##.....##....##...
// .##.....##.##.....##.##.......##..##...##.......##.....##.##.....##....##...
// .########..##.....##.##.......#####.....######..#########.##.....##....##...
// .##.....##.##.....##.##.......##..##.........##.##.....##.##.....##....##...
// .##.....##.##.....##.##....##.##...##..##....##.##.....##.##.....##....##...
// .########...#######...######..##....##..######..##.....##..#######.....##...

// setup
globalvar num S_BUCKSHOT_AMMO;
globalvar num S_BUCKSHOT_CD;
globalvar num buckshot_cd;
playervar num buckshot_ammo;
globalvar num buckshot_pb;
globalvar bool buckshot_timer;
globalvar bool s_spawn_buckshot;
globalvar bool s_always_buckshot;
playervar bool buckshot_enabled;
globalvar str buckshot_txt;

// logic
globalvar num S_BUCKSHOT_SPREAD;
playervar num charge_lvl;


// ..######..##.....##....###....########..########....##........#######...######..##....##
// .##....##.###...###...##.##...##.....##....##.......##.......##.....##.##....##.##...##.
// .##.......####.####..##...##..##.....##....##.......##.......##.....##.##.......##..##..
// ..######..##.###.##.##.....##.########.....##.......##.......##.....##.##.......#####...
// .......##.##.....##.#########.##...##......##.......##.......##.....##.##.......##..##..
// .##....##.##.....##.##.....##.##....##.....##.......##.......##.....##.##....##.##...##.
// ..######..##.....##.##.....##.##.....##....##.......########..#######...######..##....##

// setup
globalvar num S_LOCK_AMMO;
globalvar num S_LOCK_CD;
globalvar num lock_cd;
playervar num lock_ammo;
globalvar num lock_pb;
globalvar bool lock_timer;
globalvar bool s_spawn_lock;
globalvar bool s_always_lock;
playervar bool lock_enabled;
globalvar str lock_txt;

// logic
globalvar num S_LOCK_RADIUS;
globalvar num S_LOCK_TIME;
playervar player[] locking_targets;
playervar player[] locked_targets;
playervar any lock_id;
playervar any locking_id;


// ..#######..##.....##....###....########...######..##.....##..#######..########
// .##.....##.##.....##...##.##...##.....##.##....##.##.....##.##.....##....##...
// .##.....##.##.....##..##...##..##.....##.##.......##.....##.##.....##....##...
// .##.....##.##.....##.##.....##.##.....##..######..#########.##.....##....##...
// .##..##.##.##.....##.#########.##.....##.......##.##.....##.##.....##....##...
// .##....##..##.....##.##.....##.##.....##.##....##.##.....##.##.....##....##...
// ..#####.##..#######..##.....##.########...######..##.....##..#######.....##...

// setup
globalvar num S_QUADSHOT_AMMO;
globalvar num S_QUADSHOT_CD;
globalvar num quadshot_cd;
playervar num quadshot_ammo;
globalvar num quadshot_pb;
globalvar bool quadshot_timer;
globalvar bool s_spawn_quadshot;
globalvar bool s_always_quadshot;
playervar bool quadshot_enabled;
globalvar str quadshot_txt;

// logic
globalvar num S_QUADSHOT_SPREAD;


// .##.....##....###....########...#######..########..####.########.########.########.
// .##.....##...##.##...##.....##.##.....##.##.....##..##.......##..##.......##.....##
// .##.....##..##...##..##.....##.##.....##.##.....##..##......##...##.......##.....##
// .##.....##.##.....##.########..##.....##.########...##.....##....######...########.
// ..##...##..#########.##........##.....##.##...##....##....##.....##.......##...##..
// ...##.##...##.....##.##........##.....##.##....##...##...##......##.......##....##.
// ....###....##.....##.##.........#######..##.....##.####.########.########.##.....##

// setup
globalvar num S_VAP_AMMO;
globalvar num S_VAP_CD;
globalvar num vap_cd;
playervar num vap_ammo;
globalvar num vap_pb;
globalvar bool vap_timer;
globalvar bool s_spawn_vap;
globalvar bool s_always_vap;
playervar bool vap_enabled;
globalvar str vap_txt;

// logic
globalvar num S_VAP_DELAY;
globalvar num S_VAP_ESIZE;
playervar num vap_s;
playervar vec vap_hit_pos;
playervar any[] vap_effect;
playervar any vap_icon;
globalvar bool s_vap_user_affected;


// .########.##.......########..######..########.########...#######.
// .##.......##.......##.......##....##....##....##.....##.##.....##
// .##.......##.......##.......##..........##....##.....##.##.....##
// .######...##.......######...##..........##....########..##.....##
// .##.......##.......##.......##..........##....##...##...##.....##
// .##.......##.......##.......##....##....##....##....##..##.....##
// .########.########.########..######.....##....##.....##..#######.

// setup
globalvar num S_ELECTRO_AMMO;
globalvar num S_ELECTRO_CD;
globalvar num electro_cd;
playervar num electro_ammo;
globalvar num electro_pb;
globalvar bool electro_timer;
globalvar bool s_spawn_electro;
globalvar bool s_always_electro;
playervar bool electro_enabled;
globalvar str electro_txt;

// logic
globalvar num S_ELECTRO_PSPEED;
globalvar num S_ELECTRO_MESIZE;
globalvar num S_ELECTRO_ESIZE;
globalvar num S_ELECTRO_DELAY;
playervar vec electro_eyepos1;
playervar vec electro_eyepos2;
playervar vec electro_eyepos3;
playervar vec electro_m_hitpos;
playervar vec electro_m_effect;
playervar vec electro_hitpos;
playervar any electro_effect;
playervar bool mines_placed;
playervar color mine_color;

// ..######..########.....###....########..##....##
// .##....##.##.....##...##.##...##.....##.##...##.
// .##.......##.....##..##...##..##.....##.##..##..
// ..######..########..##.....##.########..#####...
// .......##.##........#########.##...##...##..##..
// .##....##.##........##.....##.##....##..##...##.
// ..######..##........##.....##.##.....##.##....##

// setup
globalvar num S_SPARK_AMMO;
globalvar num S_SPARK_CD;
globalvar num spark_cd;
playervar num spark_ammo;
globalvar num spark_pb;
globalvar bool spark_timer;
globalvar bool s_spawn_spark;
globalvar bool s_always_spark;
playervar bool spark_enabled;
globalvar str spark_txt;

// logic
globalvar num S_SPARK_PSPEED;
globalvar num S_SPARK_ESIZE;
globalvar num S_SPARK_HITESIZE;


// .########..########.########..##.....##..######..
// .##.....##.##.......##.....##.##.....##.##....##.
// .##.....##.##.......##.....##.##.....##.##.......
// .##.....##.######...########..##.....##.##...####
// .##.....##.##.......##.....##.##.....##.##....##.
// .##.....##.##.......##.....##.##.....##.##....##.
// .########..########.########...#######...######..
globalvar bool s_debug;



/* ------------------------------------------------------------------------------- todo + notes: -------------------------------------------------------------------------------
dont use EntityExists() with effects
for whatever reason; setting the buff_user to null will most likely break cooldown effects (timer inworld and growing sphere), doesnt break the timer logic, only the effects
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */

// ............##.....##....###....####.##....##...........
// ............###...###...##.##....##..###...##...........
// ............####.####..##...##...##..####..##...........
// .#######....##.###.##.##.....##..##..##.##.##....#######
// ............##.....##.#########..##..##..####...........
// ............##.....##.##.....##..##..##...###...........
// ............##.....##.##.....##.####.##....##...........
disabled rule: "---------------- Main ----------------"{}

rule: "[Main] :: Initial Global"
{
    // DisableInspectorRecording();
    DisableCompletion();
    DisableAnnouncer();

    CreateHudText(all, null, MatchTime() % 60 >= 10 
                             ? <"<0>:<1>", RoundToInteger(MatchTime() / 60, Rounding.Down), RoundToInteger(MatchTime() % 60, Rounding.Down)> 
                             : <"<0>:0<1>", RoundToInteger(MatchTime() / 60, Rounding.Down), RoundToInteger(MatchTime() % 60, Rounding.Down)>, /* spacing for crosshair: */ " \n\n", Location.Top, 0.2);

    SetMatchTime(10);

    cd_txt = [];
    buff_effect = [];
    buff_pos = [];
    buff_icon = [];
    s_grapple_option = [];

    match_started = false;

    S_MATCH_TIME_LIMIT = WorkshopSettingInteger("General",              "​Match Time (Minutes) (20)", 20, 1, 60, 1) * 60;
    // S_PRI_DELAY = WorkshopSettingReal("General",                        "Primary Fire Delay (0.7)", 0.7, 0.51, 2, 2);
    // s_pri_delay = WorkshopSettingToggle("General",                      "Enable Primary Fire Delay (On)", true, 3);
    s_pri_fx_enabled = WorkshopSettingToggle("General",                 "Enable Primary Fire Effects (On)", true, 4);

    s_buffs_enabled = WorkshopSettingToggle("Buffs",                    "​​Enable Buffs (On)", true, 1);
    s_buffs_spawn_at_start = WorkshopSettingToggle("Buffs",             "​Buffs Spawn Immediately When Match Starts (Off)", false, 2);
    s_cd_ip_timer = WorkshopSettingToggle("Buffs",                      "Show buff cooldown timer (On)", true, 3);
    s_buff_hud_txt = WorkshopSettingToggle("Buffs",                     "Show Buff Cooldown HUD Text (On)", true, 4);
    // s_use_cxhair = WorkshopSettingToggle("Buffs",                       "Buffs Change Crosshair (On)", true, 5);
    S_PICKUP_RAD = WorkshopSettingReal("Buffs",                         "Buff Collection Radius (1.25)", 1.25, 0.5, 3, 6);
    s_cd_type = WorkshopSettingCombo("Buffs",                           "Buff Timer Type (Progress Bar)", 0, ["Progress Bar", "Timer", "None"], 7);

    s_grapple_enabled = WorkshopSettingToggle("Grapple",                "Enable Grapple (On)", true, 1);
    S_GRAPPLE_PULL_SPEED = WorkshopSettingReal("Grapple",               "Grapple ​​Pull Speed (2.65)", 2.65, 0.5, 5, 2);
    S_GRAPPLE_RANGE = WorkshopSettingReal("Grapple",                    "​​Grapple Range (40)", 40, 3.5, 100, 3);
    s_grapple_option[0] = WorkshopSettingToggle("Grapple",              "Break Grapple if too close (On)", true, 4);
    s_grapple_option[1] = WorkshopSettingToggle("Grapple",              "Break Grapple if grapple hit loses LOS (Off)", false, 5);

    s_sec_enabled = WorkshopSettingToggle("Secondary Fire",             "Enable Secondary (On)", true, 1);
    S_SEC_PSPEED = WorkshopSettingReal("Secondary Fire",                "​​​Projectile Speed (90)", 90, 1, 500, 3);
    S_SEC_RADIUS = WorkshopSettingReal("Secondary Fire",                "​​​Explosion Radius (2.5)", 2.5, 1, 20, 4);

    s_dodge_enabled = WorkshopSettingToggle("Dodge",                    "Enable Dodge (On)", true, 1);
    S_DODGE_FORCE = WorkshopSettingReal("Dodge",                        "Dodge ​​​​​Force (14)", 14, 1, 100, 2);

    s_bhop_enabled = WorkshopSettingToggle("Bunny Hopping",             "Enable Bunny Hopping (On)", true, 1);
    S_BHOP_MAX_SPEED = WorkshopSettingInteger("Bunny Hopping",          "​Maximum Speed Multiplier From Bunny Hopping (320)", 320, 110, 10000, 2);
    S_BHOP_SPEED_RATE = WorkshopSettingReal("Bunny Hopping",            "​​Speed gain rate (12.5)", 12.5, 1, 100, 3);

    s_spawn_wallbang = WorkshopSettingToggle("Wallbang",                "​​​​Spawn Wallbang (On)", true, 1);
    S_WALLBANG_CD = WorkshopSettingInteger("Wallbang",                  "​​Wallbang Spawn Time (75)", 75, 5, 600, 2);
    S_WALLBANG_AMMO = WorkshopSettingInteger("Wallbang",                "Wallbang Ammo (10)", 10, 1, 60, 3);
    S_NUM_WALLBANGS = WorkshopSettingInteger("Wallbang",                "​Wallbang Amount (8)", 8, 2, 100, 4);

    s_spawn_ricochet = WorkshopSettingToggle("Ricochet",                "Spawn Ricochet (On)", true, 1);
    S_RICOCHET_CD = WorkshopSettingInteger("Ricochet",                  "Ricochet ​Spawn Time (75)", 75, 5, 600, 2);
    S_RICOCHET_AMMO = WorkshopSettingInteger("Ricochet",                "Ricochet Ammo (10)", 10, 1, 60, 3);
    S_NUM_RICOCHETS = WorkshopSettingInteger("Ricochet",                "​​​Ricochet Amount (8)", 8, 1, 16, 4);

    s_spawn_electro = WorkshopSettingToggle("Electro",                  "​​​​​Spawn Electro (On)", true, 1);
    S_ELECTRO_CD = WorkshopSettingInteger("Electro",                    "Electro ​Spawn Time (100)", 100, 5, 600, 2);
    S_ELECTRO_AMMO = WorkshopSettingInteger("Electro",                  "Electro Ammo (15)", 15, 1, 60, 3);
    S_ELECTRO_ESIZE = WorkshopSettingReal("Electro",                    "Electro Primary Explosion Size (1.5)", 1.5, 1, 500, 4);
    S_ELECTRO_MESIZE = WorkshopSettingReal("Electro",                   "Electro Mine Explosion Size (5)", 5, 1, 500, 5);
    S_ELECTRO_DELAY = WorkshopSettingReal("Electro",                    "Electro Mine Explosion Time When Idle (3)", 3, 1, 500, 6);
    S_ELECTRO_PSPEED = WorkshopSettingReal("Electro",                   "Electro Mine Projectile Speed (70)", 70, 1, 500, 7);

    s_spawn_spark = WorkshopSettingToggle("Spark",                      "​​​​​Spawn Spark (On)", true, 1);
    S_SPARK_CD = WorkshopSettingInteger("Spark",                        "Spark ​Spawn Time (125)", 125, 5, 600, 2);
    S_SPARK_AMMO = WorkshopSettingInteger("Spark",                      "Spark Ammo (10)", 10, 1, 60, 3);
    S_SPARK_PSPEED = WorkshopSettingReal("Spark",                       "Spark Projectile Speed (10)", 10, 1, 500, 4);
    S_SPARK_ESIZE = WorkshopSettingReal("Spark",                        "Spark Explosion Size (1.5)", 1.5, 1, 500, 5);
    S_SPARK_HITESIZE = WorkshopSettingReal("Spark",                     "Spark Hit Explosion Size (7)", 7, 1, 500, 6);

    s_spawn_quadshot = WorkshopSettingToggle("Quadshot",                "​​​​​Spawn Quadshot (On)", true, 1);
    S_QUADSHOT_CD = WorkshopSettingInteger("Quadshot",                  "Quadshot ​Spawn Time (125)", 125, 5, 600, 2);
    S_QUADSHOT_AMMO = WorkshopSettingInteger("Quadshot",                "Quadshot Ammo (10)", 10, 1, 60, 3);
    S_QUADSHOT_SPREAD = WorkshopSettingReal("Quadshot",                 "Quadshot Spread (Lower is Tighter) (0.8)", 0.8, 0.1, 20, 4);

    // ------------------------------------------- supers ------------------------------------------- //

    s_spawn_vap = WorkshopSettingToggle("Vaporizer",                    "​​​​​Spawn Vaporizer (On)", true, 1);
    S_VAP_CD = WorkshopSettingInteger("Vaporizer",                      "Vaporizer Spawn Time (180)", 180, 5, 600, 2);
    S_VAP_AMMO = WorkshopSettingInteger("Vaporizer",                    "Vaporizer Ammo (5)", 5, 1, 60, 3);
    S_VAP_ESIZE = WorkshopSettingReal("Vaporizer",                      "Vaporizer Explosion Size (19.75)", 19.75, 5, 50, 4);
    S_VAP_DELAY = WorkshopSettingReal("Vaporizer",                      "Vaporizer Explosion and Weapon Fire Delay (1)", 1, 0.5, 20, 5);
    s_vap_user_affected = WorkshopSettingToggle("Vaporizer",            "Vaporizer user affected by own explosion", true, 6);

    s_spawn_buckshot = WorkshopSettingToggle("Buckshot",                "​​​​​Spawn Buckshot (On)", true, 1);
    S_BUCKSHOT_CD = WorkshopSettingInteger("Buckshot",                  "Buckshot ​Spawn Time (200)", 200, 5, 600, 2);
    S_BUCKSHOT_AMMO = WorkshopSettingInteger("Buckshot",                "​​Buckshot Ammo (15)", 15, 1, 60, 3);
    S_BUCKSHOT_SPREAD = WorkshopSettingReal("Buckshot",                 "​​​Buckshot Spread (Lower is Tighter) (2.65)", 2.65, 0.1, 20, 4);

    s_spawn_lock = WorkshopSettingToggle("Smart Lock",                  "​​Spawn Smart Lock (On)", true, 1);
    S_LOCK_CD = WorkshopSettingInteger("Smart Lock",                    "​Smart Lock Spawn Time (230)", 230, 5, 600, 2);
    S_LOCK_AMMO = WorkshopSettingInteger("Smart Lock",                  "​​​Smart Lock Ammo (15)", 15, 1, 60, 3);
    S_LOCK_RADIUS = WorkshopSettingReal("Smart Lock",                   "​​​Lock on radius (Degrees) (10)", 10, 1, 120, 4);
    S_LOCK_TIME = WorkshopSettingReal("Smart Lock",                     "Lock on time (0.65)", 0.65, 0.1, 10, 5);

    // ---------------------------------------------------------------------------------------------- //

    s_debug = WorkshopSettingToggle("Debug",                            "Show Debug Info", true, 1);
    s_always_wallbang = WorkshopSettingToggle("Debug",                  "​​​​​Always Wallbang", false, 3);
    s_always_ricochet = WorkshopSettingToggle("Debug",                  "​​​​​​​​​​Always Ricochet", false, 4);
    s_always_electro = WorkshopSettingToggle("Debug",                   "​​​​​Always Electro", false, 5);
    s_always_spark = WorkshopSettingToggle("Debug",                     "Always Spark", false, 6);
    s_always_quadshot = WorkshopSettingToggle("Debug",                  "Always Quadshot", false, 7);
    s_always_vap = WorkshopSettingToggle("Debug",                       "Always Vaporizer", false, 8);
    s_always_buckshot = WorkshopSettingToggle("Debug",                  "​​​​​Always Buckshot", false, 9);
    s_always_lock = WorkshopSettingToggle("Debug",                      "Always Smart Lock", false, 10);

    if (!s_buffs_enabled)
    {
        s_spawn_wallbang = false;
        s_spawn_ricochet = false;
        s_spawn_buckshot = false;
        s_spawn_lock = false;
        s_spawn_vap = false;
        s_spawn_electro = false;
        s_spawn_spark = false;
        s_spawn_quadshot = false;
    }

    // [0]: wallbang
    // [1]: ricochet
    // [5]: electro
    // [6]: spark
    // [7]: quadshot

    // supers
    // [2]: buckshot
    // [3]: smart lock
    // [4]: vaporizer

    valid_map = false;

    switch (true)
    {
        case (IsMap(Map.Workshop_Chamber) || IsMap(Map.Workshop_Expanse) || IsMap(Map.Workshop_Expanse_Night) || IsMap(Map.Workshop_Island) || IsMap(Map.Workshop_Island_Night)):
            valid_map = true;

            if (s_buffs_enabled)
            {
                if (s_spawn_wallbang || s_spawn_ricochet || s_spawn_electro || s_spawn_spark || s_spawn_quadshot)
                    CreateInWorldText(all, "Regular", Vector(8, 4, 0), 1.5, TextColor: Color.Yellow);

                if (s_spawn_buckshot || s_spawn_lock || s_spawn_vap)
                    CreateInWorldText(all, "Supers", Vector(-8, 4, 0), 1.5, TextColor: Color.Red);

                if (s_spawn_wallbang)
                    CreateInWorldText(all, "Bullets will ignore walls and players", Vector(8, 2, -8), 0.75);
                if (s_spawn_ricochet)
                    CreateInWorldText(all, "Bullets bounce off walls", Vector(8, 2, -4), 0.75);
                if (s_spawn_electro)
                    CreateInWorldText(all, "Shots create a small explosion. Press reload to launch mines. All deployed mines are detonated if one of them is shot and armed", Vector(8, 2, 0), 0.75);
                if (s_spawn_spark)
                    CreateInWorldText(all, "Press reload to launch an explosive projectile, projectile detonates with a larger radius if shot", Vector(8, 2, 4), 0.75);
                if (s_spawn_quadshot)
                    CreateInWorldText(all, "Turns your weapon into a shotgun with a small spread. Has an X-shaped spread pattern", Vector(8, 2, 8), 0.75);

                if (s_spawn_buckshot)
                    CreateInWorldText(all, "Turns your weapon into a shotgun with a large spread. Has an O-shaped spread pattern", Vector(-8, 2, 4), 0.75);
                if (s_spawn_lock)
                    CreateInWorldText(all, <"Locks on to enemies by looking at them for <0> second(s)", S_LOCK_TIME>, Vector(-8, 2, 0), 0.75);
                if (s_spawn_vap)
                    CreateInWorldText(all, <"Fires a large explosion delayed by <0> second(s) but decreases fire rate", S_VAP_DELAY>, Vector(-8, 2, -4), 0.75);
            }

            buff_pos[0] = Vector(8, 1, -8);
            buff_pos[1] = Vector(8, 1, -4);
            buff_pos[5] = Vector(8, 1, 0);
            buff_pos[6] = Vector(8, 1, 4);
            buff_pos[7] = Vector(8, 1, 8);

            buff_pos[2] = Vector(-8, 1, 4);
            buff_pos[3] = Vector(-8, 1, 0);
            buff_pos[4] = Vector(-8, 1, -4);
            break;
        case (IsMap(Map.Black_Forest) || IsMap(Map.Black_Forest_Winter)):
            valid_map = true;
            buff_pos[0] = Vector(16.79, 12.44, 29.48);
            buff_pos[1] = Vector(16.18, 12.36, -20.11);
            buff_pos[5] = Vector(-5.15, 14.05, 5.25);
            buff_pos[6] = Vector(27.75, 18, 12.5);
            buff_pos[7] = Vector(27.75, 18, -2.5);

            buff_pos[2] = Vector(4.66, 18.28, 5.00);
            buff_pos[3] = Vector(-25.49, 13.09, 5.00);
            buff_pos[4] = Vector(21.00, 10.00, 5.00);
            break;
        case (IsMap(Map.Blizzard_World) || IsMap(Map.Blizzard_World_Winter)):
            valid_map = true;
            buff_pos[0] = Vector(-32.50, 0.61, 73.15);
            buff_pos[1] = Vector(-77.28, 5.88, 66.15);
            buff_pos[5] = Vector(-37.28, -1.25, 146.63);
            buff_pos[6] = Vector(-77.28, 0.25, 66.15);
            buff_pos[7] = Vector(-90.76, 1.75, 94.02);

            buff_pos[2] = Vector(-54.50, 0.61, 110.20);
            buff_pos[3] = Vector(-67.55, 1.75, 138.74);
            buff_pos[4] = Vector(-25.04, 1.29, 109.95);
            break;
        case (IsMap(Map.Castillo)):
            valid_map = true;
            buff_pos[0] = Vector(-106.18, 40.56, 43.20);
            buff_pos[1] = Vector(-100.35, 40.56, 73.75);
            buff_pos[5] = Vector(-124.27, 35.43, 61.14);
            buff_pos[6] = Vector(-96.77, 33.20, 33.82);
            buff_pos[7] = Vector(-86.58, 33.56, 84.14);

            buff_pos[2] = Vector(-115.85, 39.57, 60.92);
            buff_pos[3] = Vector(-74.82, 33.00, 52.93);
            buff_pos[4] = Vector(-85.65, 39.64, 55.00);
            break;
        case (IsMap(Map.Chateau_Guillard) || IsMap(Map.Chateau_Guillard_Halloween)):
            valid_map = true;
            buff_pos[0] = Vector(206.21, 10.03, 92.43);
            buff_pos[1] = Vector(196.33, 17.50, 47.12);
            buff_pos[5] = Vector(236.85, 3, 91.89);
            buff_pos[6] = Vector(206.20, 16.50, 87.00);
            buff_pos[7] = Vector(182.25, 10, 102.00);

            buff_pos[2] = Vector(169.25, 6, 80.97);
            buff_pos[3] = Vector(206.19, 1, 77.96);
            buff_pos[4] = Vector(193.26, 10, 116.66);
            break;
        case (IsMap(Map.Dorado)):
            valid_map = true;
            buff_pos[0] = Vector(115.66, 8.73, -7.08);
            buff_pos[1] = Vector(85.30, 13.75, 29.84);
            buff_pos[5] = Vector(134.33, 12.01, 47.79);
            buff_pos[6] = Vector(141.62, 11, 3.08);
            buff_pos[7] = Vector(129.02, 10, -24.67);

            buff_pos[2] = Vector(98.04, 19.01, 15.26);
            buff_pos[3] = Vector(131.27, 12.05, 26.12);
            buff_pos[4] = Vector(76.87, 9.00, 7.34);
            break;
        case (IsMap(Map.Ecopoint_Antarctica) || IsMap(Map.Ecopoint_Antarctica_Winter)):
            valid_map = true;
            buff_pos[0] = Vector(1.66, 12.63, -25.00);
            buff_pos[1] = Vector(1.66, 12.63, 25.00);
            buff_pos[5] = Vector(-10.30, 9.53, -0.32);
            buff_pos[6] = Vector(20.54, 7.02, -17.00);
            buff_pos[7] = Vector(20.54, 7.01, 17.00);

            buff_pos[2] = Vector(-19.50, 13.00, 0.00);
            buff_pos[3] = Vector(20.50, 10.00, 0.00);
            buff_pos[4] = Vector(18.70, 5.00, 0.00);
            break;
        case (IsMap(Map.Eichenwalde) || IsMap(Map.Eichenwalde_Halloween)):
            valid_map = true;
            buff_pos[0] = Vector(55.70, 22.00, -67.84);
            buff_pos[1] = Vector(58.33, 5.72, -90.39);
            buff_pos[5] = Vector(55.99, 18.72, -109.98);
            buff_pos[6] = Vector(54.76, 11.72, -118.74);
            buff_pos[7] = Vector(38.31, 5.81, -65.01);

            buff_pos[2] = Vector(76.03, 11.69, -109.66);
            buff_pos[3] = Vector(88.13, 13.67, -67.39);
            buff_pos[4] = Vector(30.76, 15.00, -81.88);
            break;
        case (IsMap(Map.Havana)):
            valid_map = true;
            buff_pos[0] = Vector(9.50, 7.00, -79.23);
            buff_pos[1] = Vector(37.64, 11.00, -94.23);
            buff_pos[5] = Vector(63.36, 5, -65.32);
            buff_pos[6] = Vector(9.38, 13, -79.20);
            buff_pos[7] = Vector(32.42, 5, -96.74);

            buff_pos[2] = Vector(27.92, 13.00, -61.96);
            buff_pos[3] = Vector(65.14, 12.97, -83.35);
            buff_pos[4] = Vector(40.74, 6.82, -83.33);
            break;
        case (IsMap(Map.Hollywood) || IsMap(Map.Hollywood_Halloween)):
            valid_map = true;
            buff_pos[0] = Vector(-11.91, 2.73, -74.64);
            buff_pos[1] = Vector(-4.09, 2.60, -15.87);
            buff_pos[5] = Vector(28.64, 7.80, -77.49);
            buff_pos[6] = Vector(50.05, 3.75, -56.09);
            buff_pos[7] = Vector(-25.46, 6.75, -41.37);

            buff_pos[2] = Vector(20.67, 2.60, -51.82);
            buff_pos[3] = Vector(7.87, 13.90, -48.38);
            buff_pos[4] = Vector(18.51, 5.69, -28.41);
            break;
        case (IsMap(Map.Kanezaka)):
            valid_map = true;
            buff_pos[0] = Vector(-0.96, 10, -46.32);
            buff_pos[1] = Vector(-16.00, 12.15, 16.83);
            buff_pos[5] = Vector(-30.66, 7.55, -9.75);
            buff_pos[6] = Vector(-1.55, 7, 7.55);
            buff_pos[7] = Vector(-52.52, 9, 24.24);

            buff_pos[2] = Vector(-29.03, 5.00, 43.08);
            buff_pos[3] = Vector(-30.66, 11.89, -9.75);
            buff_pos[4] = Vector(-11.38, 6.86, 3.78);
            break;
        case (IsMap(Map.Kings_Row) || IsMap(Map.Kings_Row_Winter)):
            valid_map = true;
            buff_pos[0] = Vector(-49.46, 1.00, 2.69);
            buff_pos[1] = Vector(-31.19, 10.00, -13.40);
            buff_pos[5] = Vector(-34.90, 1.14, -24.66);
            buff_pos[6] = Vector(-68.40, 5.50, -35.08);
            buff_pos[7] = Vector(-65.62, 0.67, -21.24);

            buff_pos[2] = Vector(-93.67, 8.50, -29.38);
            buff_pos[3] = Vector(-48.85, 10.12, -37.62);
            buff_pos[4] = Vector(-92.15, 2.10, 7.65);
            break;
        case (IsMap(Map.Lijiang_Control_Center) || IsMap(Map.Lijiang_Control_Center_Lunar)):
            valid_map = true;
            buff_pos[0] = Vector(-26.80, 268.00, 308.00);
            buff_pos[1] = Vector(26.80, 268.00, 308.00);
            buff_pos[5] = Vector(0, 273.43, 280);
            buff_pos[6] = Vector(20.25, 270.95, 337.10);
            buff_pos[7] = Vector(-20.25, 270.95, 337.10);

            buff_pos[2] = Vector(0.00, 271.00, 323.00);
            buff_pos[3] = Vector(0.00, 271.00, 260.65);
            buff_pos[4] = Vector(0.00, 279.00, 291.85);
            break;
        case (IsMap(Map.Lijiang_Garden) || IsMap(Map.Lijiang_Garden_Lunar)):
            valid_map = true;
            buff_pos[0] = Vector(46.85, 96.04, 150);
            buff_pos[1] = Vector(-46.85, 96.04, 150);
            buff_pos[5] = Vector(0, 96.00, 125.85);
            buff_pos[6] = Vector(-17.69, 95, 173.97);
            buff_pos[7] = Vector(17.69, 95, 173.97);

            buff_pos[2] = Vector(0, 95, 143.35);
            buff_pos[3] = Vector(0, 95, 185.00);
            buff_pos[4] = Vector(0, 97, 108.00);
            break;
        case (IsMap(Map.Necropolis)):
            valid_map = true;
            buff_pos[0] = Vector(1.68, 12.70, 17.25);
            buff_pos[1] = Vector(1.80, 12.70, -16.41);
            buff_pos[5] = Vector(-31.13, 3, 0);
            buff_pos[6] = Vector(1.15, 4, 22.91);
            buff_pos[7] = Vector(1.15, 4, -22.91);

            buff_pos[2] = Vector(-21.05, 13.71, 0);
            buff_pos[3] = Vector(8.50, 2.01, 0.00);
            buff_pos[4] = Vector(23.08, 5.99, 0.00);
            break;
        case (IsMap(Map.Paris)):
            valid_map = true;
            buff_pos[0] = Vector(-104.10, 16.00, -100.65);
            buff_pos[1] = Vector(-109.18, 11.00, -60.60);
            buff_pos[5] = Vector(-103.36, 11.76, -37.17);
            buff_pos[6] = Vector(-81.38, 14, -103.85);
            buff_pos[7] = Vector(-52.17, 10.08, -46.28);

            buff_pos[2] = Vector(-57.19, 14.00, -82.00);
            buff_pos[3] = Vector(-73.39, 11.02, -38.23);
            buff_pos[4] = Vector(-85.93, 13.00, -64.09);
            break;
        case (IsMap(Map.Oasis_City_Center)):
            valid_map = true;
            buff_pos[0] = Vector(164.76, 5, 226.22);
            buff_pos[1] = Vector(122.22, 5, 268.75);
            buff_pos[5] = Vector(158.69, 5, 262.68);
            buff_pos[6] = Vector(125.12, 2.85, 291.32);
            buff_pos[7] = Vector(187.39, 2.85, 229.09);

            buff_pos[2] = Vector(154.48, 12.52, 258.48);
            buff_pos[3] = Vector(118.01, 2, 221.96);
            buff_pos[4] = Vector(143.48, 3.15, 247.50);
            break; 
        case (IsMap(Map.Oasis_University)):
            valid_map = true;
            buff_pos[0] = Vector(-188, 16, -38);
            buff_pos[1] = Vector(-188, 16, 38);
            buff_pos[5] = Vector(-188, 10.40, 0);
            buff_pos[6] = Vector(-188, 17, 18);
            buff_pos[7] = Vector(-188, 17, -18);

            buff_pos[2] = Vector(-172, 18, 0);
            buff_pos[3] = Vector(-188, 17, 0);
            buff_pos[4] = Vector(-217.72, 20, 0);
            break; 
        case (IsMap(Map.Oasis_Gardens)):
            valid_map = true;
            buff_pos[0] = Vector(115.06, 8.50, -273.62);
            buff_pos[1] = Vector(167.40, 8.50, -221.28);
            buff_pos[5] = Vector(87.4, 3.50, -248.25);
            buff_pos[6] = Vector(142, 3.50, -193.60);
            buff_pos[7] = Vector(141.35, 8.38, -247.59);

            buff_pos[2] = Vector(107.60, 5.50, -206.56);
            buff_pos[3] = Vector(152.05, 8.54, -258.26);
            buff_pos[4] = Vector(121.35, 12.50, -227.56);
            break;
    }

    CreateHudText(all, null, null, "ㅤInstagib | Created by scort#11221", Location.Right, 0, Color.White, Color.White, Color.White, HudTextRev.VisibleTo);
    CreateHudText(all, null, "ㅤv2.0.0 | Code: APPPX\n", null, Location.Right, 0.1, Color.White, Color.White, Color.White, HudTextRev.VisibleTo);

    if (valid_map && s_buffs_enabled && !s_buffs_spawn_at_start)
    {
        wallbang_cd = S_WALLBANG_CD;
        ricochet_cd = S_RICOCHET_CD;
        buckshot_cd = S_BUCKSHOT_CD;
        lock_cd = S_LOCK_CD;
        vap_cd = S_VAP_CD;
        electro_cd = S_ELECTRO_CD;
        spark_cd = S_SPARK_CD;
        quadshot_cd = S_QUADSHOT_CD;
    }
}

rule: "[Main] :: Start Match"
if (!match_started)
if (IsGameInProgress())
{
    LogToInspector("Match Started");
    SetMatchTime(S_MATCH_TIME_LIMIT);
    match_started = true;

    if (valid_map && s_buffs_enabled)
    {
        if (!s_buffs_spawn_at_start)
        {
            WallbangCooldown();
            RicochetCooldown();
            BuckshotCooldown();
            LockCooldown();
            VaporizerCooldown();
            ElectroCooldown();
            SparkCooldown();
            QuadshotCooldown();
        }
        else
        {
            wallbang_cd = 0;
            ricochet_cd = 0;
            buckshot_cd = 0;
            lock_cd = 0;
            vap_cd = 0;
            electro_cd = 0;
            quadshot_cd = 0;
        }

        if (s_buff_hud_txt)
        {
            if (s_spawn_wallbang)
            {
                CreateHudText(all, AbilityIconString(Hero.Baptiste, Button.Ultimate), null,
                wallbang_cd != 0 ? wallbang_txt : can_pickup_buff[0] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buff_user[0]>,
                Location.Left, 1, Color.Yellow);
            }
            if (s_spawn_ricochet)
            {
                CreateHudText(all, AbilityIconString(Hero.Winston, Button.Ability1), null,
                ricochet_cd != 0 ? ricochet_txt : can_pickup_buff[1] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buff_user[1]>,
                Location.Left, 2, Color.Violet);
            }

            if (s_spawn_electro)
            {
                CreateHudText(all, AbilityIconString(Hero.Echo, Button.SecondaryFire), null,
                electro_cd != 0 ? electro_txt : can_pickup_buff[5] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buff_user[5]>,
                Location.Left, 3, Color.SkyBlue);
            }

            if (s_spawn_spark)
            {
                CreateHudText(all, AbilityIconString(Hero.Sigma, Button.Ability1), null,
                spark_cd != 0 ? spark_txt : can_pickup_buff[6] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buff_user[6]>,
                Location.Left, 4, Color.Purple);
            }

            if (s_spawn_quadshot)
            {
                CreateHudText(all, AbilityIconString(Hero.Mccree, Button.Ability2), null,
                quadshot_cd != 0 ? quadshot_txt : can_pickup_buff[7] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buff_user[7]>,
                Location.Left, 5, Color.Orange);
            }

            if (s_spawn_vap || s_spawn_buckshot || s_spawn_lock)
            {
                CreateHudText(all, null, " \nSupers", null,
                Location.Left, 5.1, Color.White);
            }

            if (s_spawn_vap)
            {
                CreateHudText(all, AbilityIconString(Hero.Symmetra, Button.Ultimate), null,
                vap_cd != 0 ? vap_txt : can_pickup_buff[4] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buff_user[4]>,
                Location.Left, 6, Color.Rose);
            }
            if (s_spawn_buckshot)
            {
                CreateHudText(all, AbilityIconString(Hero.Ashe, Button.Ability1), null,
                buckshot_cd != 0 ? buckshot_txt : can_pickup_buff[2] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buff_user[2]>,
                Location.Left, 7, CustomColor(0, 255, 0, 255));
            }
            if (s_spawn_lock)
            {
                CreateHudText(all, AbilityIconString(Hero.Sombra, Button.SecondaryFire), null,
                lock_cd != 0 ? lock_txt : can_pickup_buff[3] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buff_user[3]>,
                Location.Left, 8, CustomColor(28, 81, 255, 255));
            }
        }
    }

    if (s_debug)
    {
        CreateHudText(host, null, <"<0> <1>", buff_pos[0], DistanceBetween(host, buff_pos[0])>, null, Location.Left, 0.9);
        CreateHudText(host, null, <"<0> <1>", buff_pos[1], DistanceBetween(host, buff_pos[1])>, null, Location.Left, 1.9);
        CreateHudText(host, null, <"<0> <1>", buff_pos[5], DistanceBetween(host, buff_pos[5])>, null, Location.Left, 2.9);
        CreateHudText(host, null, <"<0> <1>", buff_pos[6], DistanceBetween(host, buff_pos[6])>, null, Location.Left, 3.9);
        CreateHudText(host, null, <"<0> <1>", buff_pos[7], DistanceBetween(host, buff_pos[7])>, null, Location.Left, 4.9);
        CreateHudText(host, null, <"<0> <1>", buff_pos[4], DistanceBetween(host, buff_pos[4])>, null, Location.Left, 7.9);
        CreateHudText(host, null, <"<0> <1>", buff_pos[2], DistanceBetween(host, buff_pos[2])>, null, Location.Left, 5.9);
        CreateHudText(host, null, <"<0> <1>", buff_pos[3], DistanceBetween(host, buff_pos[3])>, null, Location.Left, 6.9);

        CreateHudText(host, null, null, <"Pos: <0>\nFacing: <1>\nHoriz Facing Vector: <2>\nThrottle: <3>\nbhopping: <4>\nvalid_map: <5>\nhas_buff: <6>", 
        PositionOf(host), 
        FacingDirectionOf(host), 
        DirectionFromAngles(HorizontalFacingAngleOf(host), 0), 
        ThrottleOf(host), 
        host.bhopping, 
        valid_map,
        host.has_buff

        >, Location.Right, 0.3);

        CreateHudText(host, null, "Cur", <"<0>%", RoundToInteger(ServerLoad() / 2.55, Rounding.Nearest)>, Location.Right, 0.32, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
        CreateHudText(host, null, "Avg", <"<0>%", RoundToInteger(ServerLoadAverage() / 2.55, Rounding.Nearest)>, Location.Right, 0.33, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
        CreateHudText(host, null, "Peak", <"<0>%", RoundToInteger(ServerLoadPeak() / 2.55, Rounding.Nearest)>, Location.Right, 0.34, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
        CreateHudText(host, null, "Ent", EntityCount(), Location.Right, 0.36, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
        CreateHudText(host, null, "Txt", TextCount() - 14, Location.Right, 0.37, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
    }
}

// rule: "[Main] :: Crosshair"
// Event.OngoingPlayer
// if (s_use_cxhair)
// {
//     // this is disgusting and needs improvement. for now this works fine as a proof of concept
//     CreateHudText(player, null, " \n\n", <"ㅤ\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0><1><2><3><4><5><6>               <7><8><9><10><11><12><13>", 
//     // left
//     wallbang_enabled ? "≫" : "",
//     ricochet_enabled ? "ᄾ" : "",
//     electro_enabled ? "ㅑ" : "",
//     quadshot_enabled ? "Ｘ" : "",
//     buckshot_enabled ? "〘" : "",
//     lock_enabled 
//         ? CountOf(locked_targets) >= 1 
//             ? "▣" 
//             : "□" 
//         : "",
//     vap_enabled ? " ∈" : "",
//     // right
//     vap_enabled ? "∋ " : "",
//     lock_enabled 
//         ? CountOf(locked_targets) >= 1 
//             ? "▣" 
//             : "□" 
//         : "",
//     buckshot_enabled ? "〙" : "",
//     quadshot_enabled ? "Ｘ" : "",
//     electro_enabled ? "ㅕ" : "",
//     ricochet_enabled ? "ᄼ" : "",
//     wallbang_enabled ? "≪" : "">, 
//     Location.Top, 2, Color.White, Color.White, Color.White);
// }

rule: "[Main] :: Player Join"
Event.OnPlayerJoin
{
    if (IsDummyBot())
        SetRespawnMaxTime(player, 1);

    DisableGameModeHud();

    DisallowButton(player, Button.Ability1);
    DisallowButton(player, Button.Ability2);

    if (s_always_wallbang)
    {
        wallbang_enabled = true;
    }
    if (s_always_ricochet)
    {
        ricochet_enabled = true;
    }
    if (s_always_buckshot)
    {
        buckshot_enabled = true;
    }
    if (s_always_lock)
    {
        lock_enabled = true;
    }
    if (s_always_vap)
    {
        vap_enabled = true;
    }
    if (s_always_electro)
    {
        electro_enabled = true;
    }
    if (s_always_spark)
    {
        spark_enabled = true;
    }
    if (s_always_quadshot)
    {
        quadshot_enabled = true;
    }

    hud_txt = [];
    spree_iwt = [];
    sec_eyepos = Vector(-10000, -10000, -10000);
    electro_eyepos1 = Vector(-10000, -10000, -10000);
    electro_eyepos2 = Vector(-10000, -10000, -10000);
    electro_eyepos3 = Vector(-10000, -10000, -10000);
    bhop_speed = 100;
}

rule: "[Main] :: Player Leave"
Event.OnPlayerLeave
{
    // DestroyInWorldText(wh_txt);
    DestroyInWorldText(lock_id);
    DestroyInWorldText(locking_id);
}

rule: "[Main] :: Player Spawned"
Event.OngoingPlayer
if (HasSpawned())
{
    CreateEffect(bhopping ? all : null, Effect.Soldier76SprintingEffect, Color.White, player, 1);
    SmallMessage(player, "Welcome!");
    Wait(3);
    SmallMessage(player, <"Holding down <0> will let you gain speed by bunny hopping", InputBindingString(Button.Jump)>);
    Wait(3);
    SmallMessage(player, <"<0> to use a grappling hook to pull you towards a surface or to pull players towards you", InputBindingString(Button.Ability2)>);
    Wait(3);
    SmallMessage(player, <"<0> to launch a projectile that knocks yourself and enemy players back", InputBindingString(Button.SecondaryFire)>);
    Wait(3);
    SmallMessage(player, <"<0> to dodge in any direction", InputBindingString(Button.Ability1)>);
    Wait(3);
    SmallMessage(player, "Buffs are littered throughout the map that give you special changes to your weapon. Have fun!");
}

rule: "[Main] :: Force Respawn"
Event.OngoingPlayer
if (IsButtonHeld(player, Button.Jump))
if (IsDead())
{
    WaitIfTrue(0.2);
    Respawn();
}

// rule: "[Main] :: Player Respawn"
//     Event.OngoingPlayer
//     if (IsAlive())
//     {
//         if (wallbang_enabled)
//             ChaseVariableAtRate(wallbang_dur, 0, 1, RateChaseReevaluation.None);
//         if (ricochet_enabled)
//             ChaseVariableAtRate(ricochet_dur, 0, 1, RateChaseReevaluation.None);
//         if (buckshot_enabled)
//             ChaseVariableAtRate(buckshot_dur, 0, 1, RateChaseReevaluation.None);
//         if (lock_enabled)
//             ChaseVariableAtRate(lock_dur, 0, 1, RateChaseReevaluation.None);
//         if (vap_enabled)
//             ChaseVariableAtRate(vap_dur, 0, 1, RateChaseReevaluation.None);
//     }

// rule: "[Main] :: Player Dead"
//     Event.OngoingPlayer
//     if (IsDead())
//     {
//         StopChasingVariable(wallbang_dur);
//         StopChasingVariable(ricochet_dur);
//         StopChasingVariable(buckshot_dur);
//         StopChasingVariable(lock_dur);
//         StopChasingVariable(vap_dur);
//     }

rule: "[Main] :: Speedometer & Accuracy HUD Text"
Event.OngoingPlayer
if (s_bhop_enabled)
if (S_BHOP_MAX_SPEED > 100)
{
    CreateHudText(player, null, null, <" \n<0> M/S\n", HorizontalSpeedOf()>, Location.Left, 10, Color.White, Color.White, Color.White, HudTextRev.String);
}

rule: "[Main] :: End Game"
if (match_started)
if (MatchTime() == 0)
{
    EnableCompletion();
}

// rule: "[Main] :: Primary Delay"
// Event.OngoingPlayer
// if (s_pri_delay)
// if (!s_always_vap)
// if (!vap_enabled) 
// if (IsButtonHeld(player, Button.PrimaryFire))
// {
//     // AllowButton(player, Button.PrimaryFire);
//     PressButton(player, Button.PrimaryFire);
//     MinWait();
//     DisallowButton(player, Button.PrimaryFire);
//     Wait(S_PRI_DELAY - 0.016);
//     AllowButton(player, Button.PrimaryFire);
//     LoopIfConditionIsTrue();
// }

rule: "[Main] :: Primary Effect"
Event.OngoingPlayer
if (IsFiringPrimary())
if (s_pri_fx_enabled) 
if (!has_buff)
{
    pri_hit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);
    any start_pos = weapon_muzzle;

    player[] enemies = RemoveFromArray(all, player);

    any[] pri_beam = [];
    CreateBeamEffect(player, BeamType.BadBeam, EyePosition() + Facing() + start_pos, pri_hit, Color.Aqua, EffectRev.None);
    pri_beam[0] = LastCreatedEntity();
    CreateBeamEffect(enemies, BeamType.BadBeam, EyePosition() + Facing() + start_pos, pri_hit, Color.Red, EffectRev.None);
    pri_beam[1] = LastCreatedEntity();

    PlayEffect(player, PlayEffect.GoodExplosion, Color.Aqua, pri_hit, 0.2);
    PlayEffect(enemies, PlayEffect.GoodExplosion, Color.Red, pri_hit, 0.2);

    Wait(0.25);
    DestroyEffect(pri_beam[0]);
    DestroyEffect(pri_beam[1]);
}
// .............######..########..########..########.########....##....##..#######..########.####.########..######............
// ............##....##.##.....##.##.....##.##.......##..........###...##.##.....##....##.....##..##.......##....##...........
// ............##.......##.....##.##.....##.##.......##..........####..##.##.....##....##.....##..##.......##.................
// .#######.....######..########..########..######...######......##.##.##.##.....##....##.....##..######....######.....#######
// ..................##.##........##...##...##.......##..........##..####.##.....##....##.....##..##.............##...........
// ............##....##.##........##....##..##.......##..........##...###.##.....##....##.....##..##.......##....##...........
// .............######..##........##.....##.########.########....##....##..#######.....##....####.##........######............
disabled rule: "---------------- Killing Spree Notifs ----------------"{}

rule: "[Killspree] :: Record Kills"
Event.OnFinalBlow
{
    life_kills++;
}

rule: "[Killspree] :: Reset Kills on death"
Event.OnDeath
{
    if (life_kills >= 6)
    {
        BigMessage(all, !EventWasEnvironment() 
                            ? <"<0>'s <1> player spree was ended<2>!", Victim(), life_kills, Victim() != Attacker() 
                                                                                                    ? <" by <0>", Attacker()>
                                                                                                    : " by themself!"> 
                            : <"<0> fell off the map! They had a <1> player spree", Victim(), life_kills>);

        SmallMessage(player, <"<0> player kill spree!", life_kills>);

        DestroyEffect(spree_effect);
        DestroyHudText(spree_hud);

        Wait(0.1);
        spree_iwt = [];
    }

    life_kills = 0;
}

rule: "[Killspree] :: Kill"
Event.OnFinalBlow
if (life_kills == 6)
{
    BigMessage(all, <"<0> is on a Killing Spree!", player>);

    CreateEffect(all, Effect.Sparkles, streak_color != null ? streak_color : RainbowColor(), player, 1, EffectRev.VisibleToPositionRadiusAndColor);
    spree_effect = LastCreatedEntity();

    // if then else for colors here because streak_color doesnt update when using RainbowColor()
    CreateHudText(player, null, <" \n<0> Kills", life_kills>, streak_str, Location.Left, 15, Color.White, Color.White, streak_color != null ? streak_color : RainbowColor(), HudTextRev.VisibleToSortOrderStringAndColor);
    spree_hud = LastTextID();

    CreateInWorldText(player, "Killing Spree!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.White);
    spree_iwt[0] = LastTextID();

    streak_str = "Killing Spree";
    streak_color = Color.White;

    Wait(2);

    DestroyInWorldText(spree_iwt[0]);
}

rule: "[Killspree] :: Rampage"
Event.OnFinalBlow
if (life_kills == 8)
{
    BigMessage(all, <"<0> is on a Rampage!", player>);

    CreateInWorldText(player, "Rampage!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.LimeGreen);
    spree_iwt[1] = LastTextID();

    streak_str = "Rampage";
    streak_color = Color.LimeGreen;

    Wait(2);

    DestroyInWorldText(spree_iwt[1]);
}

rule: "[Killspree] :: Dominating"
Event.OnFinalBlow
if (life_kills == 11)
{
    BigMessage(all, <"<0> is Dominating!", player>);

    CreateInWorldText(player, "Dominating!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.SkyBlue);
    spree_iwt[2] = LastTextID();

    streak_str = "Dominating";
    streak_color = Color.SkyBlue;

    Wait(2);

    DestroyInWorldText(spree_iwt[2]);
}

rule: "[Killspree] :: Unstoppable"
Event.OnFinalBlow
if (life_kills == 14)
{
    BigMessage(all, <"<0> is Unstoppable!", player>);

    CreateInWorldText(player, "Unstoppable!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Purple);
    spree_iwt[3] = LastTextID();

    streak_str = "Unstoppable";
    streak_color = Color.Purple;

    Wait(2);

    DestroyInWorldText(spree_iwt[3]);
}

rule: "[Killspree] :: Godlike"
Event.OnFinalBlow
if (life_kills == 17)
{
    BigMessage(all, <"<0> is Godlike!", player>);

    CreateInWorldText(player, "Godlike!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Yellow);
    spree_iwt[4] = LastTextID();

    streak_str = "Godlike";
    streak_color = Color.Yellow;

    Wait(2);

    DestroyInWorldText(spree_iwt[4]);
}

rule: "[Killspree] :: Divine"
Event.OnFinalBlow
if (life_kills == 21)
{
    BigMessage(all, <"<0> is Divine!", player>);

    CreateInWorldText(player, "Divine!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Orange);
    spree_iwt[5] = LastTextID();

    streak_str = "Divine";
    streak_color = Color.Orange;

    Wait(2);

    DestroyInWorldText(spree_iwt[5]);
}

rule: "[Killspree] :: Empyreal"
Event.OnFinalBlow
if (life_kills == 24)
{
    BigMessage(all, <"<0> is Empyreal!", player>);

    CreateInWorldText(player, "Empyreal!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.VisibleToStringAndColor, RainbowColor());
    spree_iwt[6] = LastTextID();

    streak_str = "Empyreal";
    streak_color = null;

    Wait(2);

    DestroyInWorldText(spree_iwt[6]);
}

// ............########..##.....##..#######..########............
// ............##.....##.##.....##.##.....##.##.....##...........
// ............##.....##.##.....##.##.....##.##.....##...........
// .#######....########..#########.##.....##.########.....#######
// ............##.....##.##.....##.##.....##.##..................
// ............##.....##.##.....##.##.....##.##..................
// ............########..##.....##..#######..##..................
disabled rule: "---------------- Bhop ----------------"{}

void ResetSpeed() playervar "[Bhop] :: Reset Speed"
{
    StopChasingVariable(bhop_speed);
    is_chasing = false;
    bhopping = false;
    bhop_speed = 100;
    SetMoveSpeed(player, bhop_speed);
}

rule: "[Bhop] :: Auto Hop"
Event.OngoingPlayer
if (s_bhop_enabled)
if (IsOnGround())
if (IsButtonHeld(player, Button.Jump))
{
    DisallowButton(player, Button.Jump);
    MinWait();
    AllowButton(player, Button.Jump);
}

// void StopAccelDir() playervar "[Bhop] :: Stop Accel Dir Sub"
// {
//     StopAccelerating();
//     StopForcingThrottle();
//     horizontal_facing_vector = null;
// }

// rule: "[Bhop] :: Start Accel Dir"
// Event.OngoingPlayer
// if (bhopping)
// if (!using_grapple)
// if (ThrottleOf().Z != 1)
// {
//     horizontal_facing_vector = DirectionFromAngles(HorizontalFacingAngleOf(), 0);

//     if (SpeedOfInDirection(player, DirectionFromAngles(HorizontalFacingAngleOf(), 0)) >= 0)
//     {
//         // lol
//         ForceThrottle(player, 0.9999, 1, 0, 1, 0, 1); // forces player to hold W, unable to use throttle 1 for Z because stopping the accel dir relies on the throttle being 1
//         StartAccelerating(player, Forward(), 10000, 60, Relative.ToPlayer, AccelerateRev.DirectionRateAndMaxSpeed);
//     }
//     // else
//     // {
//     //     ForceThrottle(player, 0, 1, 0.9999, 1, 0, 1);
//     //     StartAccelerating(player, Backward(), 1000, 120, Relative.ToPlayer, AccelerateRev.DirectionRateAndMaxSpeed);
//     //     horizontal_facing_vector = -horizontal_facing_vector;
//     // }

//     StartAccelerating(player, horizontal_facing_vector, 1000, 60, Relative.ToWorld, AccelerateRev.DirectionRateAndMaxSpeed);
// }

// rule: "[Bhop] :: Stop Accel Dir if moving"
// Event.OngoingPlayer
// if (bhopping)
// if (ThrottleOf().Z == 1 || ThrottleOf().Z == -1)
// {
//     // StopAccelDir();
// }

// rule: "[Bhop] :: Stop Accel Dir if Grapple"
// Event.OngoingPlayer
// if (using_grapple)
// {
//     // StopAccelDir();
// }

rule: "[Bhop] :: Airborne"
Event.OngoingPlayer
if (s_bhop_enabled)
if ((!using_grapple && IsInAir() && HorizontalSpeedOf() > 5.14) || (using_grapple && IsInAir()))
{
    ChaseVariableAtRate(bhop_speed, S_BHOP_MAX_SPEED, S_BHOP_SPEED_RATE, RateChaseReevaluation.None);
    is_chasing = true;
    bhopping = true;
}

rule: "[Bhop] :: Update Speed"
Event.OngoingPlayer
if (is_chasing)
{
    SetMoveSpeed(player, bhop_speed);
    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Bhop] :: Update is_chasing"
Event.OngoingPlayer
if (is_chasing && bhop_speed == S_BHOP_MAX_SPEED || bhop_speed == 100)
{
    StopChasingVariable(bhop_speed);
    is_chasing = false;
}

rule: "[Bhop] :: Stop chasing"
Event.OngoingPlayer
if (!using_grapple && (is_chasing || bhop_speed == S_BHOP_MAX_SPEED) && HorizontalSpeedOf() < 5.14)
{
    ResetSpeed();
    // StopAccelDir();
}

rule: "[Bhop] :: Stop if player is on ground"
Event.OngoingPlayer
if ((IsOnGround() && !using_grapple) && (bhop_speed > 100))
{
    WaitIfTrue(0.25);
    ResetSpeed();
    // StopAccelDir();
}

// ............########...#######..########...######...########...........
// ............##.....##.##.....##.##.....##.##....##..##.................
// ............##.....##.##.....##.##.....##.##........##.................
// .#######....##.....##.##.....##.##.....##.##...####.######......#######
// ............##.....##.##.....##.##.....##.##....##..##.................
// ............##.....##.##.....##.##.....##.##....##..##.................
// ............########...#######..########...######...########...........
disabled rule: "---------------- Dodge ----------------"{}

rule: "[Dodge] :: Action"
Event.OngoingPlayer
if (s_dodge_enabled)
if (can_dodge)
if (!using_grapple)
if (IsButtonHeld(player, Button.Ability1))
{
    throttle_of = ThrottleOf() + Vector(0, 0.5, 0);

    if (throttle_of == Vector(0, 0.5, 0))
        throttle_of = Vector(0, 0.5, 1);

    ApplyImpulse(player, throttle_of, S_DODGE_FORCE, Relative.ToPlayer, ContraryMotion.Cancel);

    if (bhop_speed < 120)
        bhop_speed += S_BHOP_SPEED_RATE * 3;

    can_dodge = false;
}

rule: "[Dodge] :: On Ground"
Event.OngoingPlayer
if (IsOnGround())
{
    can_dodge = true;
}

// .............######..########..######...#######..##....##.########.....###....########..##....##...........
// ............##....##.##.......##....##.##.....##.###...##.##.....##...##.##...##.....##..##..##............
// ............##.......##.......##.......##.....##.####..##.##.....##..##...##..##.....##...####.............
// .#######.....######..######...##.......##.....##.##.##.##.##.....##.##.....##.########.....##.......#######
// ..................##.##.......##.......##.....##.##..####.##.....##.#########.##...##......##..............
// ............##....##.##.......##....##.##.....##.##...###.##.....##.##.....##.##....##.....##..............
// .............######..########..######...#######..##....##.########..##.....##.##.....##....##..............
disabled rule: "---------------- Secondary Fire ----------------"{}

rule: "[Secondary Fire] :: Projectile"
Event.OngoingPlayer
if (s_sec_enabled)
if (IsButtonHeld(player, Button.SecondaryFire))
if (IsAlive())
{
    sec_rc_start = EyePosition();
    sec_rc_end = EyePosition() + Facing() * 100;

    PlayEffect(all, PlayEffect.RingExplosionSound, Color.White, player, 50);

    DestroyEffect(sec_orb[0]);
    DestroyEffect(sec_orb[1]);

    // secondaryHit = RayCastHitPosition(sec_rc_start, sec_rc_end, AllLivingPlayers(), player);
    sec_eyepos = EyePosition();

    CreateEffect(all, Effect.Orb, Color.Red, sec_eyepos, 0.25);
    sec_orb[0] = LastCreatedEntity();
    CreateEffect(all, Effect.BadAura, Color.Red, sec_eyepos, 0.5);
    sec_orb[1] = LastCreatedEntity();

    ChaseVariableAtRate(sec_eyepos, RayCastHitPosition(sec_rc_start, sec_rc_end, AllLivingPlayers(), player), S_SEC_PSPEED, RateChaseReevaluation.DestinationAndRate);

    Wait(0.75);
    LoopIfConditionIsTrue();
}

rule: "[Secondary Fire] :: Projectile Impulse"
Event.OngoingPlayer
if (DistanceBetween(sec_eyepos, RayCastHitPosition(sec_rc_start, sec_rc_end, AllLivingPlayers(), player)) < 0.1)
{
    // sec_in_air = false;
    StopChasingVariable(sec_eyepos);
    any[] players = FilteredArray(AllLivingPlayers(), DistanceBetween(Curr(), sec_eyepos) <= S_SEC_RADIUS);
    for (num i = 0; i < CountOf(players); i++)
    {
        ApplyImpulse(players[i], DirectionTowards(sec_eyepos, players[i] + Vector(0, 2, 0)), 15, Relative.ToWorld, ContraryMotion.Incorporate);
    }

    PlayEffect(all, PlayEffect.GoodExplosion, Color.Red, sec_eyepos, S_SEC_RADIUS);

    DestroyEffect(sec_orb[0]);
    DestroyEffect(sec_orb[1]);
}

// .............######...########.....###....########..########..##.......########...........
// ............##....##..##.....##...##.##...##.....##.##.....##.##.......##.................
// ............##........##.....##..##...##..##.....##.##.....##.##.......##.................
// .#######....##...####.########..##.....##.########..########..##.......######......#######
// ............##....##..##...##...#########.##........##........##.......##.................
// ............##....##..##....##..##.....##.##........##........##.......##.................
// .............######...##.....##.##.....##.##........##........########.########...........
disabled rule: "---------------- Grapple ----------------"{}

void EndGrapple() playervar "[Sub] :: End Grapple"
{
    using_grapple = false;
    StopForcingThrottle();
    DestroyEffect(grapple_sphere);
    DestroyEffect(grapple_beam);

    grapple_hit_player = null;
}

rule: "[Grapple] :: Grapple Start"
Event.OngoingPlayer
if (match_started)
if (s_grapple_enabled)
if (IsAlive())
if (IsButtonHeld(player, Button.Ability2))
{
    grapple_hit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * S_GRAPPLE_RANGE, AllLivingPlayers(), player);
    grapple_hit_player = RayCastHitPlayer(EyePosition(), EyePosition() + Facing() * S_GRAPPLE_RANGE, AllLivingPlayers(), player, true);
    vec grapple_eyepos = EyePosition();

    CreateBeamEffect(all, BeamType.BrigitteFlailChainBeam, player, grapple_hit_player ? grapple_hit_player : grapple_hit, Color.White, EffectRev.VisibleToPositionAndRadius);
    grapple_beam = LastCreatedEntity();

    if (DistanceBetween(grapple_eyepos, grapple_hit) < S_GRAPPLE_RANGE && DistanceBetween(player, grapple_hit) > 3) // grapple hit
    {
        CreateEffect(all, Effect.Sphere, Color.Yellow, grapple_hit_player ? grapple_hit_player : grapple_hit, 0.2);
        grapple_sphere = LastCreatedEntity();

        PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, grapple_hit, 0.2);
        PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, player, 0.33);
        PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 100);

        using_grapple = true;
    }
    else // grapple miss
    {
        Wait(0.25);
        EndGrapple();
    }

    Wait(0.5);
    LoopIf(IsButtonHeld(player, Button.Ability2) && IsAlive() && !using_grapple);
}

rule: "[Grapple] :: Pull"
Event.OngoingPlayer
if (using_grapple)
{
    ForceThrottle(player, 0, 0.05, 0, 0.05, 0, 0.05);

    if (grapple_hit_player && IsAlive(grapple_hit_player))
        ApplyImpulse(grapple_hit_player, Vector(0, 0.3, 0) + DirectionTowards(grapple_hit_player, EyePosition()), S_GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);
    else if (IsButtonHeld(player, Button.Jump)) // push the player upwards more if they are holding jump
        ApplyImpulse(player, Vector(0, 0.3, 0) + DirectionTowards(EyePosition(), grapple_hit), S_GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);
    else // pull inpulse
        ApplyImpulse(player, DirectionTowards(EyePosition(), grapple_hit), S_GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);

    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Grapple] :: Grapple End Ability 2"
Event.OngoingPlayer
if (!IsButtonHeld(player, Button.Ability2))
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End On Death"
Event.OnDeath
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End Grappled Player Dead"
Event.OngoingPlayer
if (IsDead(grapple_hit_player))
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Grappled Player Too Close"
Event.OngoingPlayer
if (s_grapple_option[0])
if (DistanceBetween(player, grapple_hit_player) < 3)
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Too Close"
Event.OngoingPlayer
if (s_grapple_option[0] && DistanceBetween(player, grapple_hit) < 3)
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Player Out of LOS"
Event.OngoingPlayer
if (s_grapple_option[1])
if (!IsInLineOfSight(player, grapple_hit_player))
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Hit Position Out of LOS"
Event.OngoingPlayer
if (s_grapple_option[1]) 
if (!IsInLineOfSight(player, grapple_hit))
{
    WaitIfTrue(0.25);
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Grappled Player out of view angle"
Event.OngoingPlayer
if (s_grapple_option[1])
if (!IsInViewAngle(player, grapple_hit_player, 105))
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Grapple Hit out of view angle"
Event.OngoingPlayer
if (s_grapple_option[1])
if (!IsInViewAngle(player, grapple_hit, 120))
{
    WaitIfTrue(0.25);
    EndGrapple();
}

// ............########..##.....##.########.########...........
// ............##.....##.##.....##.##.......##.................
// ............##.....##.##.....##.##.......##.................
// .#######....########..##.....##.######...######......#######
// ............##.....##.##.....##.##.......##.................
// ............##.....##.##.....##.##.......##.................
// ............########...#######..##.......##.................
disabled rule: "---------------- Buff ----------------"{}

void CollectBuff() playervar "[Sub] :: Collect Buff"
{
    has_buff = true;
    can_pickup_buff[b_index] = false;
    buff_user[b_index] = player;

    switch (true)
    {
        case (b_index == 0):
            LogToInspector(<"Wallbang Enabled for <0>", buff_user[0]>);
            can_pickup_buff[0] = false;
            wallbang_enabled = true;

            BigMessage(player, "Wallbang");
            CreateHudText(player, null, null, 
            <" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0> Wallbang Ammo: <1>/<2> <0>", 
            AbilityIconString(Hero.Baptiste, Button.Ultimate), wallbang_ammo, S_WALLBANG_AMMO>, 
            Location.Top, 1, Color.Yellow, Color.Yellow, Color.Yellow);
            hud_txt[0] = LastTextID();

            // give ammo
            wallbang_ammo = S_WALLBANG_AMMO;

            break;
        case (b_index == 1):
            LogToInspector(<"Ricochet Enabled for <0>", buff_user[1]>);
            can_pickup_buff[1] = false;
            ricochet_enabled = true;

            BigMessage(player, "Ricochet");
    
            CreateHudText(player, null, null, 
            <" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0> Ricochet Ammo: <1>/<2> <0>", 
            AbilityIconString(Hero.Winston, Button.Ability1), ricochet_ammo, S_RICOCHET_AMMO>, 
            Location.Top, 1, Color.Violet, Color.Violet, Color.Violet);
            hud_txt[1] = LastTextID();

            // give ammo
            ricochet_ammo = S_RICOCHET_AMMO;

            break;
        case (b_index == 2):
            LogToInspector(<"Buckshot Enabled for <0>", buff_user[2]>);
            can_pickup_buff[2] = false;
            buckshot_enabled = true;

            // toasts
            CreateHudText(player, null, null, 
            <" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0> Buckshot Ammo: <1>/<2> <0>", 
            AbilityIconString(Hero.Ashe, Button.Ability1), buckshot_ammo, S_BUCKSHOT_AMMO>, 
            Location.Top, 1, Color.Green, Color.Green, Color.Green);
            hud_txt[2] = LastTextID();

            BigMessage(player, "Buckshot");

            // give ammo
            buckshot_ammo = S_BUCKSHOT_AMMO;

            break;
        case (b_index == 3):
            LogToInspector(<"Smart Lock Enabled for <0>", buff_user[3]>);
            can_pickup_buff[3] = false;
            lock_enabled = true;

            // toasts
            CreateHudText(player, null, null,
            <" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0> Smart Lock Ammo: <1>/<2> <0>", 
            AbilityIconString(Hero.Sombra, Button.SecondaryFire), lock_ammo, S_LOCK_AMMO>, 
            Location.Top, 1, CustomColor(28, 81, 255, 255), CustomColor(28, 81, 255, 255), CustomColor(28, 81, 255, 255));
            hud_txt[3] = LastTextID();

            BigMessage(player, "Smart Lock");

            // give ammo
            lock_ammo = S_LOCK_AMMO;

            break;
        case (b_index == 4):
            LogToInspector(<"Vaporizer Enabled for <0>", buff_user[4]>);
            can_pickup_buff[4] = false;
            vap_enabled = true;

            // toasts
            CreateHudText(player, null, null,
            <" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0> Vaporizer Ammo: <1>/<2> <0>", 
            AbilityIconString(Hero.Symmetra, Button.Ultimate), vap_ammo, S_VAP_AMMO>, 
            Location.Top, 1, Color.Rose, Color.Rose, Color.Rose);
            hud_txt[4] = LastTextID();

            BigMessage(player, "Vaporizer");

            // give ammo
            vap_ammo = S_VAP_AMMO;

            break;
        case (b_index == 5):
            LogToInspector(<"Electro Enabled for <0>", buff_user[6]>);
            can_pickup_buff[5] = false;
            electro_enabled = true;

            // toasts
            CreateHudText(player, null, null, 
            <" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0> Electro Ammo: <2>/<3> <0>  |  Press <1> for alternate fire", 
            AbilityIconString(Hero.Echo, Button.SecondaryFire), InputBindingString(Button.Reload), electro_ammo, S_ELECTRO_AMMO>,
            Location.Top, 1, Color.Blue, Color.Blue, Color.Blue);
            hud_txt[5] = LastTextID();

            BigMessage(player, "Electro");

            // give ammo
            electro_ammo = S_ELECTRO_AMMO;

            break;
        case (b_index == 6):
            LogToInspector(<"Spark Enabled for <0>", buff_user[6]>);
            can_pickup_buff[6] = false;
            spark_enabled = true;

            // toasts
            CreateHudText(player, null, null,
            <" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0> Spark Ammo: <2>/<3> <0>  |  Press <1> for alternate fire", 
            AbilityIconString(Hero.Sigma, Button.Ability1), InputBindingString(Button.Reload), spark_ammo, S_SPARK_AMMO>,
            Location.Top, 1, Color.Purple, Color.Purple, Color.Purple);
            hud_txt[6] = LastTextID();

            BigMessage(player, "Spark");

            // give ammo
            spark_ammo = S_SPARK_AMMO;

            break;
        case (b_index == 7):
            LogToInspector(<"Quadshot Enabled for <0>", buff_user[7]>);
            can_pickup_buff[7] = false;
            quadshot_enabled = true;

            // toasts
            CreateHudText(player, null, null, 
            <" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0> Quadshot Ammo: <1>/<2> <0>", 
            AbilityIconString(Hero.Mccree, Button.Ability2), quadshot_ammo, S_QUADSHOT_AMMO>, 
            Location.Top, 1, Color.Orange, Color.Orange, Color.Orange);
            hud_txt[7] = LastTextID();

            BigMessage(player, "Quadshot");

            // give ammo
            quadshot_ammo = S_QUADSHOT_AMMO;

            break;
    }

    // destroy inworld text / icon / orb
    DestroyProgressBarInWorldText(cd_txt[b_index]);
    DestroyInWorldText(cd_txt[b_index]);
    DestroyEffect(sphere_ip_effect[b_index]);
    DestroyEffect(sphere_ip_effect[b_index][0]);
    DestroyEffect(sphere_ip_effect[b_index][1]);
    DestroyInWorldText(buff_icon[b_index]);
    DestroyEffect(buff_effect[b_index]);

    // pickup effects
    PlayEffect(all, PlayEffect.GoodPickupEffect, buff_color, buff_pos[b_index], 1);
    PlayEffect(all, PlayEffect.BuffExplosionSound, buff_color, buff_pos[b_index], 200);

    // create effect
    CreateEffect(IsAlive() ? all : null, Effect.GoodAura, buff_color, player, 0.5, EffectRev.VisibleToPositionAndRadius);
    collected_buff_effect[b_index] = LastCreatedEntity();

    b_index = 99;
    buff_color = null;
}

// ..######...#######...#######..##.......########...#######..##......##.##....##..######.
// .##....##.##.....##.##.....##.##.......##.....##.##.....##.##..##..##.###...##.##....##
// .##.......##.....##.##.....##.##.......##.....##.##.....##.##..##..##.####..##.##......
// .##.......##.....##.##.....##.##.......##.....##.##.....##.##..##..##.##.##.##..######.
// .##.......##.....##.##.....##.##.......##.....##.##.....##.##..##..##.##..####.......##
// .##....##.##.....##.##.....##.##.......##.....##.##.....##.##..##..##.##...###.##....##
// ..######...#######...#######..########.########...#######...###..###..##....##..######.
void WallbangCooldown() "[Sub] :: Wallbang Cooldown" 
{
    if (s_spawn_wallbang)
    {
        if (!EntityExists(buff_user[0]) && wallbang_cd == 0)
                wallbang_cd = S_WALLBANG_CD;

        if (wallbang_cd == S_WALLBANG_CD)
        {
            LogToInspector("Wallbang cooldown started");
            wallbang_pb = 0;
            wallbang_timer = true;

            if (s_cd_type == 0)
                ChaseVariableOverTime(wallbang_pb, 100, S_WALLBANG_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphere_ip_effect[0]);
        DestroyProgressBarInWorldText(cd_txt[0]);
        DestroyInWorldText(cd_txt[0]);

        MinWait();

        if (s_cd_ip_timer && s_cd_type != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Yellow, buff_pos[0], wallbang_pb * 0.004, EffectRev.PositionAndRadius);
            sphere_ip_effect[0] = LastCreatedEntity();
        }

        if (s_cd_type == 0)
        {
            CreateProgressBarInWorldText(all, wallbang_pb, null, buff_pos[0] + Vector(0, wallbang_pb * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Yellow, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cd_txt[0] = LastTextID();
        }
        else if (s_cd_type == 1)
        {
            CreateInWorldText(all, wallbang_txt, buff_pos[0], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cd_txt[0] = LastTextID();
        }
    }
}

void RicochetCooldown() "[Sub] :: Ricochet Cooldown"
{
    if (s_spawn_ricochet)
    {
        if (!EntityExists(buff_user[1]) && ricochet_cd == 0)
            ricochet_cd = S_RICOCHET_CD;

        if (ricochet_cd == S_RICOCHET_CD)
        {
            LogToInspector("Riochet cooldown started");
            ricochet_pb = 0;
            ricochet_timer = true;

            if (s_cd_type == 0)
                ChaseVariableOverTime(ricochet_pb, 100, S_RICOCHET_CD, TimeChaseReevaluation.None);
        }
        
        // destroy and recreate the effects, just in case
        DestroyEffect(sphere_ip_effect[1]);
        DestroyProgressBarInWorldText(cd_txt[1]);
        DestroyInWorldText(cd_txt[1]);

        MinWait();

        if (s_cd_ip_timer && s_cd_type != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Violet, buff_pos[1], ricochet_pb * 0.004, EffectRev.PositionAndRadius);
            sphere_ip_effect[1] = LastCreatedEntity();
        }

        if (s_cd_type == 0)
        {
            CreateProgressBarInWorldText(all, ricochet_pb, null, buff_pos[1] + Vector(0, ricochet_pb * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Violet, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cd_txt[1] = LastTextID();
        }
        else if (s_cd_type == 1)
        {
            CreateInWorldText(all, ricochet_txt, buff_pos[1], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cd_txt[1] = LastTextID();
        }
    }
}

void BuckshotCooldown() "[Sub] :: Buckshot Cooldown"
{
    if (s_spawn_buckshot)
    {
        if (!EntityExists(buff_user[2]) && buckshot_cd == 0)
            buckshot_cd = S_BUCKSHOT_CD;

        if (buckshot_cd == S_BUCKSHOT_CD)
        {
            LogToInspector("Buckshot cooldown started");
            buckshot_pb = 0;
            buckshot_timer = true;

            if (s_cd_type == 0)
                ChaseVariableOverTime(buckshot_pb, 100, S_BUCKSHOT_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphere_ip_effect[2]);
        DestroyProgressBarInWorldText(cd_txt[2]);
        DestroyInWorldText(cd_txt[2]);

        MinWait();

        if (s_cd_ip_timer && s_cd_type != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Green, buff_pos[2], buckshot_pb * 0.004, EffectRev.PositionAndRadius);
            sphere_ip_effect[2][0] = LastCreatedEntity();
            CreateEffect(all, Effect.GoodAura, Color.Green, buff_pos[2], buckshot_pb * 0.004, EffectRev.PositionAndRadius);
            sphere_ip_effect[2][1] = LastCreatedEntity();
        }

        if (s_cd_type == 0)
        {
            CreateProgressBarInWorldText(all, buckshot_pb, null, buff_pos[2] + Vector(0, buckshot_pb * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, CustomColor(0, 255, 0, 255), Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cd_txt[2] = LastTextID();
        }
        else if (s_cd_type == 1)
        {
            CreateInWorldText(all, buckshot_txt, buff_pos[2], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cd_txt[2] = LastTextID();
        }
    }
}

void LockCooldown() "[Sub] :: Lock Cooldown"
{
    if (s_spawn_lock)
    {
        if (!EntityExists(buff_user[3]) && lock_cd == 0)
            lock_cd = S_LOCK_CD;

        if (lock_cd == S_LOCK_CD)
        {
            LogToInspector("Smart Lock cooldown started");
            lock_pb = 0;
            lock_timer = true;

            if (s_cd_type == 0)
                ChaseVariableOverTime(lock_pb, 100, S_LOCK_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphere_ip_effect[3]);
        DestroyProgressBarInWorldText(cd_txt[3]);
        DestroyInWorldText(cd_txt[3]);

        MinWait();

        if (s_cd_ip_timer && s_cd_type != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Blue, buff_pos[3], lock_pb * 0.004, EffectRev.PositionAndRadius);
            sphere_ip_effect[3][0] = LastCreatedEntity();
            CreateEffect(all, Effect.GoodAura, Color.Blue, buff_pos[3], lock_pb * 0.004, EffectRev.PositionAndRadius);
            sphere_ip_effect[3][1] = LastCreatedEntity();
        }

        if (s_cd_type == 0)
        {
            CreateProgressBarInWorldText(all, lock_pb, null, buff_pos[3] + Vector(0, lock_pb * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, CustomColor(54, 55, 212, 255), Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cd_txt[3] = LastTextID(); 
        }
        else if (s_cd_type == 1)
        {
            CreateInWorldText(all, lock_txt, buff_pos[3], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cd_txt[3] = LastTextID(); 
        }
    }
}

void VaporizerCooldown() "[Sub] :: Vaporizer Cooldown"
{
    if (s_spawn_vap)
    {
        if (!EntityExists(buff_user[4]) && vap_cd == 0)
            vap_cd = S_VAP_CD;

        if (vap_cd == S_VAP_CD)
        {
            LogToInspector("Vaporizer cooldown started");
            vap_pb = 0;
            vap_timer = true;

            if (s_cd_type == 0)
                ChaseVariableOverTime(vap_pb, 100, S_VAP_CD, TimeChaseReevaluation.None);
        }
        
        // destroy and recreate the effects, just in case
        DestroyEffect(sphere_ip_effect[4]);
        DestroyProgressBarInWorldText(cd_txt[4]);
        DestroyInWorldText(cd_txt[4]);

        MinWait();

        if (s_cd_ip_timer && s_cd_type != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Rose, buff_pos[4], vap_pb * 0.004);
            sphere_ip_effect[4][0] = LastCreatedEntity();
            CreateEffect(all, Effect.GoodAura, Color.Rose, buff_pos[4], vap_pb * 0.004);
            sphere_ip_effect[4][1] = LastCreatedEntity();
        }

        if (s_cd_type == 0)
        {
            CreateProgressBarInWorldText(all, vap_pb, null, buff_pos[4] + Vector(0, vap_pb * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Rose, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cd_txt[4] = LastTextID();
        }
        else if (s_cd_type == 1)
        {
            CreateInWorldText(all, vap_txt, buff_pos[4], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cd_txt[4] = LastTextID();
        }
    }
}

void ElectroCooldown() "[Sub] :: Electro Cooldown"
{
    if (s_spawn_electro)
    {
        if (!EntityExists(buff_user[5]) && electro_cd == 0)
            electro_cd = S_ELECTRO_CD;

        if (electro_cd == S_ELECTRO_CD)
        {
            LogToInspector("Electro cooldown started");
            electro_pb = 0;
            electro_timer = true;

            if (s_cd_type == 0)
                ChaseVariableOverTime(electro_pb, 100, S_ELECTRO_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphere_ip_effect[5]);
        DestroyProgressBarInWorldText(cd_txt[5]);
        DestroyInWorldText(cd_txt[5]);

        MinWait();

        if (s_cd_ip_timer && s_cd_type != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.SkyBlue, buff_pos[5], electro_pb * 0.004, EffectRev.PositionAndRadius);
            sphere_ip_effect[5] = LastCreatedEntity();
        }

        if (s_cd_type == 0)
        {
            CreateProgressBarInWorldText(all, electro_pb, null, buff_pos[5] + Vector(0, electro_pb * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Blue, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cd_txt[5] = LastTextID();
        }
        else if (s_cd_type == 1)
        {
            CreateInWorldText(all, electro_txt, buff_pos[5], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cd_txt[5] = LastTextID();
        }
    }
}

void SparkCooldown() "[Sub] :: Spark Cooldown"
{
    if (s_spawn_spark)
    {
        if (!EntityExists(buff_user[6]) && spark_cd == 0)
            spark_cd = S_SPARK_CD;

        if (spark_cd == S_SPARK_CD)
        {
            LogToInspector("Spark cooldown started");
            spark_pb = 0;
            spark_timer = true;

            if (s_cd_type == 0)
                ChaseVariableOverTime(spark_pb, 100, S_SPARK_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphere_ip_effect[6]);
        DestroyProgressBarInWorldText(cd_txt[6]);
        DestroyInWorldText(cd_txt[6]);

        MinWait();

        if (s_cd_ip_timer && s_cd_type != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Purple, buff_pos[6], spark_pb * 0.004, EffectRev.PositionAndRadius);
            sphere_ip_effect[6] = LastCreatedEntity();
        }

        if (s_cd_type == 0)
        {
            CreateProgressBarInWorldText(all, spark_pb, null, buff_pos[6] + Vector(0, spark_pb * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Purple, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cd_txt[6] = LastTextID();
        }
        else if (s_cd_type == 1)
        {
            CreateInWorldText(all, spark_txt, buff_pos[6], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cd_txt[6] = LastTextID();
        }
    }
}

void QuadshotCooldown() "[Sub] :: Quadshot Cooldown"
{
    if (s_spawn_quadshot)
    {
        if (!EntityExists(buff_user[7]) && quadshot_cd == 0)
            quadshot_cd = S_QUADSHOT_CD;

        if (quadshot_cd == S_QUADSHOT_CD)
        {
            LogToInspector("Quadshot cooldown started");
            quadshot_pb = 0;
            quadshot_timer = true;

            if (s_cd_type == 0)
                ChaseVariableOverTime(quadshot_pb, 100, S_QUADSHOT_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphere_ip_effect[7]);
        DestroyProgressBarInWorldText(cd_txt[7]);
        DestroyInWorldText(cd_txt[7]);

        MinWait();

        if (s_cd_ip_timer && s_cd_type != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Orange, buff_pos[7], quadshot_pb * 0.004, EffectRev.PositionAndRadius);
            sphere_ip_effect[7] = LastCreatedEntity();
        }

        if (s_cd_type == 0)
        {
            CreateProgressBarInWorldText(all, quadshot_pb, null, buff_pos[7] + Vector(0, quadshot_pb * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Orange, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cd_txt[7] = LastTextID();
        }
        else if (s_cd_type == 1)
        {
            CreateInWorldText(all, quadshot_txt, buff_pos[7], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cd_txt[7] = LastTextID();
        }
    }
}

// .########.####.##.....##.########.########...######.
// ....##.....##..###...###.##.......##.....##.##....##
// ....##.....##..####.####.##.......##.....##.##......
// ....##.....##..##.###.##.######...########...######.
// ....##.....##..##.....##.##.......##...##.........##
// ....##.....##..##.....##.##.......##....##..##....##
// ....##....####.##.....##.########.##.....##..######.

rule: "[Buff] :: Wallbang Timer"
if (wallbang_timer)
{
    wallbang_cd--;

    wallbang_txt = <"<0><1>", 
                wallbang_cd >= 60 
                    ? <"<0>:", RoundToInteger(wallbang_cd / 60, Rounding.Down)> 
                    : "", 
                wallbang_cd % 60 < 10 && wallbang_cd >= 60 
                    ? <"0<0>", wallbang_cd % 60>
                    : wallbang_cd % 60>;

    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Ricochet Timer"
if (ricochet_timer)
{
    ricochet_cd--;

    ricochet_txt = <"<0><1>", 
                ricochet_cd >= 60 
                    ? <"<0>:", RoundToInteger(ricochet_cd / 60, Rounding.Down)> 
                    : "", 
                ricochet_cd % 60 < 10 && ricochet_cd >= 60 
                    ? <"0<0>", ricochet_cd % 60>
                    : ricochet_cd % 60>;

    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Buckshot Timer"
if (buckshot_timer)
{
    buckshot_cd--;

    buckshot_txt = <"<0><1>", 
                buckshot_cd >= 60 
                    ? <"<0>:", RoundToInteger(buckshot_cd / 60, Rounding.Down)> 
                    : "", 
                buckshot_cd % 60 < 10 && buckshot_cd >= 60 
                    ? <"0<0>", buckshot_cd % 60>
                    : buckshot_cd % 60>;
    
    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Lock Timer"
if (lock_timer)
{
    lock_cd--;

    lock_txt = <"<0><1>", 
                lock_cd >= 60 
                    ? <"<0>:", RoundToInteger(lock_cd / 60, Rounding.Down)> 
                    : "", 
                lock_cd % 60 < 10 && lock_cd >= 60 
                    ? <"0<0>", lock_cd % 60>
                    : lock_cd % 60>;

    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Vaporizer Timer"
if (vap_timer)
{
    vap_cd--;

    vap_txt = <"<0><1>", 
                vap_cd >= 60 
                    ? <"<0>:", RoundToInteger(vap_cd / 60, Rounding.Down)> 
                    : "", 
                vap_cd % 60 < 10 && vap_cd >= 60 
                    ? <"0<0>", vap_cd % 60>
                    : vap_cd % 60>;

    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Quadshot Timer"
if (quadshot_timer)
{
    quadshot_cd--;

    quadshot_txt = <"<0><1>", 
                quadshot_cd >= 60 
                    ? <"<0>:", RoundToInteger(quadshot_cd / 60, Rounding.Down)> 
                    : "", 
                quadshot_cd % 60 < 10 && quadshot_cd >= 60 
                    ? <"0<0>", quadshot_cd % 60>
                    : quadshot_cd % 60>;
    
    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Spark Timer"
if (spark_timer)
{
    spark_cd--;

    spark_txt = <"<0><1>", 
                spark_cd >= 60 
                    ? <"<0>:", RoundToInteger(spark_cd / 60, Rounding.Down)> 
                    : "", 
                spark_cd % 60 < 10 && spark_cd >= 60 
                    ? <"0<0>", spark_cd % 60>
                    : spark_cd % 60>;
    
    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Electro Timer"
if (electro_timer)
{
    electro_cd--;

    electro_txt = <"<0><1>", 
                electro_cd >= 60 
                    ? <"<0>:", RoundToInteger(electro_cd / 60, Rounding.Down)> 
                    : "", 
                electro_cd % 60 < 10 && electro_cd >= 60 
                    ? <"0<0>", electro_cd % 60>
                    : electro_cd % 60>;
    
    Wait(1);
    LoopIfConditionIsTrue();
}

// ............##......##....###....##.......##.......########.....###....##....##..######.............
// ............##..##..##...##.##...##.......##.......##.....##...##.##...###...##.##....##............
// ............##..##..##..##...##..##.......##.......##.....##..##...##..####..##.##..................
// .#######....##..##..##.##.....##.##.......##.......########..##.....##.##.##.##.##...####....#######
// ............##..##..##.#########.##.......##.......##.....##.#########.##..####.##....##............
// ............##..##..##.##.....##.##.......##.......##.....##.##.....##.##...###.##....##............
// .............###..###..##.....##.########.########.########..##.....##.##....##..######.............
disabled rule: "---------------- Wallbang ----------------"{}

rule: "[Buff] :: Wallbang : Create Orb"
if (match_started)
if (valid_map)
if (s_spawn_wallbang)
if (wallbang_cd == 0)
{
    can_pickup_buff[0] = true;
    LogToInspector("Wallbang Orb Created");

    DestroyEffect(sphere_ip_effect[0]);

    CreateEffect(all, Effect.Orb, Color.Yellow, buff_pos[0], 2, EffectRev.None);
    buff_effect[0] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Yellow, buff_pos[0], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Baptiste, Button.Ultimate), buff_pos[0] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buff_icon[0] = LastTextID();

    DestroyProgressBarInWorldText(cd_txt[0]);
    DestroyInWorldText(cd_txt[0]);

    wallbang_timer = false;
    StopChasingVariable(wallbang_pb);
}

rule: "[Buff] :: Wallbang : Collect"
Event.OngoingPlayer
if (HasSpawned())
if (!has_buff)
if (can_pickup_buff[0])
if (DistanceBetween(buff_pos[0], PositionOf() + Up()) < S_PICKUP_RAD)
if (IsAlive())
{
    b_index = 0;
    buff_color = Color.Yellow;
    CollectBuff();

    // start in world cooldown
    wallbang_cd = S_WALLBANG_CD;
    WallbangCooldown(); 
}

rule: "[Buff] :: Wallbang : Remove"
Event.OngoingPlayer
if (wallbang_enabled)
if (wallbang_ammo <= 0)
{
    Wait(0.128);
    LogToInspector(<"Wallbang Disabled for <0>", buff_user[0]>);

    DestroyHudText(hud_txt[0]);
    DestroyEffect(collected_buff_effect[0]);

    wallbang_enabled = false;
    has_buff = false;
}

// rule: "[Buff] :: Wallbang : Wallhack"
// Event.OnPlayerJoin
// {
//     CreateInWorldText(FilteredArray(RemoveFromArray(AllLivingPlayers(), player), IsInViewAngle(Curr(), player, 3) && IsAlive() && !IsInLineOfSight(Curr(), EyePosition()) /* && Curr().wallbang_enabled */), 
//     " \n\n\n\n\n\n\n\n\n\n\n\n\n\n◈", player, 2, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, Color.Yellow);
//     wh_txt = LastTextID();
// }

rule: "[Buff] :: Wallbang : Action"
Event.OngoingPlayer
if (wallbang_enabled)
if (wallbang_ammo > 0)
if (IsFiringPrimary())
{
    wallbang_ammo--;
    vec gun_pos = EyePosition() + Facing() + weapon_muzzle;
    vec wallbang_hitpos = EyePosition();

    player wallbang_hitplayer;

    for (num i = 0; DistanceBetween(wallbang_hitpos, wallbang_hitpos) < 100 && i < S_NUM_WALLBANGS; i++)
    {
        wallbang_hitpos = RayCastHitPosition(wallbang_hitpos + Facing(), wallbang_hitpos + Facing() * (100 - DistanceBetween(wallbang_hitpos, wallbang_hitpos)), AllLivingPlayers(), player, true);
        wallbang_hitplayer = RayCastHitPlayer(wallbang_hitpos, wallbang_hitpos + Facing() * (100 - DistanceBetween(wallbang_hitpos, wallbang_hitpos)), AllLivingPlayers(), player, true);

        PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, wallbang_hitpos, 0.2);

        if (wallbang_hitplayer != null && wallbang_hitplayer != player)
        {
            Damage(wallbang_hitplayer, player, 10000);
        }
    }

    CreateBeamEffect(all, BeamType.BadBeam, gun_pos, wallbang_hitpos, Color.Yellow, EffectRev.None);
    wallbang_effect[0] = LastCreatedEntity();

    Wait(0.25);
    DestroyEffect(wallbang_effect[0]);
}

// ............########..####..######...#######...######..##.....##.########.########...........
// ............##.....##..##..##....##.##.....##.##....##.##.....##.##..........##..............
// ............##.....##..##..##.......##.....##.##.......##.....##.##..........##..............
// .#######....########...##..##.......##.....##.##.......#########.######......##.......#######
// ............##...##....##..##.......##.....##.##.......##.....##.##..........##..............
// ............##....##...##..##....##.##.....##.##....##.##.....##.##..........##..............
// ............##.....##.####..######...#######...######..##.....##.########....##..............
disabled rule: "---------------- Ricochet ----------------"{}

rule: "[Buff] :: Ricochet : Create Orb"
if (match_started)
if (valid_map)
if (s_spawn_ricochet)
if (ricochet_cd == 0)
{
    LogToInspector("Ricochet Orb Created");
    can_pickup_buff[1] = true;

    DestroyEffect(sphere_ip_effect[1]);

    CreateEffect(all, Effect.Orb, Color.Violet, buff_pos[1], 2, EffectRev.None);
    buff_effect[1] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Violet, buff_pos[1], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Winston, Button.Ability1), buff_pos[1] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buff_icon[1] = LastTextID();

    DestroyProgressBarInWorldText(cd_txt[1]);
    DestroyInWorldText(cd_txt[1]);

    ricochet_timer = false;
    StopChasingVariable(ricochet_pb);
}

rule: "[Buff] :: Ricochet : Collect"
Event.OngoingPlayer
if (HasSpawned())
if (!has_buff)
if (can_pickup_buff[1])
if (DistanceBetween(buff_pos[1], PositionOf() + Up()) < S_PICKUP_RAD)
if (IsAlive())
{
    b_index = 1;
    buff_color = Color.Violet;
    CollectBuff();

    // start in world cooldown
    ricochet_cd = S_RICOCHET_CD;
    RicochetCooldown(); 
}

rule: "[Buff] :: Ricochet : Remove"
Event.OngoingPlayer
if (ricochet_enabled)
if (ricochet_ammo <= 0)
{
    Wait(0.128);
    LogToInspector(<"Riochet Disabled for <0>", buff_user[1]>);

    DestroyHudText(hud_txt[1]);
    DestroyEffect(collected_buff_effect[1]);

    ricochet_enabled = false;
    has_buff = false;
}


rule: "[Buff] :: Ricochet : Action"
Event.OngoingPlayer
if (ricochet_enabled)
if (ricochet_ammo > 0)
if (IsFiringPrimary())
{
    ricochet_ammo--;

    vec[] normals = [];
    vec[] hp = [];
    vec[] hp_ricochets = [];
    any[] hp_player = [];
    any[] ricochets = [];
    any[] hp_player_ricochets = [];
    any[] ricochet_effects = [];
    any ricochet_effect;

    eye_pos = EyePosition()/*  + Facing() + weapon_muzzle */;
    facing = Facing();

    vec start_pos = weapon_muzzle;
    vec first_hp = RayCastHitPosition(eye_pos, eye_pos + facing * 100, AllLivingPlayers(), player, true);

    CreateBeamEffect(all, BeamType.BadBeam, eye_pos + facing + start_pos, first_hp, Color.Violet, EffectRev.None);
    ricochet_effect = LastCreatedEntity();

    for (num i = 0; DistanceBetween(eye_pos, first_hp) < 99 && i < S_NUM_RICOCHETS; i++)
    {
        if (i > 0)
        {
            eye_pos = hp[i - 1];
            facing = ricochets[i - 1];
        }

        # https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector/4019883#4019883
        normals[i] = RayCastHitNormal(eye_pos, eye_pos + facing * 100, AllLivingPlayers(), player, true);
        hp[i] = RayCastHitPosition(eye_pos, eye_pos + facing * 100, AllLivingPlayers(), player, true);
        hp_player[i] = RayCastHitPlayer(eye_pos, eye_pos + facing * 100, AllLivingPlayers(), player, true);
        # the integer is how 'strong' the reflection vector is, too low and it will 'run' along surfaces, too high and it does the opposite
        ricochets[i] = facing - (2 * (normals[i] * DotProduct(facing, normals[i])));
        hp_ricochets[i] = RayCastHitPosition(hp[i], hp[i] + ricochets[i] * 100, AllLivingPlayers(), player, true);
        hp_player_ricochets[i] = RayCastHitPlayer(hp[i], hp[i] + ricochets[i] * 100, AllLivingPlayers(), player, true);

        CreateBeamEffect(all, BeamType.BadBeam, hp[i], hp_ricochets[i], Color.Violet, EffectRev.None); // ricochets
        ricochet_effects[i] = LastCreatedEntity();

        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, hp[i], 0.2); // first raycast hit
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, hp_ricochets[i], 0.2); // ricochets

        Damage(hp_player[i], player, 10000);
        Damage(hp_player_ricochets[i], player, 10000);

        if (DistanceBetween(hp[i], hp_ricochets[i]) > 99)
            break;
    }

    Wait(0.25);
    DestroyEffect(ricochet_effect);
    for (num i = 0; i < S_NUM_RICOCHETS; i++)
    {
        // DestroyEffect(ricochet_effect[i]);
        DestroyEffect(ricochet_effects[i]);
    }
}

// ............########..##.....##..######..##....##..######..##.....##..#######..########...........
// ............##.....##.##.....##.##....##.##...##..##....##.##.....##.##.....##....##..............
// ............##.....##.##.....##.##.......##..##...##.......##.....##.##.....##....##..............
// .#######....########..##.....##.##.......#####.....######..#########.##.....##....##.......#######
// ............##.....##.##.....##.##.......##..##.........##.##.....##.##.....##....##..............
// ............##.....##.##.....##.##....##.##...##..##....##.##.....##.##.....##....##..............
// ............########...#######...######..##....##..######..##.....##..#######.....##..............
disabled rule: "---------------- Buckshot ----------------"{}

rule: "[Buff] :: Buckshot : Create Orb"
if (match_started)
if (valid_map)
if (s_spawn_buckshot)
if (buckshot_cd == 0)
{
    LogToInspector("Buckshot Orb Created");
    can_pickup_buff[2] = true;

    DestroyEffect(sphere_ip_effect[2][0]);

    CreateEffect(all, Effect.Orb, Color.Green, buff_pos[2], 2, EffectRev.None);
    buff_effect[2] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Green, buff_pos[2], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Ashe, Button.Ability1), buff_pos[2] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buff_icon[2] = LastTextID();

    DestroyProgressBarInWorldText(cd_txt[2]);
    DestroyInWorldText(cd_txt[2]);

    buckshot_timer = false;
    StopChasingVariable(buckshot_pb);
}

rule: "[Buff] :: Buckshot : Collect"
Event.OngoingPlayer
if (HasSpawned())
if (!has_buff)
if (can_pickup_buff[2])
if (DistanceBetween(buff_pos[2], PositionOf() + Up()) < S_PICKUP_RAD)
if (IsAlive())
{
    b_index = 2;
    buff_color = Color.Green;
    CollectBuff();

    // start in world cooldown
    buckshot_cd = S_BUCKSHOT_CD;
    BuckshotCooldown(); 
}

rule: "[Buff] :: Buckshot : Remove"
Event.OngoingPlayer
if (buckshot_enabled)
if (buckshot_ammo <= 0)
{
    Wait(0.128);
    LogToInspector(<"Buckshot Disabled for <0>", buff_user[2]>);

    DestroyHudText(hud_txt[2]);
    DestroyEffect(collected_buff_effect[2]);

    buckshot_enabled = false;
    has_buff = false;
}

rule: "[Buff] :: Buckshot : Action"
Event.OngoingPlayer
if (buckshot_enabled)
if (buckshot_ammo > 0)
if (IsFiringPrimary())
{
    buckshot_ammo--;

    vec gun_pos = weapon_muzzle;
    vec[] buckshot_hp = [];
    player[] buckshot_hp_player = [];
    any[] buckshot_beam = [];
    any center_beam;

    num bs_spread_diag = S_BUCKSHOT_SPREAD - (S_BUCKSHOT_SPREAD * 0.33);
    num bs_spread_hori = S_BUCKSHOT_SPREAD;

    // center
    vec buckshot_center = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);

    // lower left 1
    buckshot_hp[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bs_spread_diag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bs_spread_diag) 
    * 100, AllLivingPlayers(), player, false);

    // upper left 1
    buckshot_hp[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bs_spread_diag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bs_spread_diag) 
    * 100, AllLivingPlayers(), player, false);

    // lower right 1
    buckshot_hp[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bs_spread_diag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bs_spread_diag) 
    * 100, AllLivingPlayers(), player, false);

    // upper right 1
    buckshot_hp[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bs_spread_diag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bs_spread_diag) 
    * 100, AllLivingPlayers(), player, false);

    // mid left 1
    buckshot_hp[4] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bs_spread_hori) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    * 100, AllLivingPlayers(), player, false);

    // mid right 1
    buckshot_hp[5] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bs_spread_hori) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    * 100, AllLivingPlayers(), player, false);

    ////////////
    // player //
    ////////////

    // lower left 1
    buckshot_hp_player[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bs_spread_diag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bs_spread_diag) 
    * 100, AllLivingPlayers(), player, false);

    // upper left 1
    buckshot_hp_player[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bs_spread_diag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bs_spread_diag) 
    * 100, AllLivingPlayers(), player, false);

    // lower right 1
    buckshot_hp_player[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bs_spread_diag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bs_spread_diag) 
    * 100, AllLivingPlayers(), player, false);

    // upper right 1
    buckshot_hp_player[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bs_spread_diag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bs_spread_diag) 
    * 100, AllLivingPlayers(), player, false);

    // mid left 1
    buckshot_hp_player[4] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bs_spread_hori) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    * 100, AllLivingPlayers(), player, false);

    // mid right 1
    buckshot_hp_player[5] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bs_spread_hori) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    * 100, AllLivingPlayers(), player, false);

    
    PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshot_center, 0.2);

    CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gun_pos, buckshot_center, Color.Green, EffectRev.None);
    center_beam = LastCreatedEntity();

    for (num p = 0; p < 6; p++)
    {
        Damage(buckshot_hp_player[p], player, 10000);

        PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshot_hp[p], 0.2);

        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gun_pos, buckshot_hp[p], Color.Green, EffectRev.None);
        buckshot_beam[p] = LastCreatedEntity();
    }

    Wait(0.25);
    DestroyEffect(center_beam);

    for (num e = 0; e < 6; e++)
    {
        DestroyEffect(buckshot_beam[e]);
    }
}

// .............######..##.....##....###....########..########....##........#######...######..##....##...........
// ............##....##.###...###...##.##...##.....##....##.......##.......##.....##.##....##.##...##............
// ............##.......####.####..##...##..##.....##....##.......##.......##.....##.##.......##..##.............
// .#######.....######..##.###.##.##.....##.########.....##.......##.......##.....##.##.......#####.......#######
// ..................##.##.....##.#########.##...##......##.......##.......##.....##.##.......##..##.............
// ............##....##.##.....##.##.....##.##....##.....##.......##.......##.....##.##....##.##...##............
// .............######..##.....##.##.....##.##.....##....##.......########..#######...######..##....##...........
disabled rule: "---------------- Smart Lock ----------------"{}

rule: "[Buff] :: Smart Lock : Create Orb"
if (match_started)
if (valid_map)
if (s_spawn_lock)
if (lock_cd == 0)
{
    can_pickup_buff[3] = true;

    DestroyEffect(sphere_ip_effect[3][0]);

    CreateEffect(all, Effect.Orb, Color.Blue, buff_pos[3], 2, EffectRev.None);
    buff_effect[3] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Blue, buff_pos[3], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Sombra, Button.SecondaryFire), buff_pos[3] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buff_icon[3] = LastTextID();

    DestroyProgressBarInWorldText(cd_txt[3]);
    DestroyInWorldText(cd_txt[3]);

    lock_timer = false;
    StopChasingVariable(lock_pb);
}

rule: "[Buff] :: Smart Lock : Collect"
Event.OngoingPlayer
if (HasSpawned())
if (!has_buff)
if (can_pickup_buff[3])
if (DistanceBetween(buff_pos[3], PositionOf() + Up()) < S_PICKUP_RAD)
if (IsAlive())
{
    b_index = 3;
    buff_color = Color.Blue;
    CollectBuff();

    // start in world cooldown
    lock_cd = S_LOCK_CD;
    LockCooldown();
}

rule: "[Buff] :: Smart Lock : Remove"
Event.OngoingPlayer
if (lock_enabled)
if (lock_ammo <= 0)
{
    Wait(0.128);

    LogToInspector(<"Smart Lock Disabled for <0>", buff_user[3]>);
    DestroyHudText(hud_txt[3]);
    DestroyEffect(collected_buff_effect[3]);

    lock_enabled = false;
    has_buff = false;
}

// symbols:
// locked: ▣
// not locked: □

rule: "[Buff] :: Smart Lock : Lock Text"
Event.OnPlayerJoin
{
    locking_targets = RemoveFromArray(all, player);

    // locking text
    CreateInWorldText(FilteredArray(RemoveFromArray(AllLivingPlayers(), player), Curr().lock_enabled && ArrayContains(Curr().locking_targets, player)), 
    " \n\n\n\n\n□", player, 5, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, CustomColor(28, 81, 255, 255));
    locking_id = LastTextID();

    // locked text
    CreateInWorldText(FilteredArray(RemoveFromArray(AllLivingPlayers(), player), Curr().lock_enabled && ArrayContains(Curr().locked_targets, player)),
    " \n\n\n\n\n▣", player, 5, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, CustomColor(28, 81, 255, 255));
    lock_id = LastTextID();
}

rule: "[Buff] :: Smart Lock : Locking On - Get Players"
Event.OngoingPlayer
if (lock_enabled)
if (IsAlive())
if (CountOf(FilteredArray(RemoveFromArray(AllLivingPlayers(), player), IsAlive(Curr()) && IsInViewAngle(player, Curr(), S_LOCK_RADIUS) && IsInLineOfSight(player, Curr()))) != CountOf(locking_targets))
{
    locking_targets = FilteredArray(RemoveFromArray(AllLivingPlayers(), player), IsAlive(Curr()) && IsInViewAngle(player, Curr(), S_LOCK_RADIUS) && IsInLineOfSight(player, Curr()));
}

rule: "[Buff] :: Smart Lock : Lock On - Lost Target"
Event.OngoingPlayer
if (lock_enabled)
if (IsAlive())
if (CountOf(locking_targets) < CountOf(locked_targets))
{
    MinWait();
    locked_targets = locking_targets;
}

rule: "[Buff] :: Smart Lock : Lock On - Found Target"
Event.OngoingPlayer
if (lock_enabled)
if (IsAlive())
if (CountOf(locking_targets) > CountOf(locked_targets))
{
    Wait(S_LOCK_TIME, WaitBehavior.RestartWhenTrue);
    locked_targets = locking_targets;
}

rule: "[Buff] :: Smart Lock : Fire Action"
Event.OngoingPlayer
if (lock_enabled)
if (IsFiringPrimary())
{
    lock_ammo -= CountOf(locked_targets);

    vec lock_hit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);
    vec gun_pos = weapon_muzzle;

    PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, lock_hit, 0.2);

    CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gun_pos, lock_hit, Color.Blue, EffectRev.None);
    any lock_beam = LastCreatedEntity();

    any[] lock_beams = [];
    for (num i = 0; i < CountOf(locked_targets); i++)
    {
        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gun_pos, locked_targets[i], Color.Blue, EffectRev.None);
        lock_beams[i] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, locked_targets[i], 0.2);
        Damage(locked_targets[i], player, 10000);
    }

    Wait(0.25);
    DestroyEffect(lock_beam);

    for (num i = 0; i < CountOf(lock_beams); i++)
    {
        DestroyEffect(lock_beams[i]);
    }
}
// ............##.....##....###....########...#######..########..####.########.########.########............
// ............##.....##...##.##...##.....##.##.....##.##.....##..##.......##..##.......##.....##...........
// ............##.....##..##...##..##.....##.##.....##.##.....##..##......##...##.......##.....##...........
// .#######....##.....##.##.....##.########..##.....##.########...##.....##....######...########.....#######
// .............##...##..#########.##........##.....##.##...##....##....##.....##.......##...##.............
// ..............##.##...##.....##.##........##.....##.##....##...##...##......##.......##....##............
// ...............###....##.....##.##.........#######..##.....##.####.########.########.##.....##...........
disabled rule: "---------------- Vaporizer ----------------" {}

rule: "[Buff] :: Vaporizer : Create Orb"
if (match_started)
if (valid_map)
if (s_spawn_vap)
if (vap_cd == 0)
{
    LogToInspector("Vaporizer Orb Created");
    can_pickup_buff[4] = true;

    DestroyEffect(sphere_ip_effect[4][0]);

    CreateEffect(all, Effect.Orb, Color.Rose, buff_pos[4], 2, EffectRev.None);
    buff_effect[4] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Rose, buff_pos[4], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Symmetra, Button.Ultimate), buff_pos[4] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buff_icon[4] = LastTextID();

    DestroyProgressBarInWorldText(cd_txt[4]);
    DestroyInWorldText(cd_txt[4]);

    vap_timer = false;
    StopChasingVariable(vap_pb);
}

rule: "[Buff] :: Vaporizer : Collect"
Event.OngoingPlayer
if (HasSpawned())
if (!has_buff)
if (can_pickup_buff[4])
if (DistanceBetween(buff_pos[4], PositionOf() + Up()) < S_PICKUP_RAD)
if (IsAlive())
{
    b_index = 4;
    buff_color = Color.Rose;
    CollectBuff();

    // start in world cooldown
    vap_cd = S_VAP_CD;
    VaporizerCooldown();
}

rule: "[Buff] :: Vaporizer : Remove"
Event.OngoingPlayer
if (vap_enabled)
if (vap_ammo <= 0)
{
    AllowButton(player, Button.PrimaryFire);
    Wait(0.128);

    LogToInspector(<"Vaporizer Disabled for <0>", buff_user[4]>);

    // destroy hud timer and player effect
    DestroyHudText(hud_txt[4]);
    DestroyEffect(collected_buff_effect[4]);

    vap_enabled = false;
    has_buff = false;
}

player[] vap_check: FilteredArray(s_vap_user_affected ? AllLivingPlayers() : RemoveFromArray(AllLivingPlayers(), player), (DistanceBetween(Curr(), vap_hit_pos) <= S_VAP_ESIZE) && IsInLineOfSight(Curr(), vap_hit_pos));
rule: "[Buff] :: Vaporizer : Action"
Event.OngoingPlayer
if (vap_enabled)
if (IsFiringPrimary())
{
    vap_ammo--;

    vap_hit_pos = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);
    vec start_pos = EyePosition() + Facing() + weapon_muzzle;

    CreateIcon(vap_check, vap_hit_pos, Icon.Warning, IconRev.VisibleTo, Color.Rose, true);
    vap_icon = LastCreatedEntity();

    CreateBeamEffect(all, BeamType.BadBeam, start_pos, vap_hit_pos, Color.Rose, EffectRev.None);
    vap_effect[0] = LastCreatedEntity();
    CreateEffect(all, Effect.Orb, Color.Rose, vap_hit_pos, 1, EffectRev.None);
    vap_effect[1] = LastCreatedEntity();
    CreateEffect(all, Effect.GoodAura, Color.Rose, vap_hit_pos, vap_s);
    vap_effect[2] = LastCreatedEntity();
    CreateEffect(all, Effect.Ring, Color.Rose, vap_hit_pos, vap_s);
    vap_effect[3] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.ZaryaParticleCannonExplosionEffect, Color.Team1, vap_hit_pos);

    vap_s = 5;
    ChaseVariableOverTime(vap_s, 0.5, S_VAP_DELAY, TimeChaseReevaluation.None);

    DisallowButton(player, Button.PrimaryFire);

    Wait(0.25);
    DestroyEffect(vap_effect[0]);

    Wait(S_VAP_DELAY - 0.25);
    // WaitUntil(vap_s == 0.5, 9999);
    DestroyIcon(vap_icon);
    AllowButton(player, Button.PrimaryFire);

    StopChasingVariable(vap_s);

    DestroyEffect(vap_effect[1]);
    DestroyEffect(vap_effect[2]);
    DestroyEffect(vap_effect[3]);

    PlayEffect(all, PlayEffect.GoodExplosion, Color.Rose, vap_hit_pos, S_VAP_ESIZE);
    PlayEffect(all, PlayEffect.ExplosionSound, Position: vap_hit_pos, Radius: 200);

    player[] players = vap_check;
    for (num i = 0; i < CountOf(players); i++)
    {
        Damage(players[i], player, 10000);
    }
}

// .............#######..##.....##....###....########...######..##.....##..#######..########...........
// ............##.....##.##.....##...##.##...##.....##.##....##.##.....##.##.....##....##..............
// ............##.....##.##.....##..##...##..##.....##.##.......##.....##.##.....##....##..............
// .#######....##.....##.##.....##.##.....##.##.....##..######..#########.##.....##....##.......#######
// ............##..##.##.##.....##.#########.##.....##.......##.##.....##.##.....##....##..............
// ............##....##..##.....##.##.....##.##.....##.##....##.##.....##.##.....##....##..............
// .............#####.##..#######..##.....##.########...######..##.....##..#######.....##..............
disabled rule: "---------------- Quadshot ----------------"{}

rule: "[Buff] :: Quadshot : Create Orb"
if (match_started)
if (valid_map)
if (s_spawn_quadshot)
if (quadshot_cd == 0)
{
    LogToInspector("Quadshot Orb Created");
    can_pickup_buff[7] = true;

    DestroyEffect(sphere_ip_effect[7]);

    CreateEffect(all, Effect.Orb, Color.Orange, buff_pos[7], 2, EffectRev.None);
    buff_effect[7] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Orange, buff_pos[7], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Mccree, Button.Ability2), buff_pos[7] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buff_icon[7] = LastTextID();

    DestroyProgressBarInWorldText(cd_txt[7]);
    DestroyInWorldText(cd_txt[7]);

    quadshot_timer = false;
    StopChasingVariable(quadshot_pb);
}

rule: "[Buff] :: Quadshot : Collect"
Event.OngoingPlayer
if (HasSpawned())
if (!has_buff)
if (can_pickup_buff[7])
if (DistanceBetween(buff_pos[7], PositionOf() + Up()) < S_PICKUP_RAD)
if (IsAlive())
{
    b_index = 7;
    buff_color = Color.Orange;
    CollectBuff();

    // start in world cooldown
    quadshot_cd = S_QUADSHOT_CD;
    QuadshotCooldown();
}

rule: "[Buff] :: Quadshot : Remove"
Event.OngoingPlayer
if (quadshot_enabled)
if (quadshot_ammo <= 0)
{
    Wait(0.128);

    LogToInspector(<"Quadshot Disabled for <0>", buff_user[7]>);

    // destroy hud timer and player effect
    DestroyHudText(hud_txt[7]);
    DestroyEffect(collected_buff_effect[7]);

    quadshot_enabled = false;
    has_buff = false;
}

rule: "[Buff] :: Quadshot : Action"
Event.OngoingPlayer
if (quadshot_enabled)
if (IsFiringPrimary())
{
    quadshot_ammo--;

    vec[] quad_hp = [];
    player[] quad_hp_player = [];
    vec gun_pos = weapon_muzzle;
    any[] quad_beam = [];
    any center_beam;

    // center
    vec quadshotCenter = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);

    // upper left
    quad_hp[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(S_QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - S_QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // upper right
    quad_hp[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-S_QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - S_QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // lower left
    quad_hp[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(S_QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + S_QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // lower right
    quad_hp[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-S_QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + S_QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    ////////////
    // player //
    ////////////

    // upper left
    quad_hp_player[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(S_QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - S_QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // upper right
    quad_hp_player[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-S_QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - S_QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // lower left
    quad_hp_player[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(S_QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + S_QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // lower right
    quad_hp_player[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-S_QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + S_QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gun_pos, quadshotCenter, Color.Orange, EffectRev.None);
    center_beam = LastCreatedEntity();

    for (num p = 0; p < 4; p++)
    {
        Damage(quad_hp_player[p], player, 10000);

        PlayEffect(all, PlayEffect.GoodExplosion, Color.Orange, quad_hp[p], 0.2);

        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gun_pos, quad_hp[p], Color.Orange, EffectRev.None);
        quad_beam[p] = LastCreatedEntity();
    }

    PlayEffect(all, PlayEffect.GoodExplosion, Color.Orange, quadshotCenter, 0.2);

    Wait(0.25);
    DestroyEffect(center_beam);

    for (num b = 0; b < 4; b++)
    {
        DestroyEffect(quad_beam[b]);
    }
}

// ............########.##.......########..######..########.########...#######............
// ............##.......##.......##.......##....##....##....##.....##.##.....##...........
// ............##.......##.......##.......##..........##....##.....##.##.....##...........
// .#######....######...##.......######...##..........##....########..##.....##....#######
// ............##.......##.......##.......##..........##....##...##...##.....##...........
// ............##.......##.......##.......##....##....##....##....##..##.....##...........
// ............########.########.########..######.....##....##.....##..#######............
disabled rule: "---------------- Electro ----------------"{}

rule: "[Buff] :: Electro : Create Orb"
if (match_started)
if (valid_map)
if (s_spawn_electro)
if (electro_cd == 0)
{
    LogToInspector("Electro Orb Created");
    can_pickup_buff[5] = true;

    DestroyEffect(sphere_ip_effect[5]);

    CreateEffect(all, Effect.Orb, Color.SkyBlue, buff_pos[5], 2, EffectRev.None);
    buff_effect[5] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.SkyBlue, buff_pos[5], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Echo, Button.SecondaryFire), buff_pos[5] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buff_icon[5] = LastTextID();

    DestroyProgressBarInWorldText(cd_txt[5]);
    DestroyInWorldText(cd_txt[5]);

    electro_timer = false;
    StopChasingVariable(electro_pb);
}

rule: "[Buff] :: Electro : Collect"
Event.OngoingPlayer
if (HasSpawned())
if (!has_buff)
if (can_pickup_buff[5])
if (DistanceBetween(buff_pos[5], PositionOf() + Up()) < S_PICKUP_RAD)
if (IsAlive())
{
    b_index = 5;
    buff_color = Color.SkyBlue;
    CollectBuff();

    // start in world cooldown
    electro_cd = S_ELECTRO_CD;
    ElectroCooldown();
}

rule: "[Buff] :: Electro : Remove"
Event.OngoingPlayer
if (electro_enabled)
if (electro_ammo <= 0)
{
    Wait(0.128);

    LogToInspector(<"Electro Disabled for <0>", buff_user[5]>);

    // destroy hud timer and player effect
    DestroyHudText(hud_txt[5]);
    DestroyEffect(collected_buff_effect[5]);

    electro_enabled = false;
    has_buff = false;
}

rule: "[Buff] :: Electro : Action - Primary"
Event.OngoingPlayer
if (electro_enabled)
if (IsFiringPrimary())
{
    electro_ammo--;
    electro_hitpos = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);
    vec start_pos = EyePosition() + Facing() + weapon_muzzle;

    CreateBeamEffect(all, BeamType.BadBeam, start_pos, electro_hitpos, Color.SkyBlue, EffectRev.None);
    electro_effect = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodExplosion, Color.SkyBlue, electro_hitpos, S_ELECTRO_ESIZE);
    PlayEffect(all, PlayEffect.EchoStickyBombExplosionEffect, Color.Team1, electro_hitpos);

    player[] players = FilteredArray(RemoveFromArray(AllLivingPlayers(), player), DistanceBetween(Curr(), electro_hitpos) <= S_ELECTRO_ESIZE && IsInLineOfSight(electro_hitpos, Curr()));
    for (num i = 0; i < CountOf(players); i++)
    {
        Damage(players[i], player, 10000);
    }

    // set off all mines if one is shot
    if (mines_placed &&
        (DistanceBetween(electro_hitpos, electro_m_hitpos[0]) <= S_ELECTRO_ESIZE + 0.275 || 
         DistanceBetween(electro_hitpos, electro_m_hitpos[1]) <= S_ELECTRO_ESIZE + 0.275 || 
         DistanceBetween(electro_hitpos, electro_m_hitpos[2]) <= S_ELECTRO_ESIZE + 0.275))
    {
        ExplodeMine();
    }

    Wait(0.25);
    DestroyEffect(electro_effect);
}

rule: "[Buff] :: Electro : Action - Launch Sticky Mines"
Event.OngoingPlayer
if (electro_enabled)
if (!mines_placed)
if (IsButtonHeld(player, Button.Reload))
{
    mine_color = Color.Blue;

    // first mine //
    electro_ammo--;
    electro_m_hitpos[0] = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, null);
    PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 50);

    DestroyEffect(electro_m_effect[0][0]);
    DestroyEffect(electro_m_effect[0][1]);

    electro_eyepos1 = EyePosition();

    CreateEffect(all, Effect.Sphere, mine_color, electro_eyepos1, 0.20, EffectRev.PositionRadiusAndColor);
    electro_m_effect[0][0] = LastCreatedEntity();
    CreateEffect(all, Effect.EchoCloningEffect, Color.Team1, electro_eyepos1 + Vector(0, 0, -0.125), 0.275, EffectRev.PositionRadiusAndColor);
    electro_m_effect[0][1] = LastCreatedEntity();

    ChaseVariableAtRate(electro_eyepos1, electro_m_hitpos[0], S_ELECTRO_PSPEED, RateChaseReevaluation.DestinationAndRate);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Wait(0.2);

    // second mine //
    electro_ammo--;
    electro_m_hitpos[1] = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, null);
    PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 50);

    DestroyEffect(electro_m_effect[1][0]);
    DestroyEffect(electro_m_effect[1][1]);

    electro_eyepos2 = EyePosition();

    CreateEffect(all, Effect.Sphere, mine_color, electro_eyepos2, 0.20, EffectRev.PositionRadiusAndColor);
    electro_m_effect[1][0] = LastCreatedEntity();
    CreateEffect(all, Effect.EchoCloningEffect, Color.Team1, electro_eyepos2 + Vector(0, 0, -0.125), 0.275, EffectRev.PositionRadiusAndColor);
    electro_m_effect[1][1] = LastCreatedEntity();

    ChaseVariableAtRate(electro_eyepos2, electro_m_hitpos[1], S_ELECTRO_PSPEED, RateChaseReevaluation.DestinationAndRate);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Wait(0.2);

    // third mine //
    electro_ammo--;
    electro_m_hitpos[2] = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, null);
    PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 50);

    DestroyEffect(electro_m_effect[2][0]);
    DestroyEffect(electro_m_effect[2][1]);

    electro_eyepos3 = EyePosition();

    CreateEffect(all, Effect.Sphere, mine_color, electro_eyepos3, 0.20, EffectRev.PositionRadiusAndColor);
    electro_m_effect[2][0] = LastCreatedEntity();
    CreateEffect(all, Effect.EchoCloningEffect, Color.Team1, electro_eyepos3 + Vector(0, 0, -0.125), 0.275, EffectRev.PositionRadiusAndColor);
    electro_m_effect[2][1] = LastCreatedEntity();

    ChaseVariableAtRate(electro_eyepos3, electro_m_hitpos[2], S_ELECTRO_PSPEED, RateChaseReevaluation.DestinationAndRate);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    WaitUntil(DistanceBetween(electro_eyepos1, electro_m_hitpos[0]) < 0.1 && DistanceBetween(electro_eyepos2, electro_m_hitpos[1]) < 0.1 && DistanceBetween(electro_eyepos3, electro_m_hitpos[2]) < 0.1, 9999);
    mines_placed = true;
    mine_color = Color.SkyBlue;
}

void ExplodeMine() playervar "[Sub] :: Electro : Action - Explode Mines"
{
    mines_placed = false;

    player[] players = [];
    for (num i = 0; i < 3; i++)
    {
        players[i] = FilteredArray(RemoveFromArray(AllLivingPlayers(), player), IsInLineOfSight(Curr(), electro_m_hitpos[i]) && DistanceBetween(Curr(), electro_m_hitpos[i]) <= S_ELECTRO_MESIZE); // get players per mine
        for (num j = 0; j < CountOf(players[i]); j++)
        {
            Damage(players[i][j], player, 10000);
        }

        DestroyEffect(electro_m_effect[i][0]);
        DestroyEffect(electro_m_effect[i][1]);

        PlayEffect(all, PlayEffect.GoodExplosion, Color.SkyBlue, electro_m_hitpos[i], S_ELECTRO_MESIZE);
        PlayEffect(all, PlayEffect.EchoStickyBombExplosionEffect, Color.Team1, electro_m_hitpos[i]);
        PlayEffect(all, PlayEffect.ExplosionSound, Position: electro_m_hitpos[i], Radius: 50);

        electro_m_hitpos[i] = null;
    }

    mine_color = Color.Blue;
}

rule: "[Buff] :: Electro : Action - Mines Idle"
Event.OngoingPlayer
if (mines_placed)
{
    WaitIfTrue(S_ELECTRO_DELAY);
    ExplodeMine();
}

// ..######..########.....###....########..##....##
// .##....##.##.....##...##.##...##.....##.##...##.
// .##.......##.....##..##...##..##.....##.##..##..
// ..######..########..##.....##.########..#####...
// .......##.##........#########.##...##...##..##..
// .##....##.##........##.....##.##....##..##...##.
// ..######..##........##.....##.##.....##.##....##
disabled rule: "---------------- Spark ----------------"{}

rule: "[Buff] :: Spark : Create Orb"
if (match_started)
if (valid_map)
if (s_spawn_spark)
if (spark_cd == 0)
{
    LogToInspector("Spark Orb Created");
    can_pickup_buff[6] = true;

    DestroyEffect(sphere_ip_effect[6]);

    CreateEffect(all, Effect.Orb, Color.Purple, buff_pos[6], 2, EffectRev.None);
    buff_effect[6] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Purple, buff_pos[6], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Sigma, Button.Ability1), buff_pos[6] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buff_icon[6] = LastTextID();

    DestroyProgressBarInWorldText(cd_txt[6]);
    DestroyInWorldText(cd_txt[6]);

    spark_timer = false;
    StopChasingVariable(spark_pb);
}

rule: "[Buff] :: Spark : Collect"
Event.OngoingPlayer
if (HasSpawned())
if (!has_buff)
if (can_pickup_buff[6])
if (DistanceBetween(buff_pos[6], PositionOf() + Up()) < S_PICKUP_RAD)
if (IsAlive())
{
    b_index = 6;
    buff_color = Color.Purple;
    CollectBuff();

    // start in world cooldown
    spark_cd = S_SPARK_CD;
    SparkCooldown();
}

rule: "[Buff] :: Spark : Remove"
Event.OngoingPlayer
if (spark_enabled)
if (spark_ammo <= 0)
{
    Wait(0.128);

    LogToInspector(<"Spark Disabled for <0>", buff_user[6]>);

    // destroy hud timer and player effect
    DestroyHudText(hud_txt[6]);
    DestroyEffect(collected_buff_effect[6]);

    spark_enabled = false;
    has_buff = false;
}

rule: "[Buff] :: Spark : Action"
Event.OngoingPlayer
if (spark_enabled)
if (IsFiringPrimary())
{
    spark_ammo--;
}

// .########..########.########..##.....##..######..
// .##.....##.##.......##.....##.##.....##.##....##.
// .##.....##.##.......##.....##.##.....##.##.......
// .##.....##.######...########..##.....##.##...####
// .##.....##.##.......##.....##.##.....##.##....##.
// .##.....##.##.......##.....##.##.....##.##....##.
// .########..########.########...#######...######..

// rule: "[Debug] :: Kill"
//     Event.OngoingPlayer
//     if (player == host && IsInteractHeld())
//     {
//         Kill();
//     }

rule: "[Debug] :: Bots"
if (IsButtonHeld(host, Button.Interact) && !IsButtonHeld(host, Button.Crouch))
{
    CreateDummyBot(HeroOf(host), OppositeTeamOf(TeamOf(host)), -1, RayCastHitPosition(EyePosition(host), EyePosition(host) + Facing(host) * 100, null, null, true), Facing(host) * -1);
}
rule: "[Debug] :: Destroy Bots"
if (IsButtonHeld(host, Button.Crouch) && IsButtonHeld(host, Button.Interact))
{
    DestroyAllDummyBots();
}

// rule: "[Debug] :: Show OW Spawn Points"
// if (match_started)
// {
//     for (num i = 0; i < CountOf(SpawnPoints()); i++)
//     {
//         CreateEffect(all, Effect.Ring, Color.White, SpawnPoints()[i], 1, EffectRev.None);
//     }
// }

// rule: "[Debug] :: Bots Hold Left Click"
// Event.OngoingPlayer
// if (IsDummyBot())
// {
//     StartHoldingButton(player, Button.PrimaryFire);
// }

// rule: "[Debug] :: Walls"
// Event.OngoingPlayer
// if (DistanceBetween(player, host) < 20 && IsAlive())
// {
//     StartForcingPlayerOutlines(player != host ? player : null, host, true, Color.Orange, OutlineType.Always);
// }

// rule: "[Debug] :: Remove Walls"
// Event.OngoingPlayer
// if (DistanceBetween(player, host) > 20 || IsDead())
// {
//     StopForcingPlayerOutlines(player, host);
// }

// rule: "[Debug] :: Show start_pos"
// Event.OngoingPlayer
// {
//     vec start_pos;

//     CreateEffect(player, Effect.Sphere, Color.Aqua, start_pos, 0.05);

//     while (true)
//     {
//         start_pos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.675, 0), player) * 0.13;
//         MinWait();
//     }
// }