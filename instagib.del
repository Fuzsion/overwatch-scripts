//////////////////////////////////////////////////
//////////////////////////////////////////////////
///// this code is an absolute fucking mess. /////
////////////// please no judge <3 ////////////////
//////////////////////////////////////////////////
//////////////////////////////////////////////////


import "macros.del";
import "instagibSettings.json";

// bhop
playervar define bhopSpeed;
playervar define speedAccumInAir;
playervar define isChasing;

// primary
playervar define primaryHit;
playervar define primaryStartPos;
playervar define primaryBeam;

// secondary
playervar define secondaryHit;
playervar define secondaryEyePos;
playervar define secondaryOrb;
playervar define secondaryStartPos;

// grapple
playervar define grappleEyePos;
playervar define grappleBeamEffect;
playervar define usingGrapple;
playervar define grappleHit;
playervar define grappleHitSphere;
playervar define grapplePlayerBeamEffect;
playervar define grappleHitPlayer;
playervar define grappleHitPlayerSphere;

// misc
playervar define livingEnemies;

// constants :: bhop
globalvar define DEFAULT_START_SPEED;
globalvar define BHOP_MAX_SPEED;
globalvar define BHOP_SPEED_RATE;

// constants :: grapple
globalvar define GRAPPLE_PULL_SPEED;

// constants :: secondary
globalvar define SECONDARY_PROJECTILE_SPEED;

// constants: misc
globalvar define MATCH_TIME_LIMIT;

// toggle
globalvar define matchStarted;

// buffs
globalvar define buffsEnabled;
globalvar define buffsSpawnImmediately;
globalvar define validBuffMap;
globalvar define buffEffect;
globalvar define buffPos;
globalvar define buffIcon;
playervar define hudText;
globalvar define cdText;

// wallbang
globalvar define spawnWallbang;
globalvar define spawnWithWallbang;
globalvar define NUM_WALLBANGS;
playervar define wallbangEffect;
playervar define wallbangEnabled;
globalvar define wallbangCD;
globalvar define WALLBANG_CD;
playervar define wallbangDur;
globalvar define WALLBANG_DUR;

// extra life
globalvar define spawnLife;
globalvar define spawnWithLife;
globalvar define lifeCD;
globalvar define LIFE_CD;
playervar define extraLife;
playervar define extraLifeIcon;

// ricochet
globalvar define spawnBounce;
globalvar define spawnWithBounce;
globalvar define NUM_BOUNCES;
globalvar define bounceCD;
globalvar define BOUNCE_CD;
playervar define bounceEnabled;
playervar define bounceDur;
globalvar define BOUNCE_DUR;

// buckshot
globalvar define spawnBuckshot;
globalvar define spawnWithBuckshot;
globalvar define BUCKSHOT_SPREAD;
playervar define buckshotHitPos;
playervar define buckshotHitPlayer;
playervar define buckshotCenter;
globalvar define buckshotCD; 
globalvar define BUCKSHOT_CD;
playervar define buckshotEnabled;
playervar define buckshotDur;
globalvar define BUCKSHOT_DUR;
globalvar define spreadDiag;
globalvar define spreadHori;
globalvar define randomSpread;

/////////////////////////////////////////////////////////////////////////////////// TODO: ///////////////////////////////////////////////////////////////////////////////////
//  Buckshot Optimizations (+ Optimize Randomized Spread). Need a new method to calculate spread that doesn't fire 9 different raycasts at once, not sure if possible
//  Player is killed with buff they will drop that buff with the same remaining time when they die
//  Optimizations
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

rule: "[Main] :: Initial Global"
    {
        DisableInspectorRecording();
        DisableCompletion();
        DisableAnnouncer();

        CreateHudText(all, null, "ㅤInstagib: v1.6.1 | Created by scort#11221", "ㅤ           Share Code: APPPX", Location.Right, 0);

        cdText = [];
        buffEffect = [];
        buffPos = [];
        buffIcon = [];
        matchStarted = false;

        DEFAULT_START_SPEED = WorkshopSettingInteger("BHop", "Starting Speed (100)", 100, 25, 300);
        BHOP_MAX_SPEED = WorkshopSettingInteger("BHop", "Maximum Speed Possible From Hops (320)", 320, 25, 10000);
        BHOP_SPEED_RATE = WorkshopSettingReal("BHop", "Speed gain rate (12.5)", 12.5, 1, 100);

        buffsSpawnImmediately = WorkshopSettingToggle("Buff Spawns", "Buffs Spawn Immediately When Match Starts (Off)", false);
        buffsEnabled = WorkshopSettingToggle("Buff Spawns", "Spawn Buffs (On)", true);

        NUM_WALLBANGS = WorkshopSettingInteger("Wallbang Buff Settings", "Wallbang Amount (5)", 5, 2, 100);
        WALLBANG_CD = WorkshopSettingInteger("Wallbang Buff Settings", "Wallbang Orb Spawn Time (75)", 75, 1, 300);
        WALLBANG_DUR = WorkshopSettingInteger("Wallbang Buff Settings", "Wallbang Buff Duration (25)", 25, 1, 300);
        spawnWallbang = WorkshopSettingToggle("Wallbang Buff Settings", "Spawn Wallbang Orb (On)", true);
        spawnWithWallbang = WorkshopSettingToggle("Wallbang Buff Settings", "Spawn With Wallbang (Lasts Forever) (Off)", false);

        BOUNCE_CD = WorkshopSettingInteger("Ricochet Buff Settings", "Ricochet Orb Spawn Time (65)", 65, 1, 300);
        BOUNCE_DUR = WorkshopSettingInteger("Ricochet Buff Settings", "Ricochet Buff Duration (25)", 25, 1, 300);
        NUM_BOUNCES = WorkshopSettingInteger("Ricochet Buff Settings", "Ricochet Amount (4)", 4, 1, 64);
        spawnBounce = WorkshopSettingToggle("Ricochet Buff Settings", "Spawn Ricochet Orb (On)", true);
        spawnWithBounce = WorkshopSettingToggle("Ricochet Buff Settings", "Spawn With Ricochet (Lasts Forever) (Off)", false);

        LIFE_CD = WorkshopSettingInteger("Extra Life Buff Settings", "Extra Life Orb Spawn Time (120)", 120, 1, 400);
        spawnLife = WorkshopSettingToggle("Extra Life Buff Settings", "Spawn Extra Life Orb (On)", true);
        spawnWithLife = WorkshopSettingToggle("Extra Life Buff Settings", "Spawn With Extra Life (Off)", false);

        BUCKSHOT_CD = WorkshopSettingInteger("Buckshot Buff Settings", "Buckshot Orb Spawn Time (95)", 95, 1, 300);
        BUCKSHOT_DUR = WorkshopSettingInteger("Buckshot Buff Settings", "Buckshot Buff Duration (20)", 20, 1, 300);
        BUCKSHOT_SPREAD = WorkshopSettingReal("Buckshot Buff Settings", "Buckshot Spread (Lower is Tighter) (3.5)", 3.5, 0.1, 20);
        randomSpread = WorkshopSettingToggle("Buckshot Buff Settings", "Randomized Buckshot Spread (Off)", false);
        spawnBuckshot = WorkshopSettingToggle("Buckshot Buff Settings", "Spawn Buckshot Orb (On)", true);
        spawnWithBuckshot = WorkshopSettingToggle("Buckshot Buff Settings", "Spawn With Buckshot (Lasts Forever) (Off)", false);

        SECONDARY_PROJECTILE_SPEED = WorkshopSettingInteger("Secondary Fire", "Secondary Projectile Speed (110)", 110, 10, 500);
        // SECONDARY_RADIUS = WorkshopSettingReal("Secondary Fire", "Secondary Explosion Radius (4.5)", 4.5, 2, 10);

        MATCH_TIME_LIMIT = WorkshopSettingInteger("Misc", "Match Time (Minutes) (20)", 20, 1, 60) * 60;
        GRAPPLE_PULL_SPEED = WorkshopSettingReal("Misc", "Grapple Pull Speed (3.5)", 3.5, 1, 10);
    }

rule: "[Main] :: Initial Player Join"
    Event.OnPlayerJoin
    {
        hudText = [];
        spreeInWorld = [];
        spreeEffects = [];
    }

rule: "[Main] :: Start Match"
    if (!matchStarted && CountOf(AllLivingPlayers()) > 0 && !IsWaitingForPlayers())
    {
        SetMatchTime(10);
        Wait(10.5);
        SetMatchTime(MATCH_TIME_LIMIT);
        matchStarted = true;

        if (validBuffMap && !buffsSpawnImmediately && !IsWaitingForPlayers())
        {
                LifeCooldown();
                WallbangCooldown();
                BounceCooldown();
                BuckshotCooldown();
        }

        if (buffsEnabled)
        {
            if (!spawnWithWallbang && spawnWallbang)
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Baptiste, ButtonValue(Button.Ultimate))>, null, 
                wallbangCD != 0 ? <"<0>", RoundToInteger(wallbangCD, Rounding.Up)> : EntityExists(buffEffect[0]) ? <"<0>", IconString(Icon.Checkmark)> : "In-Use", 
                Location.Left, 1, Color.Yellow);
            
            if (!spawnWithBounce && spawnBounce)
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Winston, ButtonValue(Button.Ability1))>, null,
                bounceCD != 0 ? <"<0>", RoundToInteger(bounceCD, Rounding.Up)> : EntityExists(buffEffect[2]) ? <"<0>", IconString(Icon.Checkmark)> : "In-Use",
                Location.Left, 2, Color.Purple);

            if (!spawnWithBuckshot && spawnBuckshot)
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Ashe, ButtonValue(Button.Ability1))>, null,
                buckshotCD != 0 ? <"<0>", RoundToInteger(buckshotCD, Rounding.Up)> : EntityExists(buffEffect[3]) ? <"<0>", IconString(Icon.Checkmark)> : "In-Use",
                Location.Left, 3, Color.Green);

            if (!spawnWithLife && spawnLife)
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Mercy, ButtonValue(Button.Ability2))>, null,
                lifeCD != 0 ? <"<0>", RoundToInteger(lifeCD, Rounding.Up)> : EntityExists(buffEffect[2]) ? <"<0>", IconString(Icon.Checkmark)> : <"<0>", IconString(Icon.Checkmark)>,
                Location.Left, 4, Color.SkyBlue);
        }
    }

rule: "[Main] :: Player Spawned"
    Event.OngoingPlayer
    if (HasSpawned() && matchStarted)
    {
        SmallMessage(player, "Welcome!")
        Wait(3);
        SmallMessage(player, <"Holding down <0> will let you gain speed by bunny hopping", InputBindingString(ButtonValue(Button.Jump))>);
        Wait(3);
        SmallMessage(player, <"Press <0> to throw out a grappling hook to pull you towards a surface or to pull players towards you", InputBindingString(ButtonValue(Button.Ability2))>);
        Wait(3);
        SmallMessage(player, <"Press <0> to fire an orb that knocks players back, including yourself allowing for extra mobility", InputBindingString(ButtonValue(Button.SecondaryFire))>);
        Wait(3);
        SmallMessage(player, "Buffs are littered thorughout the map that give you special changes to your weapon");
        Wait(3);
        SmallMessage(player, "Happy Fragging!");
    }

rule: "[Main] :: End Game"
    if (matchStarted)
    {
        Wait(MATCH_TIME_LIMIT);
        EnableCompletion();
    }

rule: "[Main] :: Primary Effect"
    Event.OngoingPlayer
    if (!wallbangEnabled && !bounceEnabled && !buckshotEnabled && IsFiringPrimary())
    {
        primaryBeam = [];
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
        primaryStartPos = WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        primaryHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, livingEnemies, player);
        
        // PlayEffect(player, PlayEffect.GoodExplosion, Color.Aqua, EyePosition() + Facing() + primaryStartPos, 0.2);
        PlayEffect(player, PlayEffect.GoodExplosion, Color.Aqua, primaryHit, 0.2);
        // PlayEffect(RemoveFromArray(EnemyPlayers(), player), PlayEffect.GoodExplosion, Color.Red, EyePosition() + Facing() + primaryStartPos, 0.2);
        PlayEffect(RemoveFromArray(EnemyPlayers(), player), PlayEffect.GoodExplosion, Color.Red, primaryHit, 0.2);
        CreateBeamEffect(player, BeamType.BadBeam, EyePosition() + Facing() + primaryStartPos, primaryHit, Color.Aqua, EffectRev.None);
        primaryBeam[0] = LastCreatedEntity();
        CreateBeamEffect(RemoveFromArray(EnemyPlayers(), player), BeamType.BadBeam, EyePosition() + Facing() + primaryStartPos, primaryHit, Color.Red, EffectRev.None);
        primaryBeam[1] = LastCreatedEntity();

        Wait(0.15);
        DestroyEffect(primaryBeam[0]);
        DestroyEffect(primaryBeam[1]);
    }

disabled rule: "---------------- Killing Spree Notifs ----------------"{}

/* 
Sprees:
Killing Spree!
Rampage
Dominating
Unstoppable
Godlike
Wicked Sick 
*/

/* 
Multi Kills (todo):
Double Kill
Triple Kill
Multi Kill
Mega Kill
Ultra Kill
M-M-M-Monster Kill
Ludicrous Kill
*/

playervar define lifeKills;
playervar define spreeInWorld;
playervar define spreeEffects;
rule: "[Killspree] :: Record Kills While Alive"
    Event.OnFinalBlow
    {
        lifeKills++;
    }

rule: "[Killspree] :: Reset Kills on death"
    Event.OnDeath
    {
        if (lifeKills > 5)
        {
            BigMessage(all, !EventWasEnvironment() ? <"<0>'s <1> player spree was put to an end by <2>!", Victim(), lifeKills, Attacker()> : 
                                                       <"<0>'s <1> player spree was put to an end by the world!", Victim(), lifeKills>);
        }

        for (define i = 0; i < 7; i++)
        {
            DestroyEffect(spreeEffects[i]);
        }

        Wait(0.032);
        lifeKills = 0;
        spreeInWorld = [];
        spreeEffects = [];
    }

rule: "[Killspree] :: 5 Kills"
    Event.OnFinalBlow
    if (lifeKills == 5)
    {
        BigMessage(all, <"<0> is on a Killing Spree!", player>);
        CreateInWorldText(player, "Killing Spree!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.White);
        spreeInWorld[0] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.White, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[0] = LastCreatedEntity();
        Wait(2);
        DestroyInWorldText(spreeInWorld[0]);
    }

rule: "[Killspree] :: 8 Kills"
    Event.OnFinalBlow
    if (lifeKills == 8)
    {
        DestroyEffect(spreeEffects[0]);
        BigMessage(all, <"<0> is on a Rampage!", player>);
        CreateInWorldText(player, "Rampage!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.LimeGreen);
        spreeInWorld[1] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.LimeGreen, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[1] = LastCreatedEntity();
        Wait(2);
        DestroyInWorldText(spreeInWorld[1]);
    }

rule: "[Killspree] :: 11 Kills"
    Event.OnFinalBlow
    if (lifeKills == 11)
    {
        DestroyEffect(spreeEffects[1]);
        BigMessage(all, <"<0> is Dominating!", player>);
        CreateInWorldText(player, "Dominating!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Blue);
        spreeInWorld[2] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Blue, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[2] = LastCreatedEntity();
        Wait(2);
        DestroyInWorldText(spreeInWorld[2]);
    }

rule: "[Killspree] :: 14 Kills"
    Event.OnFinalBlow
    if (lifeKills == 14)
    {
        DestroyEffect(spreeEffects[2]);
        BigMessage(all, <"<0> is Unstoppable!", player>);
        CreateInWorldText(player, "Unstoppable!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Purple);
        spreeInWorld[3] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Purple, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[3] = LastCreatedEntity();
        Wait(2);
        DestroyInWorldText(spreeInWorld[3]);
    }

rule: "[Killspree] :: 17 Kills"
    Event.OnFinalBlow
    if (lifeKills == 17)
    {
        DestroyEffect(spreeEffects[3]);
        BigMessage(all, <"<0> is Godlike!", player>);
        CreateInWorldText(player, "Godlike!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Yellow);
        spreeInWorld[4] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Yellow, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[4] = LastCreatedEntity();
        Wait(2);
        DestroyInWorldText(spreeInWorld[4]);
    }

rule: "[Killspree] :: 21 Kills"
    Event.OnFinalBlow
    if (lifeKills == 21)
    {
        DestroyEffect(spreeEffects[4]);
        BigMessage(all, <"<0> is Divine!", player>);
        CreateInWorldText(player, "Divine!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Orange);
        spreeInWorld[5] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Orange, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[5] = LastCreatedEntity();
        Wait(2);
        DestroyInWorldText(spreeInWorld[5]);
    }

rule: "[Killspree] :: 24 Kills"
    Event.OnFinalBlow
    if (lifeKills == 24)
    {
        DestroyEffect(spreeEffects[5]);
        BigMessage(all, <"<0> is Empyreal!", player>);
        CreateInWorldText(player, "Empyreal!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Red);
        spreeInWorld[6] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Red, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[6] = LastCreatedEntity();
        Wait(2);
        DestroyInWorldText(spreeInWorld[6]);
    }

disabled rule: "---------------- Bhop ----------------"{}
rule: "[Bhop] :: Auto Hop"
    Event.OngoingPlayer
    if (IsOnGround() && IsJumpHeld())
    {
        DisableJump();
        MinWait();
        AllowJump();
    }

rule: "[Bhop] :: Starting Speed"
    Event.OngoingPlayer
    {
        bhopSpeed = DEFAULT_START_SPEED;
    }

rule: "[Bhop] :: If Airborne"
    Event.OngoingPlayer
    if ((!usingGrapple && IsJumping() && HorizontalSpeedOf() > DEFAULT_START_SPEED / 33.33) || (usingGrapple && IsInAir() && DistanceBetween(grappleEyePos, grappleHit) < 40))
    {
        speedAccumInAir = HorizontalSpeedOf();
        Wait(0.05);
        ChaseVariableAtRate(bhopSpeed, BHOP_MAX_SPEED, BHOP_SPEED_RATE, RateChaseReevaluation.DestinationAndRate);

        isChasing = true;
    }

rule: "[Bhop] :: Update Speed"
    Event.OngoingPlayer
    if (isChasing)
    {
        speedAccumInAir = HorizontalSpeedOf();
        SetMoveSpeed(player, bhopSpeed);
        Wait(0.032);
        LoopIfConditionIsTrue();
    }

rule: "[Bhop] :: Update isChasing"
    Event.OngoingPlayer
    if (isChasing && bhopSpeed == BHOP_MAX_SPEED || bhopSpeed == DEFAULT_START_SPEED)
    {
        StopChasingVariable(bhopSpeed);
        isChasing = false;
    }

rule: "[Bhop] :: Reset speed if turning too fast"
    Event.OngoingPlayer
    if (HorizontalSpeedOf() < speedAccumInAir - 0.45)
    {
        StopChasingVariable(bhopSpeed);
        isChasing = false;
        bhopSpeed = DEFAULT_START_SPEED;
        SetMoveSpeed(player, bhopSpeed);
    }

rule: "[Bhop] :: Stop chasing if too slow"
    Event.OngoingPlayer
    if (!usingGrapple && isChasing && HorizontalSpeedOf() <= DEFAULT_START_SPEED / 66.66)
    {
        StopChasingVariable(bhopSpeed);
        isChasing = false;
        bhopSpeed = DEFAULT_START_SPEED;
        SetMoveSpeed(player, bhopSpeed);
        Wait(0.032);
        LoopIfConditionIsTrue();
    }

rule: "[Bhop] :: Stop if player is on ground"
    Event.OngoingPlayer
    if ((IsOnGround() && !usingGrapple) && (bhopSpeed > DEFAULT_START_SPEED))
    {
        WaitIfTrue(0.2);
        StopChasingVariable(bhopSpeed);
        bhopSpeed = DEFAULT_START_SPEED;
        // ChaseVariableAtRate(bhopSpeed, DEFAULT_START_SPEED, 325, RateChaseReevaluation.DestinationAndRate);
        // isChasing = true;
        SetMoveSpeed(player, bhopSpeed);
    }

disabled rule: "---------------- Secondary Fire ----------------"{}

rule: "[Secondary Fire] :: Projectile"
    Event.OngoingPlayer
    if (matchStarted && IsSecondaryHeld() && IsAlive())
    {
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
        // secondaryStartPos = WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        secondaryHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, livingEnemies, player);
        secondaryEyePos = EyePosition()/*  + secondaryStartPos */;
        DestroyEffect(secondaryOrb);
        PlayEffect(all, PlayEffect.RingExplosionSound, Color.White, player, 50);
        // PlayEffect(all, PlayEffect.GoodExplosion, Color.Red, EyePosition() + Facing() + secondaryStartPos, 0.2);

        // projectile
        CreateEffect(all, Effect.Orb, Color.Red, secondaryEyePos, 0.1);
        secondaryOrb = LastCreatedEntity();
        ChaseVariableAtRate(secondaryEyePos, secondaryHit, SECONDARY_PROJECTILE_SPEED, RateChaseReevaluation.DestinationAndRate);

        Wait(0.5);
    }

rule: "[Secondary Fire] :: Impulse"
    Event.OngoingPlayer
    if (DistanceBetween(secondaryEyePos, secondaryHit) < 0.1 || RayCastHitPlayer(EyePosition(), secondaryEyePos, AllLivingPlayers(), player) != null)
    {
        StopChasingVariable(secondaryEyePos);
        define players = FilteredArray(AllLivingPlayers(), DistanceBetween(Curr(), secondaryEyePos) <= 4.5);
        for (define loop = 0; CountOf(players); 1)
        {
            ApplyImpulse(players[loop], DirectionTowards(secondaryEyePos, players[loop] + Vector(0, YOf(EyePosition(players[loop])- players[loop]) / 2, 0) + Up()), 15, Relative.ToWorld, ContraryMotion.Incorporate);
        }
        
        // projectile hit wallbangEffect
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Red, secondaryHit, 2.5);
        // PlayEffect(VisibleTo: all, Type: PlayEffect.RingExplosionSound, Position: player, Radius: 15);
        DestroyEffect(secondaryOrb);
    }

disabled rule: "---------------- Grapple ----------------"{}
rule: "[Grapple] :: Grapple Start"
    Event.OngoingPlayer
    if (matchStarted && IsAbility2Held() && IsAlive())
    {
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
        grappleHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 40, livingEnemies, player);
        grappleHitPlayer = RayCastHitPlayer(EyePosition(), EyePosition() + Facing() * 40, livingEnemies, player, true);
        grappleEyePos = EyePosition();

        if (grappleHitPlayer)
        {
            CreateBeamEffect(all, BeamType.GrappleBeam, player, grappleHitPlayer, Color.Yellow, EffectRev.VisibleToPositionAndRadius);
            grappleBeamEffect = LastCreatedEntity();
            
            CreateEffect(all, Effect.Sphere, Color.Yellow, grappleHitPlayer, 0.2);
            grappleHitPlayerSphere = LastCreatedEntity();
        }
        else 
        {
            CreateBeamEffect(all, BeamType.GrappleBeam, player, grappleHit, Color.Yellow, EffectRev.VisibleToPositionAndRadius);
            grappleBeamEffect = LastCreatedEntity();
            
            CreateEffect(all, Effect.Sphere, Color.Yellow, grappleHit, 0.2);
            grappleHitSphere = LastCreatedEntity();
        }

        PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, player, 0.33);
        PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 100);
        PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, grappleHit, 0.2);
        PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, grappleHit, 50);

        usingGrapple = true;

        if (DistanceBetween(grappleEyePos, grappleHit) == 40)
        {
            Wait(0.25);
            usingGrapple = false;
            DestroyEffect(grappleBeamEffect);
            DestroyEffect(grapplePlayerBeamEffect);
            DestroyEffect(grappleHitSphere);
            DestroyEffect(grappleHitPlayerSphere);
        }

        Wait(0.5);
    }

rule: "[Grapple] :: Pull"
    Event.OngoingPlayer
    if (usingGrapple && DistanceBetween(grappleEyePos, grappleHit) < 40)
    {
        ForceThrottle(player, 0, 0.05, 0, 0.05, 0, 0.05);

        if (grappleHitPlayer && IsAlive(grappleHitPlayer))
            ApplyImpulse(grappleHitPlayer, Vector(0, 0.3, 0) + DirectionTowards(grappleHitPlayer, EyePosition()), GRAPPLE_PULL_SPEED / 1.25, Relative.ToWorld, ContraryMotion.Incorporate);
        else
        {
            if (IsJumpHeld())
                ApplyImpulse(player, Vector(0, 0.3, 0) + DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);
            else
                ApplyImpulse(player, DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);
        }

        Wait(0.064);
        LoopIfConditionIsTrue();
    }

rule: "[Grapple] :: Grapple End"
    Event.OngoingPlayer
    if ((!IsAbility2Held() || IsDead() || IsDead(grappleHitPlayer)) || (!IsInLineOfSight(player, grappleHitPlayer) || !IsInViewAngle(player, grappleHitPlayer, 105)))
    {
        usingGrapple = false;
    }

rule: "[Grapple] :: Destroy Effects"
    Event.OngoingPlayer
    if (!usingGrapple)
    {
        DestroyEffect(grappleBeamEffect);
        DestroyEffect(grapplePlayerBeamEffect);
        DestroyEffect(grappleHitSphere);
        DestroyEffect(grappleHitPlayerSphere);
        StopForcingThrottle();
    }

disabled rule: "---------------- Buff ----------------"{}

void WallbangCooldown() globalvar "[Sub] :: Wallbang Cooldown"
    {
        if (!spawnWithWallbang && spawnWallbang)
        {
            wallbangCD = WALLBANG_CD;
            ChaseVariableAtRate(wallbangCD, 0, 1, RateChaseReevaluation.None);
            CreateInWorldText(all, <"<0>", RoundToInteger(wallbangCD, Rounding.Up)>, buffPos[0], 2, Clipping.ClipAgainstSurfaces);
            cdText[0] = LastTextID();
        }
    }

void LifeCooldown() globalvar "[Sub] :: Life Cooldown"
    {
        if (!spawnWithLife && spawnLife)
        {
            lifeCD = LIFE_CD;
            ChaseVariableAtRate(lifeCD, 0, 1, RateChaseReevaluation.None);
            CreateInWorldText(all, <"<0>", RoundToInteger(lifeCD, Rounding.Up)>, buffPos[1], 2, Clipping.ClipAgainstSurfaces);
            cdText[1] = LastTextID();
        }
    }

void BounceCooldown() globalvar "[Sub] :: Bounce Cooldown"
    {
        if (!spawnWithBounce && spawnBounce)
        {
            bounceCD = BOUNCE_CD;
            ChaseVariableAtRate(bounceCD, 0, 1, RateChaseReevaluation.None);
            CreateInWorldText(all, <"<0>", RoundToInteger(bounceCD, Rounding.Up)>, buffPos[2], 2, Clipping.ClipAgainstSurfaces);
            cdText[2] = LastTextID();
        }
    }

void BuckshotCooldown() globalvar "[Sub] :: Buckshot Cooldown"
    {
        if (!spawnWithBuckshot && spawnBuckshot)
        {
            buckshotCD = BUCKSHOT_CD;
            ChaseVariableAtRate(buckshotCD, 0, 1, RateChaseReevaluation.None);
            CreateInWorldText(all, <"<0>", RoundToInteger(buckshotCD, Rounding.Up)>, buffPos[3], 2, Clipping.ClipAgainstSurfaces);
            cdText[3] = LastTextID();
        }
    }

rule: "[Buff] :: Locations Switch"
    {
        /*
        [0]: wallbang
        [1]: extra 'life'
        [2]: bullet bouncy bouncy go go
        [3]: buckshot
        */

        # i do not recommend opening the large action in-game
        validBuffMap = false;
        switch (true)
        {
            case (buffsEnabled && CurrentMap() == Map.Workshop_Chamber || CurrentMap() == Map.Workshop_Expanse || CurrentMap() == Map.Workshop_Expanse_Night || CurrentMap() == Map.Workshop_Island || CurrentMap() == Map.Workshop_Island_Night):
                validBuffMap = true;
                buffPos[0] = Vector(0, 1, 2);
                buffPos[1] = Vector(0, 1, 6);
                buffPos[2] = Vector(0, 1, -2);
                buffPos[3] = Vector(0, 1, -6);
                break;
            case (buffsEnabled && CurrentMap() == Map.Blizzard_World || CurrentMap() == Map.Blizzard_World_Winter):
                validBuffMap = true;
                buffPos[0] = Vector(-32.50, 0.61, 73.15);
                buffPos[1] = Vector(-67.55, 1.75, 138.74);
                buffPos[2] = Vector(-77.28, 5.88, 66.15);
                buffPos[3] = Vector(-54.50, 0.61, 110.20);
                break;
            case (buffsEnabled && CurrentMap() == Map.Chateau_Guillard || CurrentMap() == Map.Chateau_Guillard_Halloween):
                validBuffMap = true;
                buffPos[0] = Vector(206.21, 16.50, 87.00);
                buffPos[1] = Vector(196.35, 17.50, 47.06);
                buffPos[2] = Vector(206.15, 1, 77.42);
                buffPos[3] = Vector(180.60, 10, 101.93);
                break;
            case (buffsEnabled && CurrentMap() == Map.Dorado):
                validBuffMap = true;
                buffPos[0] = Vector(102.46, 12.01, 9.68);
                buffPos[1] = Vector(128.33, 10.02, -23.86);
                buffPos[2] = Vector(64.44, 15.01, 25.15);
                buffPos[3] = Vector(114.30, 12, 44.92);
                break;
            case (buffsEnabled && CurrentMap() == Map.Ecopoint_Antarctica || CurrentMap() == Map.Ecopoint_Antarctica_Winter):
                validBuffMap = true;
                buffPos[0] = Vector(1.66, 12.63, -25.00);
                buffPos[1] = Vector(29.60, 4.00, 0.00);
                buffPos[2] = Vector(-32.27, 10.00, 0.00);
                buffPos[3] = Vector(1.66, 12.63, 25.00);
                break;
            case (buffsEnabled && CurrentMap() == Map.Eichenwalde || CurrentMap() == Map.Eichenwalde_Halloween):
                validBuffMap = true;
                buffPos[0] = Vector(55.70, 22.00, -67.84);
                buffPos[1] = Vector(103.96, 13.72, -109.47);
                buffPos[2] = Vector(58.33, 5.72, -90.39);
                buffPos[3] = Vector(54.74, 11.72, -121.02);
                break;
            case (buffsEnabled && CurrentMap() == Map.Hollywood || CurrentMap() == Map.Hollywood_Halloween):
                validBuffMap = true;
                buffPos[0] = Vector(-11.91, 2.73, -74.64);
                buffPos[1] = Vector(7.87, 13.90, -48.38);
                buffPos[2] = Vector(-4.09, 2.60, -15.87);
                buffPos[3] = Vector(20.67, 2.60, -51.82);
                break;
            case (buffsEnabled && CurrentMap() == Map.Kings_Row || CurrentMap() == Map.Kings_Row_Winter):
                validBuffMap = true;
                buffPos[0] = Vector(-49.46, 1.00, 2.69);
                buffPos[1] = Vector(-69.64, 1.50, -35.48);
                buffPos[2] = Vector(-31.19, 10.00, -13.40);
                buffPos[3] = Vector(-93.67, 8.50, -29.38);
                break;
            case (buffsEnabled && CurrentMap() == Map.Lijiang_Control_Center || CurrentMap() == Map.Lijiang_Control_Center_Lunar):
                validBuffMap = true;
                buffPos[0] = Vector(-33.50, 268.00, 323.00);
                buffPos[1] = Vector(0.00, 271.00, 267.50);
                buffPos[2] = Vector(0.00, 271.00, 323.00);
                buffPos[3] = Vector(33.50, 268.00, 323.00);
                break;
            case (buffsEnabled && CurrentMap() == Map.Necropolis):
                validBuffMap = true;
                buffPos[0] = Vector(0.00, -5.00, 0.00);
                buffPos[1] = Vector(1.06, 4.00, 23.07);
                buffPos[2] = Vector(-29.50, 3, 0);
                buffPos[3] = Vector(1.06, 4.00, -23.07);
                break;
            case (buffsEnabled && CurrentMap() == Map.Paris):
                validBuffMap = true;
                buffPos[0] = Vector(-104.00, 16.00, -100.00);
                buffPos[1] = Vector(-73.39, 11.02, -38.23);
                buffPos[2] = Vector(-109.18, 11.00, -60.60);
                buffPos[3] = Vector(-57.19, 14.00, -82.00);
                break;
            case (buffsEnabled && CurrentMap() == Map.Havana):
                validBuffMap = true;
                buffPos[0] = Vector(0.00, 7.00, -79.23);
                buffPos[1] = Vector(64.50, 13.00, -83.33);
                buffPos[2] = Vector(32.09, 5.00, -97.45);
                buffPos[3] = Vector(64.20, 5.00, -65.68);
                break;
            case (buffsEnabled && CurrentMap() == Map.Castillo):
                validBuffMap = true;
                buffPos[0] = Vector(-106.18, 40.56, 43.20);
                buffPos[1] = Vector(-74.82, 33.00, 52.93);
                buffPos[2] = Vector(-128.20, 35.38, 63.40);
                buffPos[3] = Vector(-100.35, 40.56, 73.75);
                break;
            case (buffsEnabled && CurrentMap() == Map.Black_Forest || CurrentMap() == Map.Black_Forest_Winter):
                validBuffMap = true;
                buffPos[0] = Vector(16.79, 12.44, 29.48);
                buffPos[1] = Vector(-25.49, 13.09, 5.00);
                buffPos[2] = Vector(4.66, 18.28, 5.00);
                buffPos[3] = Vector(16.18, 12.36, -20.11);
                break;
        }
    }

rule: "[Buff] :: Wallbang : Create Orb"
    if (validBuffMap && !spawnWithWallbang && spawnWallbang && wallbangCD == 0 && (matchStarted || buffsSpawnImmediately))
    {
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Yellow, buffPos[0], 1);
        CreateEffect(all, Effect.Orb, Color.Yellow, buffPos[0], 2);
        buffEffect[0] = LastCreatedEntity();
        CreateInWorldText(all, AbilityIconString(Hero.Baptiste, ButtonValue(Button.Ultimate)), buffPos[0], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[0] = LastTextID();
        DestroyInWorldText(cdText[0]);
    }


rule: "[Buff] :: Wallbang : Collect"
    Event.OngoingPlayer
    if ((matchStarted && EntityExists(buffEffect[0]) && DistanceBetween(buffPos[0], player) < 2.5 && HasSpawned() && IsAlive()) || spawnWithWallbang)
    {
        define wallbangBuffEffect;
        wallbangEnabled = true;

        if (!spawnWithWallbang)
        {
            // destroy inworld text / icon / orb
            DestroyInWorldText(cdText[0]);
            DestroyInWorldText(buffIcon[0]);
            DestroyEffect(buffEffect[0]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Yellow, buffPos[0], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Yellow, buffPos[0], 200);

            // start timer in hud
            wallbangDur = WALLBANG_DUR;
            ChaseVariableAtRate(wallbangDur, 0, 1, RateChaseReevaluation.None)

            // toasts
            CreateHudText(player, null, null, <"<1> Wallbang: <0> <1>", RoundToInteger(wallbangDur, Rounding.Up), AbilityIconString(Hero.Baptiste, ButtonValue(Button.Ultimate))>, Location.Top, 2);
            hudText[0] = LastTextID();
            SmallMessage(player, "Your bullets go through walls!");
            BigMessage(player, "Wallbang");

            // create effect
            CreateEffect(all, Effect.GoodAura, Color.Yellow, player, 0.75, EffectRev.VisibleToPositionAndRadius);
            wallbangBuffEffect = LastCreatedEntity();

            // sound when buff is about to run out
            Wait(WALLBANG_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
                Wait(1);
            }

            // destroy hud timer and player effect
            DestroyHudText(hudText[0]);
            DestroyEffect(wallbangBuffEffect);

            wallbangEnabled = false;

            // start in world cooldown
            WallbangCooldown(); 
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Wallbang: Forever <0>", AbilityIconString(Hero.Baptiste, ButtonValue(Button.Ultimate))>, Location.Top, 2);
            hudText[0] = LastTextID();
        }
    }

rule: "[Buff] :: Wallbang : Action"
    Event.OngoingPlayer
    if (wallbangEnabled && IsFiringPrimary())
    {
        define gunPos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        define wallbangHitPos = EyePosition();

        define wallbangLivingEnemies;
        define wallbangHitPlayer;

        for (define wallbangCount = 0; DistanceBetween(gunPos, wallbangHitPos) < 100 && wallbangCount < NUM_WALLBANGS; wallbangCount++)
        {
            wallbangLivingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
            wallbangHitPos = RayCastHitPosition(wallbangHitPos + Facing(), wallbangHitPos + Facing() * (100 - DistanceBetween(gunPos, wallbangHitPos)), wallbangLivingEnemies, player, true);
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, wallbangHitPos, 0.2);
            wallbangHitPlayer = RayCastHitPlayer(wallbangHitPos, wallbangHitPos + Facing() * (100 - DistanceBetween(gunPos, wallbangHitPos)), wallbangLivingEnemies, player, true);
            if (wallbangHitPlayer != null && wallbangHitPlayer != player)
            {
                Damage(wallbangHitPlayer, player, 10000);
            }
        }

        CreateBeamEffect(all, BeamType.BadBeam, gunPos, wallbangHitPos, Color.Yellow, EffectRev.None);
        wallbangEffect[0] = LastCreatedEntity();
        // PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, gunPos, 0.2);

        Wait(0.25);
        DestroyEffect(wallbangEffect[0]);
    }

rule: "[Buff] :: Extra Life : Create Orb"
    if (validBuffMap && !spawnWithLife && spawnLife && lifeCD == 0 && (matchStarted || buffsSpawnImmediately))
    {
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.SkyBlue, buffPos[1], 1);
        CreateEffect(all, Effect.Orb, Color.SkyBlue, buffPos[1], 2);
        buffEffect[1] = LastCreatedEntity();
        CreateInWorldText(all, AbilityIconString(Hero.Mercy, ButtonValue(Button.Ability2)), buffPos[1], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[1] = LastTextID();
        DestroyInWorldText(cdText[1]);
    }

rule: "[Buff] :: Extra Life : Collect"
    Event.OngoingPlayer
    if ((matchStarted && !extraLife && EntityExists(buffEffect[1]) && DistanceBetween(buffPos[1], player) < 2.5 && HasSpawned() && IsAlive()) || (spawnWithLife && IsAlive()))
    {
        extraLife = true;
        SetStatus(player, null, Status.Unkillable, 10000);

        if (!spawnWithLife)
        {
            // destroy inworld text / icon / orb
            DestroyInWorldText(cdText[1]);
            DestroyInWorldText(buffIcon[1]); 
            DestroyEffect(buffEffect[1]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.SkyBlue, buffPos[1], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.SkyBlue, buffPos[1], 200);

            // toasts
            SmallMessage(player, "Extra life");
            BigMessage(player, "Extra Life");

            // start in world cooldown
            LifeCooldown();
        }

        // hud text
        CreateHudText(player, null, null, <"<0> Extra Life <0>", AbilityIconString(Hero.Mercy, ButtonValue(Button.Ability2))>, Location.Top, 2);
        hudText[1] = LastTextID();

        // create icon above player
        CreateInWorldText(all, AbilityIconString(Hero.Mercy, ButtonValue(Button.Ability2)), player, 0.75, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString);
        extraLifeIcon = LastTextID();
    }

rule: "[Buff] :: Extra Life : Remove"
    Event.OngoingPlayer
    if (extraLife && (Health() == 1 || (IsDead() && !spawnWithLife)))
    {
        extraLife = false;
        ClearStatus(player, Status.Unkillable);
        SmallMessage(player, "Extra life used");
        PlayEffect(player, PlayEffect.DebuffImpactSound, Color.White, player, 200);
        DestroyInWorldText(extraLifeIcon);
        DestroyHudText(hudText[1]);

        Wait(0.5);
        SetPlayerHealth(player, MaxHealth());
    }

rule: "[Buff] :: Ricochet : Create Orb"
    if (validBuffMap && !spawnWithBounce && spawnBounce && bounceCD == 0 && (matchStarted || buffsSpawnImmediately))
    {
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Purple, buffPos[2], 1);
        CreateEffect(all, Effect.Orb, Color.Purple, buffPos[2], 2);
        buffEffect[2] = LastCreatedEntity();
        CreateInWorldText(all, AbilityIconString(Hero.Winston, ButtonValue(Button.Ability1)), buffPos[2], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[2] = LastTextID();
        DestroyInWorldText(cdText[2]);
    }

rule: "[Buff] :: Ricochet : Collect"
    Event.OngoingPlayer
    if ((matchStarted && EntityExists(buffEffect[2]) && DistanceBetween(buffPos[2], player) < 2.5 && HasSpawned() && IsAlive()) || spawnWithBounce)
    {
        define bounceBuffEffect;
        bounceEnabled = true;

        if (!spawnWithBounce)
        {
            // destroy inworld text / icon / orb
            DestroyInWorldText(cdText[2]);
            DestroyInWorldText(buffIcon[2]);
            DestroyEffect(buffEffect[2]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Purple, buffPos[2], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Purple, buffPos[2], 200);

            // start timer in hud
            bounceDur = BOUNCE_DUR;
            ChaseVariableAtRate(bounceDur, 0, 1, RateChaseReevaluation.None)

            // toasts
            CreateHudText(player, null, null, <"<1> Ricochet Bullets: <0> <1>", RoundToInteger(bounceDur, Rounding.Up), AbilityIconString(Hero.Winston, ButtonValue(Button.Ability1))>, Location.Top, 2);
            hudText[2] = LastTextID();
            SmallMessage(player, "Your bullets ricochet off walls!");
            BigMessage(player, "Ricochet Bullets");

            // create effect
            CreateEffect(all, Effect.GoodAura, Color.Purple, player, 0.75, EffectRev.VisibleToPositionAndRadius);
            bounceBuffEffect = LastCreatedEntity();

            // sound when buff is about to run out
            Wait(BOUNCE_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
                Wait(1);
            }

            // destroy hud timer and player effect
            DestroyHudText(hudText[2]);
            DestroyEffect(bounceBuffEffect);

            bounceEnabled = false;

            // start in world cooldown
            BounceCooldown();
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Ricochet Bullets: Forever <0>", AbilityIconString(Hero.Winston, ButtonValue(Button.Ability1))>, Location.Top, 2);
            hudText[2] = LastTextID();
        }
    }

playervar define normals;
playervar define hitPos;
playervar define hitPosPlayer;
playervar define ricochets;
playervar define hitPosBounces;
playervar define hitPosPlayerBounces;

playervar define eyePos;
playervar define facing;

// playervar define bounceEffects;
// playervar define bounceEffect;
rule: "[Buff] :: Ricochet : Action"
    Event.OngoingPlayer
    if (bounceEnabled && IsFiringPrimary())
    {
        # https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector
        normals = [];
        hitPos = [];
        hitPosPlayer = [];
        ricochets = [];
        hitPosBounces = [];
        hitPosPlayerBounces = [];
        define bounceEffects = [];
        define bounceEffect = [];

        for (define loop = 0; loop < NUM_BOUNCES; loop++)
        {
            if (loop > 0)
            {
                eyePos = hitPos[loop - 1];
                facing = ricochets[loop - 1];
            }
            else
            {
                eyePos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
                facing = Facing();
            }

            normals[loop] = RayCastHitNormal(eyePos, eyePos + facing * 100, all, player, true);
            hitPos[loop] = RayCastHitPosition(eyePos, eyePos + facing * 100, all, player, true);
            hitPosPlayer[loop] = RayCastHitPlayer(eyePos, eyePos + facing * 100, all, player, true);
            ricochets[loop] = facing - (2 * (normals[loop] * DotProduct(facing, normals[loop])));
            hitPosBounces[loop] = RayCastHitPosition(hitPos[loop], hitPos[loop] + ricochets[loop] * 100, AllLivingPlayers(), player, true);
            hitPosPlayerBounces[loop] = RayCastHitPlayer(hitPos[loop], hitPos[loop] + ricochets[loop] * 100, AllLivingPlayers(), player, true);

            CreateBeamEffect(all, BeamType.BadBeam, eyePos, hitPos[loop], Color.Purple, EffectRev.None); // first raycast hit
            bounceEffect[loop] = LastCreatedEntity();

            CreateBeamEffect(all, BeamType.BadBeam, hitPos[loop], hitPosBounces[loop], Color.Purple, EffectRev.None); // bounces
            bounceEffects[loop] = LastCreatedEntity();

            // PlayEffect(all, PlayEffect.GoodExplosion, Color.Purple, eyePos, 0.2); // muzzle flash
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Purple, hitPos[loop], 0.2); // first raycast hit
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Purple, hitPosBounces[loop], 0.2); // bounces

            Damage(hitPosPlayer[loop], player, 10000);
            Damage(hitPosPlayerBounces[loop], player, 10000);
        }

        Wait(0.15);
        for (define i = 0; i < NUM_BOUNCES; i++)
        {
            DestroyEffect(bounceEffect[i]);
            DestroyEffect(bounceEffects[i]);
        }
    }

rule: "[Buff] :: Buckshot : Create Orb"
    if (validBuffMap && !spawnWithBuckshot && spawnBuckshot && buckshotCD == 0 && (matchStarted || buffsSpawnImmediately))
    {
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Green, buffPos[3], 1);
        CreateEffect(all, Effect.Orb, Color.Green, buffPos[3], 2);
        buffEffect[3] = LastCreatedEntity();

        CreateInWorldText(all, AbilityIconString(Hero.Ashe, ButtonValue(Button.Ability1)), buffPos[3], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[3] = LastTextID();

        DestroyInWorldText(cdText[3]);
    }

rule: "[Buff] :: Buckshot : Collect"
    Event.OngoingPlayer
    if ((matchStarted && EntityExists(buffEffect[3]) && DistanceBetween(buffPos[3], player) < 2.5 && HasSpawned() && IsAlive()) || spawnWithBuckshot)
    {
        define buckshotBuffEffect;
        buckshotEnabled = true;

        if (!spawnWithBuckshot)
        {
            // destroy inworld text / icon / orb
            DestroyInWorldText(cdText[3]);
            DestroyInWorldText(buffIcon[3]);
            DestroyEffect(buffEffect[3]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Green, buffPos[3], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Green, buffPos[3], 200);

            // start timer in hud
            buckshotDur = BUCKSHOT_DUR;
            ChaseVariableAtRate(buckshotDur, 0, 1, RateChaseReevaluation.DestinationAndRate)
        
            // toasts
            CreateHudText(player, null, null, <"<1> Buckshot: <0> <1>", RoundToInteger(buckshotDur, Rounding.Up), AbilityIconString(Hero.Ashe, ButtonValue(Button.Ability1))>, Location.Top, 2);
            hudText[3] = LastTextID();
            BigMessage(player, "Buckshot");
            SmallMessage(player, "Your bullets spread like a shotgun!");

            // create effect
            CreateEffect(all, Effect.GoodAura, Color.Green, player, 0.75, EffectRev.VisibleToPositionAndRadius);
            buckshotBuffEffect = LastCreatedEntity();

            // sound when buff is about to run out
            Wait(BUCKSHOT_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
                Wait(1);
            }

            // destroy hud timer and player effect
            DestroyHudText(hudText[3]);
            DestroyEffect(buckshotBuffEffect);

            buckshotEnabled = false;

            // start in world cooldown
            BuckshotCooldown();
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Buckshot: Forever <0>", AbilityIconString(Hero.Ashe, ButtonValue(Button.Ability1))>, Location.Top, 2);
            hudText[3] = LastTextID();
        }
    }

playervar define randomizedSpreadHori;
playervar define randomizedSpreadDiag;
rule: "[Buff] :: Buckshot : Action"
    Event.OngoingPlayer
    if (buckshotEnabled && IsFiringPrimary())
    {
        // todo: PAIN PAIN PAIN PAIN MAKE THIS NOT FIRE 8000000 RAYCASTS SCORT PLEASE
        buckshotHitPos = [];
        buckshotHitPlayer = [];
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));
        define gunPos = WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        define buckshotBeam = [];
        define centerBeam;
        
        spreadDiag = BUCKSHOT_SPREAD - (BUCKSHOT_SPREAD * 0.33);
        spreadHori = BUCKSHOT_SPREAD;

        if (randomSpread)
        {
            randomizedSpreadHori = [];
            randomizedSpreadDiag = [];

            for (define hori = 0; hori < 4; hori++)
            {
                randomizedSpreadHori[hori] = RandomReal(spreadHori / 5, spreadHori + 1.5);
            }

            for (define diag = 0; diag < 4; diag++)
            {
                randomizedSpreadDiag[diag] = RandomReal(spreadHori / 5, spreadDiag + 1.5);
            }
        }

        /* ----------------------------------- diagonals ----------------------------------- */

        // lower left
        if (!randomSpread)
        {
            buckshotHitPos[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
            * 100, AllLivingPlayers(), player, false);

            buckshotHitPlayer[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
            * 100, AllLivingPlayers(), player, false);
        }
        else
        {
            buckshotHitPos[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadDiag[0]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadDiag[0]) 
            * 100, AllLivingPlayers(), player, false);

            buckshotHitPlayer[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadDiag[0]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadDiag[0]) 
            * 100, AllLivingPlayers(), player, false);
        }

        /* --------------------------------------------------------------------------------- */

        // upper left
        if (!randomSpread)
        {
            buckshotHitPos[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -spreadDiag) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -spreadDiag) 
            * 100, AllLivingPlayers(), player, false)
        }
        else 
        {
            buckshotHitPos[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadDiag[1]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -randomizedSpreadDiag[1]) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadDiag[1]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -randomizedSpreadDiag[1]) 
            * 100, AllLivingPlayers(), player, false)
        }

        /* --------------------------------------------------------------------------------- */

        // upper right
        if (!randomSpread)
        {
            buckshotHitPos[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
            * 100, AllLivingPlayers(), player, false)
        }
        else
        {
            buckshotHitPos[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadDiag[2]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadDiag[2]) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadDiag[2]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadDiag[2]) 
            * 100, AllLivingPlayers(), player, false)
        }
        

        /* --------------------------------------------------------------------------------- */

        // lower right
        if (!randomSpread)
        {
            buckshotHitPos[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -spreadDiag) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -spreadDiag) 
            * 100, AllLivingPlayers(), player, false)
        }
        else
        {
            buckshotHitPos[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadDiag[3]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -randomizedSpreadDiag[3]) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadDiag[3]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -randomizedSpreadDiag[3]) 
            * 100, AllLivingPlayers(), player, false)
        }

        /* --------------------------- verticals and horizontals --------------------------- */

        // upper mid
        if (!randomSpread)
        {
            buckshotHitPos[4] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadHori) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[4] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadHori) 
            * 100, AllLivingPlayers(), player, false)
        }
        else
        {
            buckshotHitPos[4] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadHori[0]) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[4] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + randomizedSpreadHori[0]) 
            * 100, AllLivingPlayers(), player, false)
        }
        
        /* --------------------------------------------------------------------------------- */

        // lower mid
        if (!randomSpread)
        {
            buckshotHitPos[5] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -spreadHori) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[5] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -spreadHori) 
            * 100, AllLivingPlayers(), player, false)
        }
        else
        {
            buckshotHitPos[5] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -randomizedSpreadHori[1]) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[5] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + -randomizedSpreadHori[1]) 
            * 100, AllLivingPlayers(), player, false)
        }

        /* --------------------------------------------------------------------------------- */

        // mid left
        if (!randomSpread)
        {
            buckshotHitPos[6] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(spreadHori) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + 0) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[6] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(spreadHori) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + 0) 
            * 100, AllLivingPlayers(), player, false)
        }
        else 
        {
            buckshotHitPos[6] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadHori[2]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + 0) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[6] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(randomizedSpreadHori[2]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + 0) 
            * 100, AllLivingPlayers(), player, false)
        }

        /* --------------------------------------------------------------------------------- */

        // mid right
        if (!randomSpread)
        {
            buckshotHitPos[7] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-spreadHori) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + 0) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[7] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-spreadHori) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + 0) 
            * 100, AllLivingPlayers(), player, false)
        }
        else
        {
            buckshotHitPos[7] = RayCastHitPosition(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadHori[3]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + 0) 
            * 100, AllLivingPlayers(), player, false)

            buckshotHitPlayer[7] = RayCastHitPlayer(EyePosition(), EyePosition() + 
            WorldVectorOf(Vector(TangentFromDegrees(-randomizedSpreadHori[3]) * 100, 0, 0), player, LocalVector.Rotation) + 
            DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + 0) 
            * 100, AllLivingPlayers(), player, false)
        }

        /* -------------------------------------------------------------------------------------------- */

        // center
        buckshotCenter = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, livingEnemies, player);

        /* -------------------------------------------------------------------------------------------- */

        // PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, EyePosition() + Facing() + gunPos, 0.2); // muzzle flash
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotCenter, 0.2);
        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotCenter, Color.Green, EffectRev.None);
        centerBeam = LastCreatedEntity();

        for (define pellets = 0; pellets < 8; pellets++)
        {
            Damage(buckshotHitPlayer[pellets], player, 10000);
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotHitPos[pellets], 0.2);
            CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotHitPos[pellets], Color.Green, EffectRev.None);
            buckshotBeam[pellets] = LastCreatedEntity();
        }

        Wait(0.15);
        DestroyEffect(centerBeam);
        for (define beams = 0; beams < 8; beams++)
        {
            DestroyEffect(buckshotBeam[beams]);
        }
    }


// rule: "[Debug] :: Position"
//     Event.OngoingPlayer
//     if (player == host)
//     {
//         CreateHudText(player, null, null, PositionOf(), Location.Top, 10);
//     }

// rule: "[Debug] :: Bots"
//     Event.OngoingPlayer
//     if (player == host && IsInteractHeld() && !IsCrouchHeld())
//     {
//         CreateDummyBot(HeroOf(), OppositeTeamOf(TeamOf()), -1, RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100), Facing() * -1);
//     }

// rule: "[Degug] :: Bots Hold Left Click"
//     Event.OngoingPlayer
//     if (IsDummyBot())
//     {
//         StartHoldingButton(player, Button.PrimaryFire);
//     }

// rule: "[Debug] :: Destroy Bots"
//     Event.OngoingPlayer
//     if (player == host && IsCrouchHeld() && IsInteractHeld())
//     {
//         DestroyAllDummyBots();

//     }