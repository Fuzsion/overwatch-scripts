import "macros.del";
import "instagibSettings.json";
import "jacob script\ruler.del";

define weaponStart: WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;

// bhop
playervar define bhopSpeed;
playervar define isChasing;

// primary
playervar define primaryHit;

// secondary
playervar define secondaryEyePos;
playervar define secondaryOrb;

// grapple
playervar define usingGrapple;
playervar define grappleHit;
playervar define grappleHitPlayer;


// constants :: bhop
globalvar define BHOP_MAX_SPEED;
globalvar define BHOP_SPEED_RATE;

// constants :: grapple
globalvar define GRAPPLE_PULL_SPEED;
globalvar define GRAPPLE_RANGE;

// constants :: secondary
globalvar define SECONDARY_PSPEED;
globalvar define SECONDARY_RADIUS;

// constants: misc
globalvar define MATCH_TIME_LIMIT;

// toggle
globalvar define matchStarted;

// dodge
globalvar define DODGE_FORCE;
playervar define throttleOf;
playervar define canDodge;

/////////////////////
/////// buffs ///////
/////////////////////

globalvar define buffsEnabled;
globalvar define buffsSpawnImmediately;
globalvar define validMap;
globalvar define buffEffect;
globalvar define buffPos;
globalvar define buffIcon;
globalvar define cdText;
globalvar define cdType;
playervar define hudText;
playervar define lifeKills;
playervar define spreeInWorld;
playervar define spreeEffect;
playervar define spreeHud;
playervar define hasSpawned;
globalvar define grappleEnabled;
globalvar define dodgeEnabled;
globalvar define secondaryEnabled;
globalvar define primaryFxEnabled;
globalvar define bhopEnabled;
globalvar define buffHudText;
globalvar define cdIP;

//// wallbang ////

globalvar define spawnWallbang;
globalvar define spawnWithWallbang;
globalvar define NUM_WALLBANGS;
globalvar define WALLBANG_DUR;
globalvar define WALLBANG_CD;
globalvar define wallbangCD;
playervar define wallbangEnabled;
playervar define wallbangEffect;
playervar define wallbangDur;

//// ricochet ////

globalvar define spawnRicochet;
globalvar define spawnWithRicochet;
globalvar define NUM_RICOCHETS;
globalvar define RICOCHET_CD;
globalvar define RICOCHET_DUR;
globalvar define ricochetCD;
playervar define ricochetEnabled;
playervar define ricochetDur;
playervar define eyePos;
playervar define facing;

//// buckshot ////

globalvar define spawnBuckshot;
globalvar define spawnWithBuckshot;
globalvar define BUCKSHOT_SPREAD;
globalvar define BUCKSHOT_CD;
globalvar define BUCKSHOT_DUR;
globalvar define buckshotCD;
playervar define buckshotEnabled;
playervar define buckshotDur;

//// smart Lock ////

globalvar define spawnLock;
globalvar define spawnWithLock;
globalvar define LOCK_CD;
globalvar define LOCK_DUR;
globalvar define lockCD;
playervar define lockEnabled;
playervar define lockDur;

globalvar define serverLoad;
globalvar define customXhair;
globalvar define PICKUP_RAD;
globalvar define primaryDelay;
globalvar define PRI_DELAY;
playervar define credit;

globalvar define spawnElectro;
globalvar define spawnWithElectro;
globalvar define ELECTRO_DELAY;
globalvar define electroCD;
globalvar define ELECTRO_CD;
globalvar define ELECTRO_DUR;
globalvar define electroPBar;
playervar define electroEnabled;
playervar define electroDur;

globalvar define buffDbg;

/* ------------------------------------------------------------------------------- todo + notes: -------------------------------------------------------------------------------
notes:
dont use EntityExists() with effects
for whatever reason; setting the buffUser to null will most likely break cooldown effects (timer inworld and growing sphere), doesnt break the timer logic, only the effects
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */

disabled rule: "---------------- Main ----------------"{}

rule: "[Main] :: Initial Global"
{
    // DisableInspectorRecording();
    DisableCompletion();
    DisableAnnouncer();

    CreateHudText(all, null, MatchTime() % 60 >= 10 
                             ? <"<0>:<1>", RoundToInteger(MatchTime() / 60, Rounding.Down), RoundToInteger(MatchTime() % 60, Rounding.Down)> 
                             : <"<0>:0<1>", RoundToInteger(MatchTime() / 60, Rounding.Down), RoundToInteger(MatchTime() % 60, Rounding.Down)>, /* spacing for crosshair */ " \n\n", Location.Top, 0.2);

    SetMatchTime(10);

    cdText = [];
    buffEffect = [];
    buffPos = [];
    buffIcon = [];
    grappleOption = [];

    matchStarted = false;

    MATCH_TIME_LIMIT = WorkshopSettingInteger("General",        "​Match Time (Minutes) (20)", 20, 1, 60, 1) * 60;
    PRI_DELAY = WorkshopSettingReal("General",                  "Primary Fire Delay (0.7)", 0.7, 0.51, 2, 2);
    primaryDelay = WorkshopSettingToggle("General",             "Enable Primary Fire Delay (On)", true, 3);
    primaryFxEnabled = WorkshopSettingToggle("General",         "Enable Primary Fire Effects (On)", true, 4);

    cdType = WorkshopSettingCombo("Buffs",                      "Buff Timer Type (Progress Bar)", 0, ["Progress Bar", "Timer", "None"], 1);
    buffsEnabled = WorkshopSettingToggle("Buffs",               "​​Enable Buffs (On)", true, 2);
    buffsSpawnImmediately = WorkshopSettingToggle("Buffs",      "​Buffs Spawn Immediately When Match Starts (Off)", false, 3);
    cdIP = WorkshopSettingToggle("Buffs",                       "Show buff cooldown timer (On)", true, 4);
    buffHudText = WorkshopSettingToggle("Buffs",                "Show Buff Cooldown HUD Text (On)", true, 5);
    customXhair = WorkshopSettingToggle("Buffs",                "Buffs Change Crosshair (On)", true, 6);
    PICKUP_RAD = WorkshopSettingReal("Buffs",                   "Buff Collection Radius (1.25)", 1.25, 0.5, 3, 7);

    grappleEnabled = WorkshopSettingToggle("Grapple",           "Enable Grapple (On)", true, 1);
    GRAPPLE_PULL_SPEED = WorkshopSettingReal("Grapple",         "Grapple ​​Pull Speed (2.65)", 2.65, 0.5, 5, 2);
    GRAPPLE_RANGE = WorkshopSettingReal("Grapple",              "​​Grapple Range (40)", 40, 3.5, 100, 3);
    grappleOption[0] = WorkshopSettingToggle("Grapple",         "Break Grapple if too close (On)", true, 4);
    grappleOption[1] = WorkshopSettingToggle("Grapple",         "Break Grapple if grapple hit loses LOS (On)", true, 5);

    secondaryEnabled = WorkshopSettingToggle("Secondary Fire",  "Enable Secondary (On)", true, 1);
    SECONDARY_PSPEED = WorkshopSettingReal("Secondary Fire",    "​​​Projectile Speed (90)", 90, 1, 500, 3);
    SECONDARY_RADIUS = WorkshopSettingReal("Secondary Fire",    "​​​Explosion Radius (2.5)", 2.5, 1, 20, 4);

    dodgeEnabled = WorkshopSettingToggle("Dodge",               "Enable Dodge (On)", true, 1);
    DODGE_FORCE = WorkshopSettingReal("Dodge",                  "Dodge ​​​​​Force (14)", 14, 1, 100, 2);

    bhopEnabled = WorkshopSettingToggle("Bunny Hopping",        "Enable Bunny Hopping (On)", true, 1);
    BHOP_MAX_SPEED = WorkshopSettingInteger("Bunny Hopping",    "​Maximum Speed Multiplier From Bunny Hopping (320)", 320, 110, 10000, 2);
    BHOP_SPEED_RATE = WorkshopSettingReal("Bunny Hopping",      "​​Speed gain rate (12.5)", 12.5, 1, 100, 3);

    spawnWallbang = WorkshopSettingToggle("Wallbang",           "​​​​Spawn Wallbang (On)", true, 1);
    WALLBANG_CD = WorkshopSettingInteger("Wallbang",            "​​Wallbang Spawn Time (75)", 75, 5, 600, 2);
    WALLBANG_DUR = WorkshopSettingInteger("Wallbang",           "Wallbang ​​​Duration (30)", 30, 1, 600, 3);
    NUM_WALLBANGS = WorkshopSettingInteger("Wallbang",          "​Wallbang Amount (8)", 8, 2, 100, 4);
    spawnWithWallbang = WorkshopSettingToggle("Wallbang",       "​​​​​All players have Wallbang (Off)", false, 5);

    spawnRicochet = WorkshopSettingToggle("Ricochet",           "Spawn Ricochet (On)", true, 1);
    RICOCHET_CD = WorkshopSettingInteger("Ricochet",            "Ricochet ​Spawn Time (75)", 75, 5, 600, 2);
    RICOCHET_DUR = WorkshopSettingInteger("Ricochet",           "​​Ricochet Duration (30)", 30, 1, 600, 3);
    NUM_RICOCHETS = WorkshopSettingInteger("Ricochet",          "​​​Ricochet Amount (4)", 4, 1, 8, 4);
    spawnWithRicochet = WorkshopSettingToggle("Ricochet",       "​​​​​All players have Ricochet (Off)", false, 5);

    spawnElectro = WorkshopSettingToggle("Electro",             "​​​​​Spawn Electro (On)", true, 1);
    ELECTRO_CD = WorkshopSettingInteger("Electro",              "Electro ​Spawn Time (100)", 100, 5, 600, 2);
    ELECTRO_DUR = WorkshopSettingInteger("Electro",             "Electro Duration (30)", 30, 1, 600, 3);
    ELECTRO_ESIZE = WorkshopSettingReal("Electro",              "Electro Primary Explosion Size (1.5)", 1.5, 1, 500, 4);
    ELECTRO_MESIZE = WorkshopSettingReal("Electro",             "Electro Mine Explosion Size (5)", 5, 1, 500, 5);
    ELECTRO_DELAY = WorkshopSettingReal("Electro",              "Electro Mine Explosion Time When Idle (3)", 3, 1, 500, 6);
    ELECTRO_PSPEED = WorkshopSettingReal("Electro",             "Electro Mine Projectile Speed (70)", 70, 1, 500, 7);
    spawnWithElectro = WorkshopSettingToggle("Electro",         "​​​​​All players have Electro (Off)", false, 9);

    // spawnSpark = WorkshopSettingToggle("Spark",                   "​​​​​Spawn Spark (On)", true, 1);
    // SPARK_CD = WorkshopSettingInteger("Spark",                    "Spark ​Spawn Time (85)", 85, 5, 600, 2);
    // SPARK_DUR = WorkshopSettingInteger("Spark",                   "Spark Duration (30)", 25, 1, 600, 3);
    // SPARK_PSPEED = WorkshopSettingReal("Spark",                   "Spark Projectile Speed (10)", 10, 1, 500, 4);
    // SPARK_ESIZE = WorkshopSettingReal("Spark",                    "Spark Normal Explosion Size (1.5)", 1.5, 1, 500, 5);
    // SPARK_HITESIZE = WorkshopSettingReal("Spark",                 "Spark shot out of air Explosion Size (4)", 4, 1, 500, 6);
    // spawnWithSpark = WorkshopSettingToggle("Spark",               "​​​​​All players have Spark (Off)", false, 7);

    spawnQuadshot = WorkshopSettingToggle("Quadshot",           "​​​​​Spawn Quadshot (On)", true, 1);
    QUADSHOT_CD = WorkshopSettingInteger("Quadshot",            "Quadshot ​Spawn Time (125)", 125, 5, 600, 2);
    QUADSHOT_DUR = WorkshopSettingInteger("Quadshot",           "Quadshot Duration (30)", 25, 1, 600, 3);
    QUADSHOT_SPREAD = WorkshopSettingReal("Quadshot",           "Quadshot Spread (Lower is Tighter) (0.8)", 0.8, 0.1, 20, 4);
    spawnWithQuadshot = WorkshopSettingToggle("Quadshot",       "​​​​​All players have Quadshot (Off)", false, 5);

    // ------------------------------------------- supers ------------------------------------------- //

    spawnVaporizer = WorkshopSettingToggle("Vaporizer",         "​​​​​Spawn Vaporizer (On)", true, 1);
    VAPORIZER_CD = WorkshopSettingInteger("Vaporizer",          "Vaporizer Spawn Time (180)", 180, 5, 600, 2);
    VAPORIZER_DUR = WorkshopSettingInteger("Vaporizer",         "Vaporizer Duration (30)", 30, 1, 600, 3);
    VAPORIZER_ESIZE = WorkshopSettingReal("Vaporizer",          "Vaporizer Explosion Size (16.75)", 16.75, 5, 50, 4);
    VAPORIZER_DELAY = WorkshopSettingReal("Vaporizer",          "Vaporizer Explosion and Weapon Fire Delay (1)", 1, 0.5, 20, 5);
    vaporizerUserAffected = WorkshopSettingToggle("Vaporizer",  "Vaporizer user affected by own explosion", true, 6);
    spawnWithVaporizer = WorkshopSettingToggle("Vaporizer",     "​​​​​All players have Vaporizer (Off)", false, 7);

    spawnBuckshot = WorkshopSettingToggle("Buckshot",           "​​​​​Spawn Buckshot (On)", true, 1);
    BUCKSHOT_CD = WorkshopSettingInteger("Buckshot",            "Buckshot ​Spawn Time (200)", 200, 5, 600, 2);
    BUCKSHOT_DUR = WorkshopSettingInteger("Buckshot",           "​​Buckshot Duration (30)", 30, 1, 600, 3);
    BUCKSHOT_SPREAD = WorkshopSettingReal("Buckshot",           "​​​Buckshot Spread (Lower is Tighter) (2.5)", 2.5, 0.1, 20, 4);
    spawnWithBuckshot = WorkshopSettingToggle("Buckshot",       "​​​​​All players have Buckshot (Off)", false, 5);

    spawnLock = WorkshopSettingToggle("Smart Lock",             "​​Spawn Smart Lock (On)", true, 1);
    LOCK_CD = WorkshopSettingInteger("Smart Lock",              "​Smart Lock Spawn Time (230)", 230, 5, 600, 2);
    LOCK_DUR = WorkshopSettingInteger("Smart Lock",             "​​​Smart Lock Duration (35)", 35, 1, 600, 3);
    LOCK_RADIUS = WorkshopSettingReal("Smart Lock",             "​​​Lock on radius (Degrees) (10)", 10, 1, 120, 4);
    LOCK_TIME = WorkshopSettingReal("Smart Lock",               "Lock on time (0.65)", 0.65, 0.1, 10, 5);
    spawnWithLock = WorkshopSettingToggle("Smart Lock",         "​​​All players have Smart Lock (Off)", false, 6);

    serverLoad = WorkshopSettingToggle("Debug",                 "Show Server Load", false, 1);
    buffDbg = WorkshopSettingToggle("Debug",                    "Display Buff Position Info", false, 2);

    if (!buffsEnabled)
    {
        spawnWallbang = false;
        spawnRicochet = false;
        spawnBuckshot = false;
        spawnLock = false;
        spawnVaporizer = false;
        spawnElectro = false;
        // spawnSpark = false;
        spawnQuadshot = false;
    }

     // [0]: wallbang
    // [1]: ricochet
    // [5]: electro
    // [6]: spark
    // [7]: quadshot

    // supers
    // [2]: buckshot
    // [3]: smart lock
    // [4]: vaporizer

    validMap = false;

    switch (true)
    {
        case (IsMap(Map.Workshop_Chamber) || IsMap(Map.Workshop_Expanse) || IsMap(Map.Workshop_Expanse_Night) || IsMap(Map.Workshop_Island) || IsMap(Map.Workshop_Island_Night)):
            validMap = true;

            if (buffsEnabled)
            {
                CreateInWorldText(all, "Regular", Vector(8, 4, 0), 1.5, TextColor: Color.Yellow);

                CreateInWorldText(all, "Supers", Vector(-8, 4, 0), 1.5, TextColor: Color.Red);
        
                CreateInWorldText(all, "Bullets will ignore walls and players, killing those who get hit", Vector(8, 2, -8), 0.75);
                CreateInWorldText(all, "Bullets bounce off walls, killing those who get hit", Vector(8, 2, -4), 0.75);
                CreateInWorldText(all, "Shots create a small explosion. Press reload to launch mines. All deployed mines are detonated if one of them is shot and armed.", Vector(8, 2, 0), 0.75);
                CreateInWorldText(all, "Press reload to launch an explosive projectile, projectile can be detonated with a larger radius if shot", Vector(8, 2, 4), 0.75);
                CreateInWorldText(all, "Turns your weapon into a small shotgun with an X-shaped spread pattern", Vector(8, 2, 8), 0.75);

                CreateInWorldText(all, "Turns your weapon into a shotgun with a large spread. Has an O shaped spread pattern", Vector(-8, 2, 4), 0.75);
                CreateInWorldText(all, <"Locks on to enemies by looking at them for <0> second(s)", LOCK_TIME>, Vector(-8, 2, 0), 0.75);
                CreateInWorldText(all, <"Fires a large explosion delayed by <0> seconds, decreases fire rate", VAPORIZER_DELAY>, Vector(-8, 2, -4), 0.75);
            }

            buffPos[0] = Vector(8, 1, -8);
            buffPos[1] = Vector(8, 1, -4);
            buffPos[5] = Vector(8, 1, 0);
            buffPos[6] = Vector(8, 1, 4);
            buffPos[7] = Vector(8, 1, 8);
            
            buffPos[2] = Vector(-8, 1, 4);
            buffPos[3] = Vector(-8, 1, 0);
            buffPos[4] = Vector(-8, 1, -4);
            break;
        case (IsMap(Map.Black_Forest) || IsMap(Map.Black_Forest_Winter)):
            validMap = true;
            buffPos[0] = Vector(16.79, 12.44, 29.48);
            buffPos[1] = Vector(16.18, 12.36, -20.11);
            buffPos[5] = Vector(-5.15, 14.05, 5.25);
            buffPos[6] = Vector(27.75, 18, 12.5);
            buffPos[7] = Vector(27.75, 18, -2.5);

            buffPos[2] = Vector(4.66, 18.28, 5.00);
            buffPos[3] = Vector(-25.49, 13.09, 5.00);
            buffPos[4] = Vector(21.00, 10.00, 5.00);
            break;
        case (IsMap(Map.Blizzard_World) || IsMap(Map.Blizzard_World_Winter)):
            validMap = true;
            buffPos[0] = Vector(-32.50, 0.61, 73.15);
            buffPos[1] = Vector(-77.28, 5.88, 66.15);
            buffPos[5] = Vector(-37.28, -1.25, 146.63);
            buffPos[6] = Vector(-77.28, 0.25, 66.15);
            buffPos[7] = Vector(-90.76, 1.75, 94.02);

            buffPos[2] = Vector(-54.50, 0.61, 110.20);
            buffPos[3] = Vector(-67.55, 1.75, 138.74);
            buffPos[4] = Vector(-25.04, 1.29, 109.95);
            break;
        case (IsMap(Map.Castillo)):
            validMap = true;
            buffPos[0] = Vector(-106.18, 40.56, 43.20);
            buffPos[1] = Vector(-100.35, 40.56, 73.75);
            buffPos[5] = Vector(-124.27, 35.43, 61.14);
            buffPos[6] = Vector(-96.77, 33.20, 33.82);
            buffPos[7] = Vector(-86.58, 33.56, 84.14);

            buffPos[2] = Vector(-115.85, 39.57, 60.92);
            buffPos[3] = Vector(-74.82, 33.00, 52.93);
            buffPos[4] = Vector(-85.65, 39.64, 55.00);
            break;
        case (IsMap(Map.Chateau_Guillard) || IsMap(Map.Chateau_Guillard_Halloween)):
            validMap = true;
            buffPos[0] = Vector(206.21, 10.03, 92.43);
            buffPos[1] = Vector(196.33, 17.50, 47.12);
            buffPos[5] = Vector(236.85, 3, 91.89);
            buffPos[6] = Vector(206.20, 16.50, 87.00);
            buffPos[7] = Vector(182.25, 10, 102.00);

            buffPos[2] = Vector(169.25, 6, 80.97);
            buffPos[3] = Vector(206.19, 1, 77.96);
            buffPos[4] = Vector(193.26, 10, 116.66);
            break;
        case (IsMap(Map.Dorado)):
            validMap = true;
            buffPos[0] = Vector(115.66, 8.73, -7.08);
            buffPos[1] = Vector(85.30, 13.75, 29.84);
            buffPos[5] = Vector(134.33, 12.01, 47.79);
            buffPos[6] = Vector(141.62, 11, 3.08);
            buffPos[7] = Vector(129.02, 10, -24.67);

            buffPos[2] = Vector(98.04, 19.01, 15.26);
            buffPos[3] = Vector(131.27, 12.05, 26.12);
            buffPos[4] = Vector(76.87, 9.00, 7.34);
            break;
        case (IsMap(Map.Ecopoint_Antarctica) || IsMap(Map.Ecopoint_Antarctica_Winter)):
            validMap = true;
            buffPos[0] = Vector(1.66, 12.63, -25.00);
            buffPos[1] = Vector(1.66, 12.63, 25.00);
            buffPos[5] = Vector(-10.30, 9.53, -0.32);
            buffPos[6] = Vector(20.54, 7.02, -17.00);
            buffPos[7] = Vector(20.54, 7.01, 17.00);

            buffPos[2] = Vector(-19.50, 13.00, 0.00);
            buffPos[3] = Vector(20.50, 10.00, 0.00);
            buffPos[4] = Vector(18.70, 5.00, 0.00);
            break;
        case (IsMap(Map.Eichenwalde) || IsMap(Map.Eichenwalde_Halloween)):
            validMap = true;
            buffPos[0] = Vector(55.70, 22.00, -67.84);
            buffPos[1] = Vector(58.33, 5.72, -90.39);
            buffPos[5] = Vector(55.99, 18.72, -109.98);
            buffPos[6] = Vector(54.76, 11.72, -118.74);
            buffPos[7] = Vector(38.31, 5.81, -65.01);

            buffPos[2] = Vector(76.03, 11.69, -109.66);
            buffPos[3] = Vector(88.13, 13.67, -67.39);
            buffPos[4] = Vector(30.76, 15.00, -81.88);
            break;
        case (IsMap(Map.Havana)):
            validMap = true;
            buffPos[0] = Vector(9.50, 7.00, -79.23);
            buffPos[1] = Vector(37.64, 11.00, -94.23);
            buffPos[5] = Vector(63.36, 5, -65.32);
            buffPos[6] = Vector(9.38, 13, -79.20);
            buffPos[7] = Vector(32.42, 5, -96.74);

            buffPos[2] = Vector(27.92, 13.00, -61.96);
            buffPos[3] = Vector(65.14, 12.97, -83.35);
            buffPos[4] = Vector(40.74, 6.82, -83.33);
            break;
        case (IsMap(Map.Hollywood) || IsMap(Map.Hollywood_Halloween)):
            validMap = true;
            buffPos[0] = Vector(-11.91, 2.73, -74.64);
            buffPos[1] = Vector(-4.09, 2.60, -15.87);
            buffPos[5] = Vector(28.64, 7.80, -77.49);
            buffPos[6] = Vector(50.05, 3.75, -56.09);
            buffPos[7] = Vector(-25.46, 6.75, -41.37);

            buffPos[2] = Vector(20.67, 2.60, -51.82);
            buffPos[3] = Vector(7.87, 13.90, -48.38);
            buffPos[4] = Vector(18.51, 5.69, -28.41);
            break;
        case (IsMap(Map.Kanezaka)):
            validMap = true;
            buffPos[0] = Vector(-0.96, 10, -46.32);
            buffPos[1] = Vector(-16.00, 12.15, 16.83);
            buffPos[5] = Vector(-30.66, 7.55, -9.75);
            buffPos[6] = Vector(-1.55, 7, 7.55);
            buffPos[7] = Vector(-52.52, 9, 24.24);

            buffPos[2] = Vector(-29.03, 5.00, 43.08);
            buffPos[3] = Vector(-30.66, 11.89, -9.75);
            buffPos[4] = Vector(-11.38, 6.86, 3.78);
            break;
        case (IsMap(Map.Kings_Row) || IsMap(Map.Kings_Row_Winter)):
            validMap = true;
            buffPos[0] = Vector(-49.46, 1.00, 2.69);
            buffPos[1] = Vector(-31.19, 10.00, -13.40);
            buffPos[5] = Vector(-34.90, 1.14, -24.66);
            buffPos[6] = Vector(-68.40, 5.50, -35.08);
            buffPos[7] = Vector(-65.62, 0.67, -21.24);

            buffPos[2] = Vector(-93.67, 8.50, -29.38);
            buffPos[3] = Vector(-48.85, 10.12, -37.62);
            buffPos[4] = Vector(-92.15, 2.10, 7.65);
            break;
        case (IsMap(Map.Lijiang_Control_Center) || IsMap(Map.Lijiang_Control_Center_Lunar)):
            validMap = true;
            buffPos[0] = Vector(-26.80, 268.00, 308.00);
            buffPos[1] = Vector(26.80, 268.00, 308.00);
            buffPos[5] = Vector(0, 273.43, 280);
            buffPos[6] = Vector(20.25, 270.95, 337.10);
            buffPos[7] = Vector(-20.25, 270.95, 337.10);

            buffPos[2] = Vector(0.00, 271.00, 323.00);
            buffPos[3] = Vector(0.00, 271.00, 260.65);
            buffPos[4] = Vector(0.00, 279.00, 291.85);
            break;
        case (IsMap(Map.Lijiang_Garden) || IsMap(Map.Lijiang_Garden_Lunar)):
            validMap = true;
            buffPos[0] = Vector(46.85, 96.04, 150);
            buffPos[1] = Vector(-46.85, 96.04, 150);
            buffPos[5] = Vector(0, 96.00, 125.85);
            buffPos[6] = Vector(-17.69, 95, 173.97);
            buffPos[7] = Vector(17.69, 95, 173.97);

            buffPos[2] = Vector(0, 95, 143.35);
            buffPos[3] = Vector(0, 95, 185.00);
            buffPos[4] = Vector(0, 97, 108.00);
            break;
        case (IsMap(Map.Necropolis)):
            validMap = true;
            buffPos[0] = Vector(1.68, 12.70, 17.25);
            buffPos[1] = Vector(1.80, 12.70, -16.41);
            buffPos[5] = Vector(-31.13, 3, 0);
            buffPos[6] = Vector(1.15, 4, 22.91);
            buffPos[7] = Vector(1.15, 4, -22.91);

            buffPos[2] = Vector(-21.05, 13.71, 0);
            buffPos[3] = Vector(8.50, 2.01, 0.00);
            buffPos[4] = Vector(23.08, 5.99, 0.00);
            break;
        case (IsMap(Map.Paris)):
            validMap = true;
            buffPos[0] = Vector(-104.10, 16.00, -100.65);
            buffPos[1] = Vector(-109.18, 11.00, -60.60);
            buffPos[5] = Vector(-103.36, 11.76, -37.17);
            buffPos[6] = Vector(-81.38, 14, -103.85);
            buffPos[7] = Vector(-52.17, 10.08, -46.28);

            buffPos[2] = Vector(-57.19, 14.00, -82.00);
            buffPos[3] = Vector(-73.39, 11.02, -38.23);
            buffPos[4] = Vector(-85.93, 13.00, -64.09);
            break;
        case (IsMap(Map.Oasis_City_Center)):
            validMap = true;
            buffPos[0] = Vector(164.76, 5, 226.22);
            buffPos[1] = Vector(122.22, 5, 268.75);
            buffPos[5] = Vector(158.69, 5, 262.68);
            buffPos[6] = Vector(125.12, 2.85, 291.32);
            buffPos[7] = Vector(187.39, 2.85, 229.09);

            buffPos[2] = Vector(154.48, 12.52, 258.48);
            buffPos[3] = Vector(118.01, 2, 221.96);
            buffPos[4] = Vector(143.48, 3.15, 247.50);
            break; 
        case (IsMap(Map.Oasis_University)):
            validMap = true;
            buffPos[0] = Vector(-188, 16, -38);
            buffPos[1] = Vector(-188, 16, 38);
            buffPos[5] = Vector(-188, 10.40, 0);
            buffPos[6] = Vector(-188, 17, 18);
            buffPos[7] = Vector(-188, 17, -18);

            buffPos[2] = Vector(-172, 18, 0);
            buffPos[3] = Vector(-188, 17, 0);
            buffPos[4] = Vector(-217.72, 20, 0);
            break; 
        case (IsMap(Map.Oasis_Gardens)):
            validMap = true;
            buffPos[0] = Vector(115.06, 8.50, -273.62);
            buffPos[1] = Vector(167.40, 8.50, -221.28);
            buffPos[5] = Vector(87.4, 3.50, -248.25);
            buffPos[6] = Vector(142, 3.50, -193.60);
            buffPos[7] = Vector(129.90, 16.28, -236.12);

            buffPos[2] = Vector(141.32, 8.38, -247.58);
            buffPos[3] = Vector(152.05, 8.54, -258.26);
            buffPos[4] = Vector(121.35, 12.50, -227.56);
            break;
    }

    CreateHudText(FilteredArray(all, Curr().credit), null, null, "ㅤInstagib | Created by scort#11221", Location.Right, 0, Color.White, Color.White, Color.White, HudTextRev.VisibleTo);
    CreateHudText(FilteredArray(all, Curr().credit), null, "ㅤv2.0.0 | Code: APPPX\n", null, Location.Right, 0.1, Color.White, Color.White, Color.White, HudTextRev.VisibleTo);

    if (validMap && buffsEnabled && !buffsSpawnImmediately)
    {
        wallbangCD = WALLBANG_CD;
        ricochetCD = RICOCHET_CD;
        buckshotCD = BUCKSHOT_CD;
        lockCD = LOCK_CD;
        vaporizerCD = VAPORIZER_CD;
        electroCD = ELECTRO_CD;
        // sparkCD = SPARK_CD;
        quadshotCD = QUADSHOT_CD;
    }
}

rule: "[Main] :: Start Match"
if (!matchStarted)
if (IsGameInProgress())
{
    LogToInspector("Match Started");
    SetMatchTime(MATCH_TIME_LIMIT);
    matchStarted = true;

    if (serverLoad)
    {
        CreateHudText(host, null, " ", "Server Load", Location.Left, 11);
        CreateHudText(host, null, "Current", <"<0>%", RoundToInteger(ServerLoad() / 2.55, Rounding.Nearest)>, Location.Left, 12, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
        CreateHudText(host, null, "Average", <"<0>%", RoundToInteger(ServerLoadAverage() / 2.55, Rounding.Nearest)>, Location.Left, 13, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
        CreateHudText(host, null, "Peak", <"<0>%", RoundToInteger(ServerLoadPeak() / 2.55, Rounding.Nearest)>, Location.Left, 14, Color.White, Color.White, Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
    }

    if (buffDbg)
    {
        CreateHudText(host, null, <"POS: <0> | Dist: <1>", buffPos[0], DistanceBetween(host, buffPos[0])>, null, Location.Left, 0.9);
        CreateHudText(host, null, <"POS: <0> | Dist: <1>", buffPos[1], DistanceBetween(host, buffPos[1])>, null, Location.Left, 1.9);

        CreateHudText(host, null, <"POS: <0> | Dist: <1>", buffPos[5], DistanceBetween(host, buffPos[5])>, null, Location.Left, 2.9);
        CreateHudText(host, null, <"POS: <0> | Dist: <1>", buffPos[6], DistanceBetween(host, buffPos[6])>, null, Location.Left, 3.9);
        CreateHudText(host, null, <"POS: <0> | Dist: <1>", buffPos[7], DistanceBetween(host, buffPos[7])>, null, Location.Left, 4.9);

        CreateHudText(host, null, <"POS: <0> | Dist: <1>", buffPos[4], DistanceBetween(host, buffPos[4])>, null, Location.Left, 5.9);
        CreateHudText(host, null, <"POS: <0> | Dist: <1>", buffPos[2], DistanceBetween(host, buffPos[2])>, null, Location.Left, 6.9);
        CreateHudText(host, null, <"POS: <0> | Dist: <1>", buffPos[3], DistanceBetween(host, buffPos[3])>, null, Location.Left, 7.9);
    }

    if (validMap && buffsEnabled)
    {
        if (!buffsSpawnImmediately)
        {
            WallbangCooldown();
            RicochetCooldown();
            BuckshotCooldown();
            LockCooldown();
            VaporizerCooldown();
            ElectroCooldown();
            QuadshotCooldown();
        }
        else
        {
            wallbangCD = 0;
            ricochetCD = 0;
            buckshotCD = 0;
            lockCD = 0;
            vaporizerCD = 0;
            electroCD = 0;
            quadshotCD = 0;
        }

        if (buffHudText)
        {
            if (!spawnWithWallbang && spawnWallbang)
            {
                CreateHudText(all, AbilityIconString(Hero.Baptiste, Button.Ultimate), null,
                wallbangCD != 0 ? wallbangText : canPickupBuff[0] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buffUser[0]>,
                Location.Left, 1, Color.Yellow);
            }
            if (!spawnWithRicochet && spawnRicochet)
            {
                CreateHudText(all, AbilityIconString(Hero.Winston, Button.Ability1), null,
                ricochetCD != 0 ? ricochetText : canPickupBuff[1] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buffUser[1]>,
                Location.Left, 2, Color.Violet);
            }

            if (!spawnWithElectro && spawnElectro)
            {
                CreateHudText(all, AbilityIconString(Hero.Echo, Button.SecondaryFire), null,
                electroCD != 0 ? electroText : canPickupBuff[5] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buffUser[5]>,
                Location.Left, 3, Color.SkyBlue);
            }

            CreateHudText(all, AbilityIconString(Hero.Sigma, Button.Ability1), null,
            "",
            Location.Left, 4, Color.Purple);

            if (!spawnWithQuadshot && spawnQuadshot)
            {
                CreateHudText(all, AbilityIconString(Hero.Echo, Button.Ability1), null,
                quadshotCD != 0 ? quadshotText : canPickupBuff[7] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buffUser[7]>,
                Location.Left, 5, Color.Orange);
            }

            if ((!spawnWithVaporizer && spawnVaporizer) || (!spawnWithBuckshot && spawnBuckshot) || (!spawnWithLock && spawnLock))
            {
                CreateHudText(all, null, " \nSupers", null,
                Location.Left, 5.1, Color.White);
            }

            if (!spawnWithVaporizer && spawnVaporizer)
            {
                CreateHudText(all, AbilityIconString(Hero.Symmetra, Button.Ultimate), null,
                vaporizerCD != 0 ? vaporizerText : canPickupBuff[4] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buffUser[4]>,
                Location.Left, 6, Color.Rose);
            }
            if (!spawnWithBuckshot && spawnBuckshot)
            {
                CreateHudText(all, AbilityIconString(Hero.Ashe, Button.Ability1), null,
                buckshotCD != 0 ? buckshotText : canPickupBuff[2] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buffUser[2]>,
                Location.Left, 7, CustomColor(0, 255, 0, 255));
            }
            if (!spawnWithLock && spawnLock)
            {
                CreateHudText(all, AbilityIconString(Hero.Sombra, Button.SecondaryFire), null,
                lockCD != 0 ? lockText : canPickupBuff[3] ? IconString(Icon.Checkmark) : <"In-Use by <0>", buffUser[3]>,
                Location.Left, 8, Color.Blue);
            }
        }
    }
}

rule: "[Main] :: Crosshair"
Event.OngoingPlayer
if (customXhair)
{
    /* 
    wallbang: 》 《
    ricochet: ᄾ ᄼ
    shock: 
    electro: ㅑㅕ
    tri shot: ∴ ∴


    buckshot: 〘 〙
    vaporizer: ∈ ∋
    smart lock: ⁅ ⁆
    */

    // this is fucking disgusting and needs improvement. for now this works fine as a proof of concept
    CreateHudText(player, null, " \n\n", <"ㅤ\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<0><1><2><3><4><5><6>               <7><8><9><10><11><12><13>", 
    // left
    wallbangEnabled ? "≫" : "",
    ricochetEnabled ? "ᄾ" : "",
    electroEnabled ? "ㅑ" : "",
    quadshotEnabled ? "Ｘ" : "",
    buckshotEnabled ? "〘" : "",
    lockEnabled ? CountOf(lockedTargets) >= 1 ? "▣" : "□" : "",
    vaporizerEnabled ? " ∈" : "",
    // right
    vaporizerEnabled ? "∋ " : "",
    lockEnabled ? CountOf(lockedTargets) >= 1 ? "▣" : "□" : "",
    buckshotEnabled ? "〙" : "",
    quadshotEnabled ? "Ｘ" : "",
    electroEnabled ? "ㅕ" : "",
    ricochetEnabled ? "ᄼ" : "",
    wallbangEnabled ? "≪" : "">, 
    Location.Top, 2, Color.White, Color.White, Color.White);
}

rule: "[Main] :: Player Join"
Event.OnPlayerJoin
{
    if (IsDummyBot())
        SetRespawnMaxTime(player, 1);

    bCnt = 0;
    hasSpawned = false;
    DisableGameModeHud();

    // DisallowButton(player, Button.PrimaryFire);
    DisallowButton(player, Button.Ability1);
    DisallowButton(player, Button.Ability2);
    SetProjectileSpeed(player, 10000);

    if (spawnWithWallbang)
    {
        wallbangEnabled = true;
        wallbangDur = 10000;
        bCnt++;
    }
    if (spawnWithRicochet)
    {
        ricochetEnabled = true;
        ricochetDur = 10000;
        bCnt++;
    }
    if (spawnWithBuckshot)
    {
        buckshotEnabled = true;
        buckshotDur = 10000;
        bCnt++;
    }
    if (spawnWithLock)
    {
        lockEnabled = true;
        lockDur = 10000;
        bCnt++;
    }
    if (spawnWithVaporizer)
    {
        vaporizerEnabled = true;
        vaporizerDur = 10000;
        bCnt++;
    }
    if (spawnWithElectro)
    {
        electroEnabled = true;
        electroDur = 10000;
        bCnt++;
    }
    // if (spawnWithSpark)
    // {
    //     sparkEnabled = true;
    //     sparkDur = 10000;
    //     bCnt++;
    // }
    if (spawnWithQuadshot)
    {
        quadshotEnabled = true;
        quadshotDur = 10000;
        bCnt++;
    }

    hudText = [];
    spreeInWorld = [];
    secondaryEyePos = -10000;
    electroEyePos1 = -10000;
    electroEyePos2 = -10000;
    electroEyePos3 = -10000;
    bhopSpeed = 100;
}

rule: "[Main] :: Player Leave"
Event.OnPlayerLeave
{
    if (player == buffUser[0])
    {
        LogToInspector("Wallbang user no longer exists");
        WallbangCooldown();
    }

    if (player == buffUser[1])
    {
        LogToInspector("Riochet user no longer exists");
        RicochetCooldown();
    }

    if (player == buffUser[2])
    {
        LogToInspector("Buckshot user no longer exists");
        BuckshotCooldown();
    }

    if (player == buffUser[3])
    {
        LogToInspector("Smart Lock user no longer exists");
        LockCooldown();
    }

    if (player == buffUser[4])
    {
        LogToInspector("Vaporizer user no longer exists");
        VaporizerCooldown();
    }

    if (player == buffUser[5])
    {
        LogToInspector("Electro user no longer exists");
        ElectroCooldown();
    }

    // if (player == buffUser[6])
    // {
    //     LogToInspector("Spark user no longer exists");
    //     SparkCooldown();
    // }

    if (player == buffUser[7])
    {
        LogToInspector("Quadshot user no longer exists");
        QuadshotCooldown();
    }

    // DestroyInWorldText(whText);
    DestroyInWorldText(lockId);
    DestroyInWorldText(lockingId);
}

rule: "[Main] :: Player Spawned"
Event.OngoingPlayer
if (HasSpawned())
{
    hasSpawned = true;
    credit = true;
    SmallMessage(player, "Welcome!");
    Wait(3);
    SmallMessage(player, <"Holding down <0> will let you gain speed by bunny hopping", InputBindingString(Button.Jump)>);
    Wait(3);
    SmallMessage(player, <"<0> to use a grappling hook to pull you towards a surface or to pull players towards you", InputBindingString(Button.Ability2)>);
    Wait(3);
    SmallMessage(player, <"<0> to launch a projectile that knocks yourself and enemy players back", InputBindingString(Button.SecondaryFire)>);
    Wait(3);
    SmallMessage(player, <"<0> to dodge in any direction", InputBindingString(Button.Ability1)>);
    Wait(3);
    SmallMessage(player, "Buffs are littered thorughout the map that give you special changes to your weapon. Have fun!");

    Wait(15);
    credit = false;
}


rule: "[Main] :: Force Respawn"
Event.OngoingPlayer
if (IsButtonHeld(player, Button.Jump))
if (IsDead())
{
    Respawn();
}

// rule: "[Main] :: Player Respawn"
//     Event.OngoingPlayer
//     if (IsAlive())
//     {
//         if (wallbangEnabled)
//             ChaseVariableAtRate(wallbangDur, 0, 1, RateChaseReevaluation.None);
//         if (ricochetEnabled)
//             ChaseVariableAtRate(ricochetDur, 0, 1, RateChaseReevaluation.None);
//         if (buckshotEnabled)
//             ChaseVariableAtRate(buckshotDur, 0, 1, RateChaseReevaluation.None);
//         if (lockEnabled)
//             ChaseVariableAtRate(lockDur, 0, 1, RateChaseReevaluation.None);
//         if (vaporizerEnabled)
//             ChaseVariableAtRate(vaporizerDur, 0, 1, RateChaseReevaluation.None);
//     }

// rule: "[Main] :: Player Dead"
//     Event.OngoingPlayer
//     if (IsDead())
//     {
//         StopChasingVariable(wallbangDur);
//         StopChasingVariable(ricochetDur);
//         StopChasingVariable(buckshotDur);
//         StopChasingVariable(lockDur);
//         StopChasingVariable(vaporizerDur);
//     }

rule: "[Main] :: Speedometer & Accuracy HUD Text"
Event.OngoingPlayer
if (bhopEnabled)
if (BHOP_MAX_SPEED > 100)
{
    CreateHudText(player, null, null, <" \n<0> M/S\n", HorizontalSpeedOf()>, Location.Left, 10, Color.White, Color.White, Color.White, HudTextRev.String);
}

rule: "[Main] :: End Game"
if (matchStarted)
if (MatchTime() == 0)
{
    EnableCompletion();
}

rule: "[Main] :: Primary Delay"
Event.OngoingPlayer
if (primaryDelay)
if (!spawnWithVaporizer)
if (!vaporizerEnabled) 
if (IsPrimaryHeld())
{
    // AllowButton(player, Button.PrimaryFire);
    PressButton(player, Button.PrimaryFire);
    MinWait();
    DisallowButton(player, Button.PrimaryFire);
    Wait(PRI_DELAY);
    AllowButton(player, Button.PrimaryFire);
    LoopIfConditionIsTrue();
}

playervar define bCnt;
rule: "[Main] :: Primary Effect"
Event.OngoingPlayer
if (IsFiringPrimary())
if (primaryFxEnabled) 
if (bCnt == 0)
{
    primaryHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);
    define startPos = weaponStart;

    define enemies = RemoveFromArray(all, player);

    define primaryBeam = [];
    CreateBeamEffect(player, BeamType.BadBeam, EyePosition() + Facing() + startPos, primaryHit, Color.Aqua, EffectRev.None);
    primaryBeam[0] = LastCreatedEntity();
    CreateBeamEffect(enemies, BeamType.BadBeam, EyePosition() + Facing() + startPos, primaryHit, Color.Red, EffectRev.None);
    primaryBeam[1] = LastCreatedEntity();

    PlayEffect(player, PlayEffect.GoodExplosion, Color.Aqua, primaryHit, 0.2);
    PlayEffect(enemies, PlayEffect.GoodExplosion, Color.Red, primaryHit, 0.2);

    Wait(0.25);
    DestroyEffect(primaryBeam[0]);
    DestroyEffect(primaryBeam[1]);
}

disabled rule: "---------------- Killing Spree Notifs ----------------"{}

rule: "[Killspree] :: Record Kills"
Event.OnFinalBlow
{
    lifeKills++;
}

rule: "[Killspree] :: Reset Kills on death"
Event.OnDeath
{
    if (lifeKills >= 6)
    {
        BigMessage(all, !EventWasEnvironment() 
                            ? <"<0>'s <1> player spree was ended by <2>!", Victim(), lifeKills, Attacker()> 
                            : <"<0>'s <1> player spree was ended by the world!", Victim(), lifeKills>);

        SmallMessage(player, <"<0> player kill spree!", lifeKills>);

        DestroyEffect(spreeEffect);
        DestroyHudText(spreeHud);

        Wait(0.1);
        spreeInWorld = [];
    }

    lifeKills = 0;
}

playervar define streakColor;
playervar define streakStr;
rule: "[Killspree] :: Kill"
Event.OnFinalBlow
if (lifeKills == 6)
{
    BigMessage(all, <"<0> is on a Killing Spree!", player>);

    CreateEffect(all, Effect.Sparkles, streakColor != null ? streakColor : RainbowColor(), player, 1, EffectRev.VisibleToPositionRadiusAndColor);
    spreeEffect = LastCreatedEntity();

    CreateHudText(player, null, <" \n<0> Kills", lifeKills>, streakStr, Location.Left, 15, Color.White, Color.White, streakColor != null ? streakColor : RainbowColor(), HudTextRev.VisibleToSortOrderStringAndColor);
    spreeHud = LastTextID();
    // if then else for colors here because var doesnt update when using RainbowColor()

    CreateInWorldText(player, "Killing Spree!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.White);
    spreeInWorld[0] = LastTextID();

    streakStr = "Killing Spree";
    streakColor = Color.White;

    Wait(2);

    DestroyInWorldText(spreeInWorld[0]);
}

rule: "[Killspree] :: Rampage"
Event.OnFinalBlow
if (lifeKills == 8)
{
    BigMessage(all, <"<0> is on a Rampage!", player>);

    CreateInWorldText(player, "Rampage!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.LimeGreen);
    spreeInWorld[1] = LastTextID();

    streakStr = "Rampage";
    streakColor = Color.LimeGreen;

    Wait(2);

    DestroyInWorldText(spreeInWorld[1]);
}

rule: "[Killspree] :: Dominating"
Event.OnFinalBlow
if (lifeKills == 11)
{
    BigMessage(all, <"<0> is Dominating!", player>);

    CreateInWorldText(player, "Dominating!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.SkyBlue);
    spreeInWorld[2] = LastTextID();

    streakStr = "Dominating";
    streakColor = Color.SkyBlue;

    Wait(2);

    DestroyInWorldText(spreeInWorld[2]);
}

rule: "[Killspree] :: Unstoppable"
Event.OnFinalBlow
if (lifeKills == 14)
{
    BigMessage(all, <"<0> is Unstoppable!", player>);

    CreateInWorldText(player, "Unstoppable!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Purple);
    spreeInWorld[3] = LastTextID();

    streakStr = "Unstoppable";
    streakColor = Color.Purple;

    Wait(2);

    DestroyInWorldText(spreeInWorld[3]);
}

rule: "[Killspree] :: Godlike"
Event.OnFinalBlow
if (lifeKills == 17)
{
    BigMessage(all, <"<0> is Godlike!", player>);

    CreateInWorldText(player, "Godlike!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Yellow);
    spreeInWorld[4] = LastTextID();

    streakStr = "Godlike";
    streakColor = Color.Yellow;

    Wait(2);

    DestroyInWorldText(spreeInWorld[4]);
}

rule: "[Killspree] :: Divine"
Event.OnFinalBlow
if (lifeKills == 21)
{
    BigMessage(all, <"<0> is Divine!", player>);

    CreateInWorldText(player, "Divine!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Orange);
    spreeInWorld[5] = LastTextID();

    streakStr = "Divine";
    streakColor = Color.Orange;

    Wait(2);

    DestroyInWorldText(spreeInWorld[5]);
}

rule: "[Killspree] :: Empyreal"
Event.OnFinalBlow
if (lifeKills == 24)
{
    BigMessage(all, <"<0> is Empyreal!", player>);

    CreateInWorldText(player, "Empyreal!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.Color, RainbowColor());
    spreeInWorld[6] = LastTextID();

    streakStr = "Empyreal";
    streakColor = null;

    Wait(2);

    DestroyInWorldText(spreeInWorld[6]);
}

disabled rule: "---------------- Bhop ----------------"{}

playervar define bhopping;

void ResetSpeed() playervar "[Bhop] :: Reset Speed"
{
    StopChasingVariable(bhopSpeed);
    isChasing = false;
    bhopping = false;
    bhopSpeed = 100;
    SetMoveSpeed(player, bhopSpeed);
}

rule: "[Bhop] :: Auto Hop"
Event.OngoingPlayer
if (bhopEnabled)
if (IsOnGround())
if (IsJumpHeld())
{
    DisableJump();
    MinWait();
    AllowJump();
}

// void StopAccelDir() playervar "[Bhop] :: Stop Accel Dir Sub"
// {
//     StopAccelerating();
//     StopForcingThrottle();
//     horizontalFacingVector = null;
// }

// playervar define horizontalFacingVector;
// rule: "[Bhop] :: Start Accel Dir"
// Event.OngoingPlayer
// if (bhopping)
// if (!usingGrapple)
// if (ThrottleOf().Z != 1)
// {
//     horizontalFacingVector = DirectionFromAngles(HorizontalFacingAngleOf(), 0);

//     if (SpeedOfInDirection(player, DirectionFromAngles(HorizontalFacingAngleOf(), 0)) >= 0)
//     {
//         // lol
//         ForceThrottle(player, 0.9999, 1, 0, 1, 0, 1); // forces player to hold W, unable to use throttle 1 for Z because stopping the accel dir relies on the throttle being 1
//         StartAccelerating(player, Forward(), 10000, 60, Relative.ToPlayer, AccelerateRev.DirectionRateAndMaxSpeed);
//     }
//     // else
//     // {
//     //     ForceThrottle(player, 0, 1, 0.9999, 1, 0, 1);
//     //     StartAccelerating(player, Backward(), 1000, 120, Relative.ToPlayer, AccelerateRev.DirectionRateAndMaxSpeed);
//     //     horizontalFacingVector = -horizontalFacingVector;
//     // }

//     StartAccelerating(player, horizontalFacingVector, 1000, 60, Relative.ToWorld, AccelerateRev.DirectionRateAndMaxSpeed);
// }

// rule: "[Bhop] :: Stop Accel Dir if moving"
// Event.OngoingPlayer
// if (bhopping)
// if (ThrottleOf().Z == 1 || ThrottleOf().Z == -1)
// {
//     // StopAccelDir();
// }

// rule: "[Bhop] :: Stop Accel Dir if Grapple"
// Event.OngoingPlayer
// if (usingGrapple)
// {
//     // StopAccelDir();
// }

rule: "[Bhop] :: Airborne"
Event.OngoingPlayer
if (bhopEnabled)
if ((!usingGrapple && IsInAir() && HorizontalSpeedOf() > 5.14) || (usingGrapple && IsInAir()))
{
    ChaseVariableAtRate(bhopSpeed, BHOP_MAX_SPEED, BHOP_SPEED_RATE, RateChaseReevaluation.None);
    isChasing = true;
    bhopping = true;
}

rule: "[Bhop] :: Update Speed"
Event.OngoingPlayer
if (isChasing)
{
    SetMoveSpeed(player, bhopSpeed);
    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Bhop] :: Update isChasing"
Event.OngoingPlayer
if (isChasing && bhopSpeed == BHOP_MAX_SPEED || bhopSpeed == 100)
{
    StopChasingVariable(bhopSpeed);
    isChasing = false;
}

rule: "[Bhop] :: Stop chasing"
Event.OngoingPlayer
if (!usingGrapple && (isChasing || bhopSpeed == BHOP_MAX_SPEED) && HorizontalSpeedOf() < 5.14)
{
    ResetSpeed();
    // StopAccelDir();
}

rule: "[Bhop] :: Stop if player is on ground"
Event.OngoingPlayer
if ((IsOnGround() && !usingGrapple) && (bhopSpeed > 100))
{
    WaitIfTrue(0.2);
    ResetSpeed();
    // StopAccelDir();
}

disabled rule: "---------------- Dodge ----------------"{}

rule: "[Dodge] :: Action"
Event.OngoingPlayer
if (dodgeEnabled)
if (canDodge)
if (!usingGrapple)
if (IsAbility1Held())
{
    throttleOf = ThrottleOf() + Vector(0, 0.5, 0);

    if (throttleOf == Vector(0, 0.5, 0))
        throttleOf = Vector(0, 0.5, 1);

    ApplyImpulse(player, throttleOf, DODGE_FORCE, Relative.ToPlayer, ContraryMotion.Cancel);

    if (bhopSpeed < 120)
        bhopSpeed += BHOP_SPEED_RATE * 3;

    canDodge = false;
}

rule: "[Dodge] :: On Ground"
Event.OngoingPlayer
if (IsOnGround())
{
    canDodge = true;
}


disabled rule: "---------------- Secondary Fire ----------------"{}

// playervar define secondaryInAir;
playervar define rcStart;
playervar define rcEnd;
rule: "[Secondary Fire] :: Projectile"
Event.OngoingPlayer
if (secondaryEnabled)
if (IsSecondaryHeld())
if (IsAlive())
{
    rcStart = EyePosition();
    rcEnd = EyePosition() + Facing() * 100;

    PlayEffect(all, PlayEffect.RingExplosionSound, Color.White, player, 50);

    DestroyEffect(secondaryOrb[0]);
    DestroyEffect(secondaryOrb[1]);

    // secondaryHit = RayCastHitPosition(rcStart, rcEnd, AllLivingPlayers(), player);
    secondaryEyePos = EyePosition();

    CreateEffect(all, Effect.Orb, Color.Red, secondaryEyePos, 0.25);
    secondaryOrb[0] = LastCreatedEntity();
    CreateEffect(all, Effect.BadAura, Color.Red, secondaryEyePos, 0.5);
    secondaryOrb[1] = LastCreatedEntity();

    ChaseVariableAtRate(secondaryEyePos, RayCastHitPosition(rcStart, rcEnd, AllLivingPlayers(), player), SECONDARY_PSPEED, RateChaseReevaluation.DestinationAndRate);

    Wait(0.75);
    LoopIfConditionIsTrue();
}

rule: "[Secondary Fire] :: Projectile Impulse"
Event.OngoingPlayer
if (DistanceBetween(secondaryEyePos, RayCastHitPosition(rcStart, rcEnd, AllLivingPlayers(), player)) < 0.1)
{
    // secondaryInAir = false;
    StopChasingVariable(secondaryEyePos);
    define players = FilteredArray(AllLivingPlayers(), DistanceBetween(Curr(), secondaryEyePos) <= SECONDARY_RADIUS);
    for (define i = 0; i < CountOf(players); i++)
    {
        ApplyImpulse(players[i], DirectionTowards(secondaryEyePos, players[i] + Vector(0, 2, 0)), 15, Relative.ToWorld, ContraryMotion.Incorporate);
    }

    PlayEffect(all, PlayEffect.GoodExplosion, Color.Red, secondaryEyePos, SECONDARY_RADIUS);

    DestroyEffect(secondaryOrb[0]);
    DestroyEffect(secondaryOrb[1]);
}

disabled rule: "---------------- Grapple ----------------"{}
playervar define grappleBeam;
playervar define grappleSphere;

void EndGrapple() playervar "[Sub] :: End Grapple"
{
    usingGrapple = false;
    StopForcingThrottle();
    DestroyEffect(grappleSphere);
    DestroyEffect(grappleBeam);

    grappleHitPlayer = null;
}

rule: "[Grapple] :: Grapple Start"
Event.OngoingPlayer
if (matchStarted)
if (grappleEnabled)
if (IsAbility2Held())
{
    grappleHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * GRAPPLE_RANGE, AllLivingPlayers(), player);
    grappleHitPlayer = RayCastHitPlayer(EyePosition(), EyePosition() + Facing() * GRAPPLE_RANGE, AllLivingPlayers(), player, true);
    define grappleEyePos = EyePosition();

    CreateBeamEffect(all, BeamType.GrappleBeam, player, grappleHitPlayer ? grappleHitPlayer : grappleHit, Color.Yellow, EffectRev.VisibleToPositionAndRadius);
    grappleBeam = LastCreatedEntity();

    if (DistanceBetween(grappleEyePos, grappleHit) < GRAPPLE_RANGE && DistanceBetween(player, grappleHit) > 3) // grapple hit
    {
        CreateEffect(all, Effect.Sphere, Color.Yellow, grappleHitPlayer ? grappleHitPlayer : grappleHit, 0.2);
        grappleSphere = LastCreatedEntity();

        PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, grappleHit, 0.2);
        PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, player, 0.33);
        PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 100);

        usingGrapple = true;
    }
    else // grapple miss
    {
        Wait(0.25);
        EndGrapple();
    }

    Wait(0.5);
    LoopIf(IsAbility2Held() && IsAlive() && !usingGrapple);
}

rule: "[Grapple] :: Pull"
Event.OngoingPlayer
if (usingGrapple)
{
    ForceThrottle(player, 0, 0.05, 0, 0.05, 0, 0.05);

    if (grappleHitPlayer && IsAlive(grappleHitPlayer))
        ApplyImpulse(grappleHitPlayer, Vector(0, 0.3, 0) + DirectionTowards(grappleHitPlayer, EyePosition()), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);
    else if (IsJumpHeld()) // push the player upwards more if they are holding jump
        ApplyImpulse(player, Vector(0, 0.3, 0) + DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);
    else // pull inpulse
        ApplyImpulse(player, DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);

    Wait(0.064);
    LoopIfConditionIsTrue();
}

rule: "[Grapple] :: Grapple End Ability 2"
Event.OngoingPlayer
if (!IsAbility2Held())
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End On Death"
Event.OnDeath
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End Grappled Player Dead"
Event.OngoingPlayer
if (IsDead(grappleHitPlayer))
{
    EndGrapple();
}

globalvar define grappleOption;

rule: "[Grapple] :: Grapple End: Grappled Player Too Close"
Event.OngoingPlayer
if (grappleOption[0])
if (DistanceBetween(player, grappleHitPlayer) < 3)
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Too Close"
Event.OngoingPlayer
if (grappleOption[0] && DistanceBetween(player, grappleHit) < 3)
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Player Out of LOS"
Event.OngoingPlayer
if (grappleOption[1])
if (!IsInLineOfSight(player, grappleHitPlayer))
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Hit Position Out of LOS"
Event.OngoingPlayer
if (grappleOption[1]) 
if (!IsInLineOfSight(player, grappleHit))
{
    WaitIfTrue(0.25);
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Grappled Player out of view angle"
Event.OngoingPlayer
if (grappleOption[1])
if (!IsInViewAngle(player, grappleHitPlayer, 105))
{
    EndGrapple();
}

rule: "[Grapple] :: Grapple End: Grapple Hit out of view angle"
Event.OngoingPlayer
if (grappleOption[1])
if (!IsInViewAngle(player, grappleHit, 120))
{
    WaitIfTrue(0.25);
    EndGrapple();
}

disabled rule: "---------------- Buff ----------------"{}

globalvar define sphereInProgressEffect;
globalvar define wallbangPBar;
globalvar define ricochetPBar;
globalvar define buckshotPBar;
globalvar define lockPBar;
globalvar define vaporizerPBar;
globalvar define wallbangTimer;
globalvar define ricochetTimer;
globalvar define buckshotTimer;
globalvar define lockTimer;
globalvar define vaporizerTimer;

void WallbangCooldown() "[Sub] :: Wallbang Cooldown" 
{
    if (!spawnWithWallbang && spawnWallbang)
    {
        if (!EntityExists(buffUser[0]) && wallbangCD == 0)
                wallbangCD = WALLBANG_CD;

        if (wallbangCD == WALLBANG_CD)
        {
            LogToInspector("Wallbang cooldown started");
            wallbangPBar = 0;
            wallbangTimer = true;

            if (cdType == 0)
                ChaseVariableOverTime(wallbangPBar, 100, WALLBANG_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphereInProgressEffect[0]);
        DestroyProgressBarInWorldText(cdText[0]);
        DestroyInWorldText(cdText[0]);

        MinWait();

        if (cdIP && cdType != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Yellow, buffPos[0], wallbangPBar * 0.004, EffectRev.PositionAndRadius);
            sphereInProgressEffect[0] = LastCreatedEntity();
        }

        if (cdType == 0)
        {
            CreateProgressBarInWorldText(all, wallbangPBar, null, buffPos[0] + Vector(0, wallbangPBar * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Yellow, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cdText[0] = LastTextID();
        }
        else if (cdType == 1)
        {
            CreateInWorldText(all, wallbangText, buffPos[0], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cdText[0] = LastTextID();
        }
    }
}

void RicochetCooldown() "[Sub] :: Ricochet Cooldown"
{
    if (!spawnWithRicochet && spawnRicochet)
    {
        if (!EntityExists(buffUser[1]) && ricochetCD == 0)
            ricochetCD = RICOCHET_CD;

        if (ricochetCD == RICOCHET_CD)
        {
            LogToInspector("Riochet cooldown started");
            ricochetPBar = 0;
            ricochetTimer = true;

            if (cdType == 0)
                ChaseVariableOverTime(ricochetPBar, 100, RICOCHET_CD, TimeChaseReevaluation.None);
        }
        
        // destroy and recreate the effects, just in case
        DestroyEffect(sphereInProgressEffect[1]);
        DestroyProgressBarInWorldText(cdText[1]);
        DestroyInWorldText(cdText[1]);

        MinWait();

        if (cdIP && cdType != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Violet, buffPos[1], ricochetPBar * 0.004, EffectRev.PositionAndRadius);
            sphereInProgressEffect[1] = LastCreatedEntity();
        }

        if (cdType == 0)
        {
            CreateProgressBarInWorldText(all, ricochetPBar, null, buffPos[1] + Vector(0, ricochetPBar * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Violet, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cdText[1] = LastTextID();
        }
        else if (cdType == 1)
        {
            CreateInWorldText(all, ricochetText, buffPos[1], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cdText[1] = LastTextID();
        }
    }
}

void BuckshotCooldown() "[Sub] :: Buckshot Cooldown"
{
    if (!spawnWithBuckshot && spawnBuckshot)
    {
        if (!EntityExists(buffUser[2]) && buckshotCD == 0)
            buckshotCD = BUCKSHOT_CD;

        if (buckshotCD == BUCKSHOT_CD)
        {
            LogToInspector("Buckshot cooldown started");
            buckshotPBar = 0;
            buckshotTimer = true;

            if (cdType == 0)
                ChaseVariableOverTime(buckshotPBar, 100, BUCKSHOT_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphereInProgressEffect[2]);
        DestroyProgressBarInWorldText(cdText[2]);
        DestroyInWorldText(cdText[2]);

        MinWait();

        if (cdIP && cdType != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Green, buffPos[2], buckshotPBar * 0.004, EffectRev.PositionAndRadius);
            sphereInProgressEffect[2][0] = LastCreatedEntity();
            CreateEffect(all, Effect.GoodAura, Color.Green, buffPos[2], buckshotPBar * 0.004, EffectRev.PositionAndRadius);
            sphereInProgressEffect[2][1] = LastCreatedEntity();
        }

        if (cdType == 0)
        {
            CreateProgressBarInWorldText(all, buckshotPBar, null, buffPos[2] + Vector(0, buckshotPBar * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, CustomColor(0, 255, 0, 255), Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cdText[2] = LastTextID();
        }
        else if (cdType == 1)
        {
            CreateInWorldText(all, buckshotText, buffPos[2], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cdText[2] = LastTextID();
        }
    }
}

void LockCooldown() "[Sub] :: Lock Cooldown"
{
    if (!spawnWithLock && spawnLock)
    {
        if (!EntityExists(buffUser[3]) && lockCD == 0)
            lockCD = LOCK_CD;

        if (lockCD == LOCK_CD)
        {
            LogToInspector("Smart Lock cooldown started");
            lockPBar = 0;
            lockTimer = true;

            if (cdType == 0)
                ChaseVariableOverTime(lockPBar, 100, LOCK_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphereInProgressEffect[3]);
        DestroyProgressBarInWorldText(cdText[3]);
        DestroyInWorldText(cdText[3]);

        MinWait();

        if (cdIP && cdType != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Blue, buffPos[3], lockPBar * 0.004, EffectRev.PositionAndRadius);
            sphereInProgressEffect[3][0] = LastCreatedEntity();
            CreateEffect(all, Effect.GoodAura, Color.Blue, buffPos[3], lockPBar * 0.004, EffectRev.PositionAndRadius);
            sphereInProgressEffect[3][1] = LastCreatedEntity();
        }

        if (cdType == 0)
        {
            CreateProgressBarInWorldText(all, lockPBar, null, buffPos[3] + Vector(0, lockPBar * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, CustomColor(54, 55, 212, 255), Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cdText[3] = LastTextID(); 
        }
        else if (cdType == 1)
        {
            CreateInWorldText(all, lockText, buffPos[3], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cdText[3] = LastTextID(); 
        }
    }
}

void VaporizerCooldown() "[Sub] :: Vaporizer Cooldown"
{
    if (!spawnWithVaporizer && spawnVaporizer)
    {
        if (!EntityExists(buffUser[4]) && vaporizerCD == 0)
            vaporizerCD = VAPORIZER_CD;

        if (vaporizerCD == VAPORIZER_CD)
        {
            LogToInspector("Vaporizer cooldown started");
            vaporizerPBar = 0;
            vaporizerTimer = true;

            if (cdType == 0)
                ChaseVariableOverTime(vaporizerPBar, 100, VAPORIZER_CD, TimeChaseReevaluation.None);
        }
        
        // destroy and recreate the effects, just in case
        DestroyEffect(sphereInProgressEffect[4]);
        DestroyProgressBarInWorldText(cdText[4]);
        DestroyInWorldText(cdText[4]);

        MinWait();

        if (cdIP && cdType != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Rose, buffPos[4], vaporizerPBar * 0.004);
            sphereInProgressEffect[4][0] = LastCreatedEntity();
            CreateEffect(all, Effect.GoodAura, Color.Rose, buffPos[4], vaporizerPBar * 0.004);
            sphereInProgressEffect[4][1] = LastCreatedEntity();
        }

        if (cdType == 0)
        {
            CreateProgressBarInWorldText(all, vaporizerPBar, null, buffPos[4] + Vector(0, vaporizerPBar * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Rose, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cdText[4] = LastTextID();
        }
        else if (cdType == 1)
        {
            CreateInWorldText(all, vaporizerText, buffPos[4], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cdText[4] = LastTextID();
        }
    }
}

void ElectroCooldown() "[Sub] :: Electro Cooldown"
{
    if (!spawnWithElectro && spawnElectro)
    {
        if (!EntityExists(buffUser[5]) && electroCD == 0)
            electroCD = ELECTRO_CD;

        if (electroCD == ELECTRO_CD)
        {
            LogToInspector("Electro cooldown started");
            electroPBar = 0;
            electroTimer = true;

            if (cdType == 0)
                ChaseVariableOverTime(electroPBar, 100, ELECTRO_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphereInProgressEffect[5]);
        DestroyProgressBarInWorldText(cdText[5]);
        DestroyInWorldText(cdText[5]);

        MinWait();

        if (cdIP && cdType != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.SkyBlue, buffPos[5], electroPBar * 0.004, EffectRev.PositionAndRadius);
            sphereInProgressEffect[5] = LastCreatedEntity();
        }

        if (cdType == 0)
        {
            CreateProgressBarInWorldText(all, electroPBar, null, buffPos[5] + Vector(0, electroPBar * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Blue, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cdText[5] = LastTextID();
        }
        else if (cdType == 1)
        {
            CreateInWorldText(all, electroText, buffPos[5], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cdText[5] = LastTextID();
        }
    }
}

void QuadshotCooldown() "[Sub] :: Quadshot Cooldown"
{
    if (!spawnWithQuadshot && spawnQuadshot)
    {
        if (!EntityExists(buffUser[7]) && quadshotCD == 0)
            quadshotCD = QUADSHOT_CD;

        if (quadshotCD == QUADSHOT_CD)
        {
            LogToInspector("Quadshot cooldown started");
            quadshotPBar = 0;
            quadshotTimer = true;

            if (cdType == 0)
                ChaseVariableOverTime(quadshotPBar, 100, QUADSHOT_CD, TimeChaseReevaluation.None);
        }

        // destroy and recreate the effects, just in case
        DestroyEffect(sphereInProgressEffect[7]);
        DestroyProgressBarInWorldText(cdText[7]);
        DestroyInWorldText(cdText[7]);

        MinWait();

        if (cdIP && cdType != 1)
        {
            CreateEffect(all, Effect.Sphere, Color.Orange, buffPos[7], quadshotPBar * 0.004, EffectRev.PositionAndRadius);
            sphereInProgressEffect[7] = LastCreatedEntity();
        }

        if (cdType == 0)
        {
            CreateProgressBarInWorldText(all, quadshotPBar, null, buffPos[7] + Vector(0, quadshotPBar * 0.004, 0), 0, Clipping.ClipAgainstSurfaces, Color.Orange, Color.White, InWorldProgressBarEvaluation.PositionAndValues);
            cdText[7] = LastTextID();
        }
        else if (cdType == 1)
        {
            CreateInWorldText(all, quadshotText, buffPos[7], 2, Clipping.ClipAgainstSurfaces, InworldTextRev.String);
            cdText[7] = LastTextID();
        }
    }
}

globalvar define wallbangText;
globalvar define ricochetText;
globalvar define buckshotText;
globalvar define lockText;
globalvar define vaporizerText;
rule: "[Buff] :: Wallbang Timer"
if (wallbangTimer)
{
    wallbangCD--;

    wallbangText = <"<0><1>", 
                wallbangCD >= 60 
                    ? <"<0>:", RoundToInteger(wallbangCD / 60, Rounding.Down)> 
                    : "", 
                wallbangCD % 60 < 10 && wallbangCD >= 60 
                    ? <"0<0>", wallbangCD % 60>
                    : wallbangCD % 60>;

    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Ricochet Timer"
if (ricochetTimer)
{
    ricochetCD--;

    ricochetText = <"<0><1>", 
                ricochetCD >= 60 
                    ? <"<0>:", RoundToInteger(ricochetCD / 60, Rounding.Down)> 
                    : "", 
                ricochetCD % 60 < 10 && ricochetCD >= 60 
                    ? <"0<0>", ricochetCD % 60>
                    : ricochetCD % 60>;

    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Buckshot Timer"
if (buckshotTimer)
{
    buckshotCD--;

    buckshotText = <"<0><1>", 
                buckshotCD >= 60 
                    ? <"<0>:", RoundToInteger(buckshotCD / 60, Rounding.Down)> 
                    : "", 
                buckshotCD % 60 < 10 && buckshotCD >= 60 
                    ? <"0<0>", buckshotCD % 60>
                    : buckshotCD % 60>;
    
    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Lock Timer"
if (lockTimer)
{
    lockCD--;

    lockText = <"<0><1>", 
                lockCD >= 60 
                    ? <"<0>:", RoundToInteger(lockCD / 60, Rounding.Down)> 
                    : "", 
                lockCD % 60 < 10 && lockCD >= 60 
                    ? <"0<0>", lockCD % 60>
                    : lockCD % 60>;

    Wait(1);
    LoopIfConditionIsTrue();
}

rule: "[Buff] :: Vaporizer Timer"
if (vaporizerTimer)
{
    vaporizerCD--;

    vaporizerText = <"<0><1>", 
                vaporizerCD >= 60 
                    ? <"<0>:", RoundToInteger(vaporizerCD / 60, Rounding.Down)> 
                    : "", 
                vaporizerCD % 60 < 10 && vaporizerCD >= 60 
                    ? <"0<0>", vaporizerCD % 60>
                    : vaporizerCD % 60>;

    Wait(1);
    LoopIfConditionIsTrue();
}

globalvar define quadshotText;
globalvar define quadshotTimer;
rule: "[Buff] :: Quadshot Timer"
if (quadshotTimer)
{
    quadshotCD--;

    quadshotText = <"<0><1>", 
                quadshotCD >= 60 
                    ? <"<0>:", RoundToInteger(quadshotCD / 60, Rounding.Down)> 
                    : "", 
                quadshotCD % 60 < 10 && quadshotCD >= 60 
                    ? <"0<0>", quadshotCD % 60>
                    : quadshotCD % 60>;
    
    Wait(1);
    LoopIfConditionIsTrue();
}


globalvar define electroText;
globalvar define electroTimer;
rule: "[Buff] :: Electro Timer"
if (electroTimer)
{
    electroCD--;

    electroText = <"<0><1>", 
                electroCD >= 60 
                    ? <"<0>:", RoundToInteger(electroCD / 60, Rounding.Down)> 
                    : "", 
                electroCD % 60 < 10 && electroCD >= 60 
                    ? <"0<0>", electroCD % 60>
                    : electroCD % 60>;
    
    Wait(1);
    LoopIfConditionIsTrue();
}

playervar define bIndex;
globalvar define buffColor;
globalvar define collectedBuffEffect;
globalvar define canPickupBuff;
globalvar define buffUser;
// playervar define buffEnabled;

void CollectBuff() playervar "[Sub] :: Collect Buff"
{
    canPickupBuff[bIndex] = false;
    buffUser[bIndex] = player;

    if (bIndex == 0)
    {
        LogToInspector(<"Wallbang Enabled for <0>", buffUser[0]>);
        canPickupBuff[0] = false;
        wallbangEnabled = true;

        // toasts
        CreateProgressBarHudText(player, wallbangDur, <"<0> Wallbang <0>", AbilityIconString(Hero.Baptiste, Button.Ultimate)>, Location.Right, 0.3, CustomColor(255, 255, 0, 255), CustomColor(255, 255, 0, 255));
        hudText[0] = LastTextID();

        BigMessage(player, "Wallbang");
        
        // start timer
        wallbangDur = 100;
        ChaseVariableOverTime(wallbangDur, 0, WALLBANG_DUR, TimeChaseReevaluation.None);
    }
    else if (bIndex == 1)
    {
        LogToInspector(<"Ricochet Enabled for <0>", buffUser[1]>);
        canPickupBuff[1] = false;
        ricochetEnabled = true;

        // toasts
        CreateProgressBarHudText(player, ricochetDur, <"<0> Ricochet <0>", AbilityIconString(Hero.Winston, Button.Ability1)>, Location.Right, 0.4, Color.Violet, Color.Violet);
        hudText[1] = LastTextID();

        BigMessage(player, "Ricochet");
        
        // start timer
        ricochetDur = 100;
        ChaseVariableOverTime(ricochetDur, 0, RICOCHET_DUR, TimeChaseReevaluation.None);
    }
    else if (bIndex == 2)
    {
        LogToInspector(<"Buckshot Enabled for <0>", buffUser[2]>);
        canPickupBuff[2] = false;
        buckshotEnabled = true;

        // toasts
        CreateProgressBarHudText(player, buckshotDur, <"<0> Buckshot <0>", AbilityIconString(Hero.Ashe, Button.Ability1)>, Location.Right, 0.5, CustomColor(0, 255, 0, 255), CustomColor(0, 255, 0, 255));
        hudText[2] = LastTextID();

        BigMessage(player, "Buckshot");

        // start timer
        buckshotDur = 100;
        ChaseVariableOverTime(buckshotDur, 0, BUCKSHOT_DUR, TimeChaseReevaluation.None);
    }
    else if (bIndex == 3)
    {
        LogToInspector(<"Smart Lock Enabled for <0>", buffUser[3]>);
        canPickupBuff[3] = false;
        lockEnabled = true;

        // toasts
        CreateProgressBarHudText(player, lockDur, <"<0> Smart Lock <0>", AbilityIconString(Hero.Sombra, Button.SecondaryFire)>, Location.Right, 0.3, CustomColor(54, 55, 212, 255), CustomColor(54, 55, 212, 255));
        hudText[3] = LastTextID();

        BigMessage(player, "Smart Lock");

        // start timer
        lockDur = 100;
        ChaseVariableOverTime(lockDur, 0, LOCK_DUR, TimeChaseReevaluation.None);
    }
    else if (bIndex == 4)
    {
        LogToInspector(<"Vaporizer Enabled for <0>", buffUser[4]>);
        canPickupBuff[4] = false;
        vaporizerEnabled = true;

        // toasts
        CreateProgressBarHudText(player, vaporizerDur, <"<0> Vaporizer <0>", AbilityIconString(Hero.Symmetra, Button.Ultimate)>, Location.Right, 0.4, Color.Rose, Color.Rose);
        hudText[4] = LastTextID();

        BigMessage(player, "Vaporizer");

        // start timer
        vaporizerDur = 100;
        ChaseVariableOverTime(vaporizerDur, 0, VAPORIZER_DUR, TimeChaseReevaluation.None);
    }
    else if (bIndex == 5)
    {
        LogToInspector(<"Electro Enabled for <0>", buffUser[6]>);
        canPickupBuff[5] = false;
        electroEnabled = true;

        // toasts
        CreateProgressBarHudText(player, electroDur, <"<0> Electro <0>", AbilityIconString(Hero.Echo, Button.SecondaryFire)>, Location.Right, 0.5, Color.Blue, Color.Blue);
        hudText[5][0] = LastTextID();
        CreateHudText(player, null, <"Press <0> to fire sticky mines                                                          ", InputBindingString(Button.Reload)>, null, Location.Right, 0.51, Color.SkyBlue, Color.SkyBlue, Color.SkyBlue);
        hudText[5][1] = LastTextID();

        BigMessage(player, "Electro");

        // start timer
        electroDur = 100;
        ChaseVariableOverTime(electroDur, 0, ELECTRO_DUR, TimeChaseReevaluation.None);
    }
    else if (bIndex == 6)
    {
        LogToInspector(<"Spark Enabled for <0>", buffUser[6]>);
        canPickupBuff[6] = false;
        // sparkEnabled = true;

        // toasts
        // CreateProgressBarHudText(player, sparkDur, <"<0> Spark <0>", AbilityIconString(Hero.Sigma, Button.Ability1)>, Location.Right, 0.6, Color.Purple, Color.Purple);
        hudText[6] = LastTextID();

        BigMessage(player, "Spark");

        // start timer
        // sparkDur = 100;
        // ChaseVariableOverTime(sparkDur, 0, SPARK_DUR, TimeChaseReevaluation.None);
    }
    else if (bIndex == 7)
    {
        LogToInspector(<"Quadshot Enabled for <0>", buffUser[7]>);
        canPickupBuff[7] = false;
        quadshotEnabled = true;

        // toasts
        CreateProgressBarHudText(player, quadshotDur, <"<0> Quadshot <0>", AbilityIconString(Hero.Echo, Button.Ability1)>, Location.Right, 0.7, Color.Orange, Color.Orange);
        hudText[7] = LastTextID();

        BigMessage(player, "Quadshot");

        // start timer
        quadshotDur = 100;
        ChaseVariableOverTime(quadshotDur, 0, QUADSHOT_DUR, TimeChaseReevaluation.None);
    }

    bCnt++; // adds one to the amount of buffs a player has

    // destroy inworld text / icon / orb
    DestroyProgressBarInWorldText(cdText[bIndex]);
    DestroyInWorldText(cdText[bIndex]);
    DestroyEffect(sphereInProgressEffect[bIndex]);
    DestroyEffect(sphereInProgressEffect[bIndex][0]);
    DestroyEffect(sphereInProgressEffect[bIndex][1]);
    DestroyInWorldText(buffIcon[bIndex]);
    DestroyEffect(buffEffect[bIndex]);

    // pickup effects
    PlayEffect(all, PlayEffect.GoodPickupEffect, buffColor, buffPos[bIndex], 1);
    PlayEffect(all, PlayEffect.BuffExplosionSound, buffColor, buffPos[bIndex], 200);

    // create effect
    CreateEffect(IsAlive() ? all : null, Effect.GoodAura, buffColor, player, 0.5, EffectRev.VisibleToPositionAndRadius);
    collectedBuffEffect[bIndex] = LastCreatedEntity();

    bIndex = 99;
    buffColor = null;
}

disabled rule: "---------------- Wallbang ----------------"{}

rule: "[Buff] :: Wallbang : Create Orb"
if (matchStarted)
if (validMap)
if (!spawnWithWallbang)
if (spawnWallbang)
if (wallbangCD == 0)
{
    canPickupBuff[0] = true;
    LogToInspector("Wallbang Orb Created");

    DestroyEffect(sphereInProgressEffect[0]);

    CreateEffect(all, Effect.Orb, Color.Yellow, buffPos[0], 2, EffectRev.None);
    buffEffect[0] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Yellow, buffPos[0], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Baptiste, Button.Ultimate), buffPos[0] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buffIcon[0] = LastTextID();

    DestroyProgressBarInWorldText(cdText[0]);
    DestroyInWorldText(cdText[0]);

    wallbangTimer = false;
    StopChasingVariable(wallbangPBar);
}

rule: "[Buff] :: Wallbang : Collect"
Event.OngoingPlayer
if (hasSpawned)
if (canPickupBuff[0])
if (DistanceBetween(buffPos[0], PositionOf() + Up()) < PICKUP_RAD)
if (IsAlive())
{
    bIndex = 0;
    buffColor = Color.Yellow;
    CollectBuff();

    Wait(WALLBANG_DUR - 4);
    for (define sound; 4; 1)
    {
        PlayEffect(IsAlive() ? all : player, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        Wait(1);
    }
}

rule: "[Buff] :: Wallbang : Remove"
Event.OngoingPlayer
if (wallbangEnabled)
if (wallbangDur == 0)
{
    Wait(0.128);
    LogToInspector(<"Wallbang Disabled for <0>", buffUser[0]>);

    // destroy hud timer and player effect
    DestroyProgressBarHudText(hudText[0]);
    DestroyEffect(collectedBuffEffect[0]);
    StopChasingVariable(wallbangDur);

    all.wallbangEnabled = false;
    wallbangEnabled = false;
    wallbangCD = WALLBANG_CD;

    // start in world cooldown
    WallbangCooldown(); 

    bCnt--;
}

// playervar define whText;
// rule: "[Buff] :: Wallbang : Wallhack"
// Event.OnPlayerJoin
// {
//     CreateInWorldText(FilteredArray(RemoveFromArray(AllLivingPlayers(), player), IsInViewAngle(Curr(), player, 3) && IsAlive() && !IsInLineOfSight(Curr(), EyePosition()) /* && Curr().wallbangEnabled */), 
//     " \n\n\n\n\n\n\n\n\n\n\n\n\n\n◈", player, 2, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, Color.Yellow);
//     whText = LastTextID();
// }

rule: "[Buff] :: Wallbang : Action"
Event.OngoingPlayer
if (wallbangEnabled)
if (IsFiringPrimary())
{
    define gunPos = EyePosition() + Facing() + weaponStart;
    define wallbangHitPos = EyePosition();

    define wallbangHitPlayer;

    for (define i = 0; DistanceBetween(wallbangHitPos, wallbangHitPos) < 100 && i < NUM_WALLBANGS; i++)
    {
        wallbangHitPos = RayCastHitPosition(wallbangHitPos + Facing(), wallbangHitPos + Facing() * (100 - DistanceBetween(wallbangHitPos, wallbangHitPos)), AllLivingPlayers(), player, true);
        wallbangHitPlayer = RayCastHitPlayer(wallbangHitPos, wallbangHitPos + Facing() * (100 - DistanceBetween(wallbangHitPos, wallbangHitPos)), AllLivingPlayers(), player, true);

        PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, wallbangHitPos, 0.2);

        if (wallbangHitPlayer != null && wallbangHitPlayer != player)
        {
            Damage(wallbangHitPlayer, player, 10000);
        }
    }

    CreateBeamEffect(all, BeamType.BadBeam, gunPos, wallbangHitPos, Color.Yellow, EffectRev.None);
    wallbangEffect[0] = LastCreatedEntity();

    Wait(0.25);
    DestroyEffect(wallbangEffect[0]);
}

disabled rule: "---------------- Ricochet ----------------"{}

rule: "[Buff] :: Ricochet : Create Orb"
if (matchStarted)
if (validMap)
if (!spawnWithRicochet)
if (spawnRicochet)
if (ricochetCD == 0)
{
    LogToInspector("Ricochet Orb Created");
    canPickupBuff[1] = true;

    DestroyEffect(sphereInProgressEffect[1]);

    CreateEffect(all, Effect.Orb, Color.Violet, buffPos[1], 2, EffectRev.None);
    buffEffect[1] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Violet, buffPos[1], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Winston, Button.Ability1), buffPos[1] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buffIcon[1] = LastTextID();

    DestroyProgressBarInWorldText(cdText[1]);
    DestroyInWorldText(cdText[1]);

    ricochetTimer = false;
    StopChasingVariable(ricochetPBar);
}

rule: "[Buff] :: Ricochet : Collect"
Event.OngoingPlayer
if (hasSpawned)
if (canPickupBuff[1])
if (DistanceBetween(buffPos[1], PositionOf() + Up()) < PICKUP_RAD)
if (IsAlive())
{
    bIndex = 1;
    buffColor = Color.Violet;
    CollectBuff();

    Wait(RICOCHET_DUR - 4);
    for (define sound; 4; 1)
    {
        PlayEffect(IsAlive() ? all : player, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        Wait(1);
    }
}

rule: "[Buff] :: Ricochet : Remove"
Event.OngoingPlayer
if (ricochetEnabled)
if (ricochetDur == 0)
{
    Wait(0.128);
    LogToInspector(<"Riochet Disabled for <0>", buffUser[1]>);
    // destroy hud timer and player effect
    DestroyProgressBarHudText(hudText[1]);
    DestroyEffect(collectedBuffEffect[1]);

    StopChasingVariable(ricochetDur);

    all.ricochetEnabled = false;
    ricochetEnabled = false;
    ricochetCD = RICOCHET_CD;

    // start in world cooldown
    RicochetCooldown(); 

    bCnt--;
}


rule: "[Buff] :: Ricochet : Action"
Event.OngoingPlayer
if (ricochetEnabled)
if (IsFiringPrimary())
{
    define normals = [];
    define hitPos = [];
    define hitPosPlayer = [];
    define ricochets = [];
    define hitPosRicochets = [];
    define hitPosPlayerRicochets = [];
    define ricochetEffects = [];
    define ricochetEffect = [];

    eyePos = EyePosition()/*  + Facing() + weaponStart */;
    facing = Facing();

    define startPos = weaponStart;
    define firstHitPos = RayCastHitPosition(eyePos, eyePos + facing * 100, AllLivingPlayers(), player, true);

    CreateBeamEffect(all, BeamType.BadBeam, eyePos + facing + startPos, firstHitPos, Color.Violet, EffectRev.None);
    ricochetEffect = LastCreatedEntity();

    for (define i = 0; i < NUM_RICOCHETS; i++)
    {
        if (i > 0)
        {
            eyePos = hitPos[i - 1];
            facing = ricochets[i - 1];
        }

        # https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector
        normals[i] = RayCastHitNormal(eyePos, eyePos + facing * 100, AllLivingPlayers(), player, true);
        hitPos[i] = RayCastHitPosition(eyePos, eyePos + facing * 100, AllLivingPlayers(), player, true);
        hitPosPlayer[i] = RayCastHitPlayer(eyePos, eyePos + facing * 100, AllLivingPlayers(), player, true);
        # integer is how 'strong' the reflection vector is, too low and it will 'run' along surfaces, too high and it does the opposite
        ricochets[i] = facing - (2 * (normals[i] * DotProduct(facing, normals[i])));
        hitPosRicochets[i] = RayCastHitPosition(hitPos[i], hitPos[i] + ricochets[i] * 100, AllLivingPlayers(), player, true);
        hitPosPlayerRicochets[i] = RayCastHitPlayer(hitPos[i], hitPos[i] + ricochets[i] * 100, AllLivingPlayers(), player, true);

        // CreateBeamEffect(all, BeamType.BadBeam, eyePos, hitPos[i], Color.Violet, EffectRev.None); // first raycast hit
        // ricochetEffect[i] = LastCreatedEntity();

        CreateBeamEffect(all, BeamType.BadBeam, hitPos[i], hitPosRicochets[i], Color.Violet, EffectRev.None); // ricochets
        ricochetEffects[i] = LastCreatedEntity();

        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, hitPos[i], 0.2); // first raycast hit
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, hitPosRicochets[i], 0.2); // ricochets

        Damage(hitPosPlayer[i], player, 10000);
        Damage(hitPosPlayerRicochets[i], player, 10000);
    }

    Wait(0.25);
    DestroyEffect(ricochetEffect);
    for (define i = 0; i < NUM_RICOCHETS; i++)
    {
        // DestroyEffect(ricochetEffect[i]);
        DestroyEffect(ricochetEffects[i]);
    }
}

disabled rule: "---------------- Buckshot ----------------"{}

rule: "[Buff] :: Buckshot : Create Orb"
if (matchStarted)
if (validMap)
if (!spawnWithBuckshot)
if (spawnBuckshot)
if (buckshotCD == 0)
{
    LogToInspector("Buckshot Orb Created");
    canPickupBuff[2] = true;

    DestroyEffect(sphereInProgressEffect[2][0]);

    CreateEffect(all, Effect.Orb, Color.Green, buffPos[2], 2, EffectRev.None);
    buffEffect[2] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Green, buffPos[2], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Ashe, Button.Ability1), buffPos[2] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buffIcon[2] = LastTextID();

    DestroyProgressBarInWorldText(cdText[2]);
    DestroyInWorldText(cdText[2]);

    buckshotTimer = false;
    StopChasingVariable(buckshotPBar);
}

rule: "[Buff] :: Buckshot : Collect"
Event.OngoingPlayer
if (hasSpawned)
if (canPickupBuff[2])
if (DistanceBetween(buffPos[2], PositionOf() + Up()) < PICKUP_RAD)
if (IsAlive())
{
    bIndex = 2;
    buffColor = Color.Green;
    CollectBuff();

    Wait(BUCKSHOT_DUR - 4);
    for (define sound; 4; 1)
    {
        PlayEffect(IsAlive() ? all : player, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        Wait(1);
    }
}

rule: "[Buff] :: Buckshot : Remove"
Event.OngoingPlayer
if (buckshotEnabled)
if (buckshotDur == 0)
{
    Wait(0.128);

    LogToInspector(<"Buckshot Disabled for <0>", buffUser[2]>);

    // destroy hud timer and player effect
    DestroyProgressBarHudText(hudText[2]);
    DestroyEffect(collectedBuffEffect[2]);

    StopChasingVariable(buckshotDur);

    all.buckshotEnabled = false;
    buckshotEnabled = false;
    buckshotCD = BUCKSHOT_CD;

    // start in world cooldown
    BuckshotCooldown(); 

    bCnt--;
}

rule: "[Buff] :: Buckshot : Action"
Event.OngoingPlayer
if (buckshotEnabled)
if (IsFiringPrimary())
{
    define buckshotHitPos = [];
    define buckshotHitPlayer = [];
    define gunPos = weaponStart;
    define buckshotBeam = [];
    define centerBeam;

    define bsSpreadDiag = BUCKSHOT_SPREAD - (BUCKSHOT_SPREAD * 0.33);
    define bsSpreadHori = BUCKSHOT_SPREAD;

    // center
    define buckshotCenter = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);

    // lower left
    buckshotHitPos[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bsSpreadDiag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bsSpreadDiag) 
    * 100, AllLivingPlayers(), player, false);

    // upper left
    buckshotHitPos[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bsSpreadDiag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bsSpreadDiag) 
    * 100, AllLivingPlayers(), player, false);

    // lower right
    buckshotHitPos[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bsSpreadDiag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bsSpreadDiag) 
    * 100, AllLivingPlayers(), player, false);

    // upper right
    buckshotHitPos[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bsSpreadDiag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bsSpreadDiag) 
    * 100, AllLivingPlayers(), player, false);

    // lower mid 
    buckshotHitPos[4] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bsSpreadHori) 
    * 100, AllLivingPlayers(), player, false);

    // upper mid 
    buckshotHitPos[5] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bsSpreadHori) 
    * 100, AllLivingPlayers(), player, false);

    // mid left 1
    buckshotHitPos[6] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bsSpreadHori) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    * 100, AllLivingPlayers(), player, false);

    // mid right 1
    buckshotHitPos[7] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bsSpreadHori) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    * 100, AllLivingPlayers(), player, false);

    // // mid left 2
    // buckshotHitPos[8] = RayCastHitPosition(EyePosition(), EyePosition() + 
    // WorldVectorOf(Vector(TangentFromDegrees(2 * bsSpreadHori) * 100, 0, 0), player) + 
    // DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    // * 100, AllLivingPlayers(), player, false);

    // // mid left 3
    // buckshotHitPos[9] = RayCastHitPosition(EyePosition(), EyePosition() + 
    // WorldVectorOf(Vector(TangentFromDegrees(3 * bsSpreadHori) * 100, 0, 0), player) + 
    // DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    // * 100, AllLivingPlayers(), player, false);

    // // mid right 2
    // buckshotHitPos[10] = RayCastHitPosition(EyePosition(), EyePosition() + 
    // WorldVectorOf(Vector(TangentFromDegrees(2 * -bsSpreadHori) * 100, 0, 0), player) + 
    // DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    // * 100, AllLivingPlayers(), player, false);

    // // mid right 3
    // buckshotHitPos[11] = RayCastHitPosition(EyePosition(), EyePosition() + 
    // WorldVectorOf(Vector(TangentFromDegrees(3 * -bsSpreadHori) * 100, 0, 0), player) + 
    // DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    // * 100, AllLivingPlayers(), player, false);

    ////////////
    // player //
    ////////////

    // lower left
    buckshotHitPlayer[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bsSpreadDiag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bsSpreadDiag) 
    * 100, AllLivingPlayers(), player, false);

    // upper left
    buckshotHitPlayer[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bsSpreadDiag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bsSpreadDiag) 
    * 100, AllLivingPlayers(), player, false);

    // lower right
    buckshotHitPlayer[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bsSpreadDiag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bsSpreadDiag) 
    * 100, AllLivingPlayers(), player, false);

    // upper right
    buckshotHitPlayer[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bsSpreadDiag) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bsSpreadDiag) 
    * 100, AllLivingPlayers(), player, false);

    // lower mid 
    buckshotHitPlayer[4] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + bsSpreadHori) 
    * 100, AllLivingPlayers(), player, false);

    // upper mid
    buckshotHitPlayer[5] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - bsSpreadHori) 
    * 100, AllLivingPlayers(), player, false);

    // mid left 1
    buckshotHitPlayer[6] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(bsSpreadHori) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    * 100, AllLivingPlayers(), player, false);

    // mid right 1
    buckshotHitPlayer[7] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-bsSpreadHori) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    * 100, AllLivingPlayers(), player, false);

    // // mid left 2
    // buckshotHitPlayer[8] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    // WorldVectorOf(Vector(TangentFromDegrees(2 * bsSpreadHori) * 100, 0, 0), player) + 
    // DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    // * 100, AllLivingPlayers(), player, false);

    // // mid left 3
    // buckshotHitPlayer[9] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    // WorldVectorOf(Vector(TangentFromDegrees(3 * bsSpreadHori) * 100, 0, 0), player) + 
    // DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    // * 100, AllLivingPlayers(), player, false);

    // // mid right 2
    // buckshotHitPlayer[10] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    // WorldVectorOf(Vector(TangentFromDegrees(2 * -bsSpreadHori) * 100, 0, 0), player) + 
    // DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    // * 100, AllLivingPlayers(), player, false);

    // // mid right 3
    // buckshotHitPlayer[11] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    // WorldVectorOf(Vector(TangentFromDegrees(3 * -bsSpreadHori) * 100, 0, 0), player) + 
    // DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
    // * 100, AllLivingPlayers(), player, false);
    
    PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotCenter, 0.2);

    CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotCenter, Color.Green, EffectRev.None);
    centerBeam = LastCreatedEntity();

    for (define p = 0; p < 8; p++)
    {
        Damage(buckshotHitPlayer[p], player, 10000);

        PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotHitPos[p], 0.2);

        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotHitPos[p], Color.Green, EffectRev.None);
        buckshotBeam[p] = LastCreatedEntity();
    }

    Wait(0.25);
    DestroyEffect(centerBeam);

    for (define beams = 0; beams < 8; beams++)
    {
        DestroyEffect(buckshotBeam[beams]);
    }
}

disabled rule: "---------------- Smart Lock ----------------"{}

rule: "[Buff] :: Smart Lock : Create Orb"
if (matchStarted)
if (validMap)
if (!spawnWithLock)
if (spawnLock)
if (lockCD == 0)
{
    canPickupBuff[3] = true;

    DestroyEffect(sphereInProgressEffect[3][0]);

    CreateEffect(all, Effect.Orb, Color.Blue, buffPos[3], 2, EffectRev.None);
    buffEffect[3] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Blue, buffPos[3], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Sombra, Button.SecondaryFire), buffPos[3] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buffIcon[3] = LastTextID();

    DestroyProgressBarInWorldText(cdText[3]);
    DestroyInWorldText(cdText[3]);

    lockTimer = false;
    StopChasingVariable(lockPBar);
}

rule: "[Buff] :: Smart Lock : Collect"
Event.OngoingPlayer
if (hasSpawned)
if (canPickupBuff[3])
if (DistanceBetween(buffPos[3], PositionOf() + Up()) < PICKUP_RAD)
if (IsAlive())
{
    bIndex = 3;
    buffColor = Color.Blue;
    CollectBuff();

    Wait(LOCK_DUR - 4);
    for (define sound; 4; 1)
    {
        PlayEffect(IsAlive() ? all : player, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        Wait(1);
    }
}

rule: "[Buff] :: Smart Lock : Remove"
Event.OngoingPlayer
if (lockEnabled)
if (lockDur == 0)
{
    Wait(0.128);

    LogToInspector(<"Smart Lock Disabled for <0>", buffUser[3]>);

    // destroy hud timer and player effect
    DestroyProgressBarHudText(hudText[3]);
    DestroyEffect(collectedBuffEffect[3]);

    StopChasingVariable(lockDur);

    all.lockEnabled = false;
    lockEnabled = false;
    lockCD = LOCK_CD;

    // start in world cooldown
    LockCooldown(); 

    bCnt--;
}


globalvar define LOCK_RADIUS;
globalvar define LOCK_TIME;
playervar define lockingTargets;
playervar define lockedTargets;
playervar define lockId;
playervar define lockingId;

// symbols:
// locked: ▣
// not locked: □

rule: "[Buff] :: Smart Lock : Lock Text"
Event.OnPlayerJoin
{
    lockingTargets = RemoveFromArray(all, player);

    // locking text
    CreateInWorldText(FilteredArray(RemoveFromArray(AllLivingPlayers(), player), Curr().lockEnabled && ArrayContains(Curr().lockingTargets, player)), 
    " \n\n\n\n\n□", player, 5, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, CustomColor(54, 55, 212, 255));
    lockingId = LastTextID();

    // locked text
    CreateInWorldText(FilteredArray(RemoveFromArray(AllLivingPlayers(), player), Curr().lockEnabled && ArrayContains(Curr().lockedTargets, player)),
    " \n\n\n\n\n▣", player, 5, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor, CustomColor(54, 55, 212, 255));
    lockId = LastTextID();
}

rule: "[Buff] :: Smart Lock : Locking On - Get Players"
Event.OngoingPlayer
if (lockEnabled)
if (IsAlive())
if (CountOf(FilteredArray(RemoveFromArray(AllLivingPlayers(), player), IsAlive(Curr()) && IsInViewAngle(player, Curr(), LOCK_RADIUS) && IsInLineOfSight(player, Curr()))) != CountOf(lockingTargets))
{
    lockingTargets = FilteredArray(RemoveFromArray(AllLivingPlayers(), player), IsAlive(Curr()) && IsInViewAngle(player, Curr(), LOCK_RADIUS) && IsInLineOfSight(player, Curr()));
}

rule: "[Buff] :: Smart Lock : Lock On - Lost Target"
Event.OngoingPlayer
if (lockEnabled)
if (IsAlive())
if (CountOf(lockingTargets) < CountOf(lockedTargets))
{
    MinWait();
    lockedTargets = lockingTargets;
}

rule: "[Buff] :: Smart Lock : Lock On - Found Target"
Event.OngoingPlayer
if (lockEnabled)
if (IsAlive())
if (CountOf(lockingTargets) > CountOf(lockedTargets))
{
    Wait(LOCK_TIME, WaitBehavior.RestartWhenTrue);
    lockedTargets = lockingTargets;
}

rule: "[Buff] :: Smart Lock : Fire Action"
Event.OngoingPlayer
if (lockEnabled)
if (IsFiringPrimary())
{
    define lockHit = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);
    define gunPos = weaponStart;

    PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, lockHit, 0.2);

    CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, lockHit, Color.Blue, EffectRev.None);
    define lockBeam = LastCreatedEntity();

    define lockBeams = [];
    for (define i = 0; i < CountOf(lockedTargets); i++)
    {
        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, lockedTargets[i], Color.Blue, EffectRev.None);
        lockBeams[i] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Blue, lockedTargets[i], 0.2);
        Damage(lockedTargets[i], player, 10000);
    }

    Wait(0.25);
    DestroyEffect(lockBeam);

    for (define i = 0; i < CountOf(lockBeams); i++)
    {
        DestroyEffect(lockBeams[i]);
    }
}

disabled rule: "---------------- Vaporizer ----------------" {}

globalvar define spawnWithVaporizer;
globalvar define spawnVaporizer;
globalvar define vaporizerCD;
globalvar define VAPORIZER_CD;
globalvar define VAPORIZER_DUR;
globalvar define VAPORIZER_DELAY;
playervar define vaporizerEnabled;
playervar define vaporizerDur;
// playervar define vaporizerDurPbar;

rule: "[Buff] :: Vaporizer : Create Orb"
if (matchStarted)
if (validMap)
if (!spawnWithVaporizer)
if (spawnVaporizer)
if (vaporizerCD == 0)
{
    LogToInspector("Vaporizer Orb Created");
    canPickupBuff[4] = true;

    DestroyEffect(sphereInProgressEffect[4][0]);

    CreateEffect(all, Effect.Orb, Color.Rose, buffPos[4], 2, EffectRev.None);
    buffEffect[4] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Rose, buffPos[4], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Symmetra, Button.Ultimate), buffPos[4] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buffIcon[4] = LastTextID();

    DestroyProgressBarInWorldText(cdText[4]);
    DestroyInWorldText(cdText[4]);

    vaporizerTimer = false;
    StopChasingVariable(vaporizerPBar);
}

rule: "[Buff] :: Vaporizer : Collect"
Event.OngoingPlayer
if (hasSpawned)
if (canPickupBuff[4])
if (DistanceBetween(buffPos[4], PositionOf() + Up()) < PICKUP_RAD)
if (IsAlive())
{
    bIndex = 4;
    buffColor = Color.Rose;
    CollectBuff();

    Wait(VAPORIZER_DUR - 4);
    for (define sound; 4; 1)
    {
        PlayEffect(IsAlive() ? all : player, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        Wait(1);
    }
}

rule: "[Buff] :: Vaporizer : Remove"
Event.OngoingPlayer
if (vaporizerEnabled)
if (vaporizerDur == 0)
{
    AllowButton(player, Button.PrimaryFire);
    Wait(0.128);

    LogToInspector(<"Vaporizer Disabled for <0>", buffUser[4]>);

    // destroy hud timer and player effect
    DestroyProgressBarHudText(hudText[4]);
    DestroyEffect(collectedBuffEffect[4]);
    StopChasingVariable(vaporizerDur);

    all.vaporizerEnabled = false;
    vaporizerEnabled = false;
    vaporizerCD = VAPORIZER_CD;

    // start in world cooldown
    VaporizerCooldown(); 

    bCnt--;
}

globalvar define VAPORIZER_ESIZE;
playervar define vaporizerHitPos;
playervar define vaporizerS;
playervar define vaporizerEffect;
playervar define vaporizerIcon;
globalvar define vaporizerUserAffected;
define vaporizerCheck: FilteredArray(vaporizerUserAffected ? AllLivingPlayers() : RemoveFromArray(AllLivingPlayers(), player), (DistanceBetween(Curr(), vaporizerHitPos) <= VAPORIZER_ESIZE) && IsInLineOfSight(Curr(), vaporizerHitPos));

rule: "[Buff] :: Vaporizer : Action"
Event.OngoingPlayer
if (vaporizerEnabled)
if (IsFiringPrimary())
{
    vaporizerHitPos = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);
    define startPos = EyePosition() + Facing() + weaponStart;

    CreateIcon(vaporizerCheck, vaporizerHitPos, Icon.Warning, IconRev.VisibleTo, Color.Rose, true);
    vaporizerIcon = LastCreatedEntity();

    CreateBeamEffect(all, BeamType.BadBeam, startPos, vaporizerHitPos, Color.Rose, EffectRev.None);
    vaporizerEffect[0] = LastCreatedEntity();
    CreateEffect(all, Effect.Orb, Color.Rose, vaporizerHitPos, 1, EffectRev.None);
    vaporizerEffect[1] = LastCreatedEntity();
    CreateEffect(all, Effect.GoodAura, Color.Rose, vaporizerHitPos, vaporizerS);
    vaporizerEffect[2] = LastCreatedEntity();
    CreateEffect(all, Effect.Ring, Color.Rose, vaporizerHitPos, vaporizerS);
    vaporizerEffect[3] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodExplosion, Color.Rose, vaporizerHitPos, 5);

    vaporizerS = 5;
    ChaseVariableOverTime(vaporizerS, 0.5, VAPORIZER_DELAY);

    DisallowButton(player, Button.PrimaryFire);

    Wait(0.25);
    DestroyEffect(vaporizerEffect[0]);

    Wait(VAPORIZER_DELAY - 0.25);
    DestroyIcon(vaporizerIcon);
    AllowButton(player, Button.PrimaryFire);

    StopChasingVariable(vaporizerS);

    DestroyEffect(vaporizerEffect[1]);
    DestroyEffect(vaporizerEffect[2]);
    DestroyEffect(vaporizerEffect[3]);

    PlayEffect(all, PlayEffect.GoodExplosion, Color.Rose, vaporizerHitPos, VAPORIZER_ESIZE);
    PlayEffect(all, PlayEffect.ExplosionSound, Position: vaporizerHitPos, Radius: 200);

    define players = vaporizerCheck;
    for (define i = 0; i < CountOf(players); i++)
    {
        Damage(players[i], player, 10000);
    }
}

disabled rule: "---------------- Quadshot ----------------"{}

globalvar define spawnQuadshot;
globalvar define spawnWithQuadshot;
globalvar define quadshotCD;
globalvar define QUADSHOT_CD;
globalvar define QUADSHOT_DUR;
globalvar define QUADSHOT_SPREAD;
globalvar define quadshotPBar;

playervar define quadshotEnabled;
playervar define quadshotDur;


rule: "[Buff] :: Quadshot : Create Orb"
if (matchStarted)
if (validMap)
if (!spawnWithQuadshot)
if (spawnQuadshot)
if (quadshotCD == 0)
{
    LogToInspector("Quadshot Orb Created");
    canPickupBuff[7] = true;

    DestroyEffect(sphereInProgressEffect[7]);

    CreateEffect(all, Effect.Orb, Color.Orange, buffPos[7], 2, EffectRev.None);
    buffEffect[7] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Orange, buffPos[7], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Echo, Button.Ability1), buffPos[7] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buffIcon[7] = LastTextID();

    DestroyProgressBarInWorldText(cdText[7]);
    DestroyInWorldText(cdText[7]);

    quadshotTimer = false;
    StopChasingVariable(quadshotPBar);
}

rule: "[Buff] :: Quadshot : Collect"
Event.OngoingPlayer
if (hasSpawned)
if (canPickupBuff[7])
if (DistanceBetween(buffPos[7], PositionOf() + Up()) < PICKUP_RAD)
if (IsAlive())
{
    bIndex = 7;
    buffColor = Color.Orange;
    CollectBuff();

    Wait(QUADSHOT_DUR - 4);
    for (define sound; 4; 1)
    {
        PlayEffect(IsAlive() ? all : player, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        Wait(1);
    }
}

rule: "[Buff] :: Quadshot : Remove"
Event.OngoingPlayer
if (quadshotEnabled)
if (quadshotDur == 0)
{
    Wait(0.128);

    LogToInspector(<"Quadshot Disabled for <0>", buffUser[7]>);

    // destroy hud timer and player effect
    DestroyProgressBarHudText(hudText[7]);
    DestroyEffect(collectedBuffEffect[7]);

    StopChasingVariable(quadshotDur);

    all.quadshotEnabled = false;
    quadshotEnabled = false;
    quadshotCD = QUADSHOT_CD;

    // start in world cooldown
    QuadshotCooldown(); 

    bCnt--;
}

rule: "[Buff] :: Quadshot : Action"
Event.OngoingPlayer
if (quadshotEnabled)
if (IsFiringPrimary())
{
    define quadshotHitPos = [];
    define quadshotHitPlayer = [];
    define gunPos = weaponStart;
    define quadshotBeam = [];
    define centerBeam;

    // center
    define quadshotCenter = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);

    // upper left
    quadshotHitPos[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // upper right
    quadshotHitPos[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // lower left
    quadshotHitPos[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // lower right
    quadshotHitPos[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    ////////////
    // player //
    ////////////

    // upper left
    quadshotHitPlayer[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // upper right
    quadshotHitPlayer[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // lower left
    quadshotHitPlayer[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    // lower right
    quadshotHitPlayer[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
    WorldVectorOf(Vector(TangentFromDegrees(-QUADSHOT_SPREAD) * 100, 0, 0), player) + 
    DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + QUADSHOT_SPREAD) 
    * 100, AllLivingPlayers(), player, false);

    CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, quadshotCenter, Color.Orange, EffectRev.None);
    centerBeam = LastCreatedEntity();

    for (define p = 0; p < 4; p++)
    {
        Damage(quadshotHitPlayer[p], player, 10000);

        PlayEffect(all, PlayEffect.GoodExplosion, Color.Orange, quadshotHitPos[p], 0.2);

        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, quadshotHitPos[p], Color.Orange, EffectRev.None);
        quadshotBeam[p] = LastCreatedEntity();
    }

    PlayEffect(all, PlayEffect.GoodExplosion, Color.Orange, quadshotCenter, 0.2);

    Wait(0.25);
    DestroyEffect(centerBeam);

    for (define b = 0; b < 4; b++)
    {
        DestroyEffect(quadshotBeam[b]);
    }
}

disabled rule: "---------------- Electro ----------------"{}

rule: "[Buff] :: Electro : Create Orb"
if (matchStarted)
if (validMap)
if (!spawnWithElectro)
if (spawnElectro)
if (electroCD == 0)
{
    LogToInspector("Electro Orb Created");
    canPickupBuff[5] = true;

    DestroyEffect(sphereInProgressEffect[5]);

    CreateEffect(all, Effect.Orb, Color.SkyBlue, buffPos[5], 2, EffectRev.None);
    buffEffect[5] = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodPickupEffect, Color.SkyBlue, buffPos[5], 1);

    CreateInWorldText(all, AbilityIconString(Hero.Echo, Button.SecondaryFire), buffPos[5] + Vector(0, 0.4, 0), 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToAndPosition);
    buffIcon[5] = LastTextID();

    DestroyProgressBarInWorldText(cdText[5]);
    DestroyInWorldText(cdText[5]);

    electroTimer = false;
    StopChasingVariable(electroPBar);
}

rule: "[Buff] :: Electro : Collect"
Event.OngoingPlayer
if (hasSpawned)
if (canPickupBuff[5])
if (DistanceBetween(buffPos[5], PositionOf() + Up()) < PICKUP_RAD)
if (IsAlive())
{
    bIndex = 5;
    buffColor = Color.SkyBlue;
    CollectBuff();

    Wait(ELECTRO_DUR - 4);
    for (define sound; 4; 1)
    {
        PlayEffect(IsAlive() ? all : player, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        Wait(1);
    }
}

rule: "[Buff] :: Electro : Remove"
Event.OngoingPlayer
if (electroEnabled)
if (electroDur == 0)
{
    Wait(0.128);

    LogToInspector(<"Electro Disabled for <0>", buffUser[5]>);

    // destroy hud timer and player effect
    DestroyProgressBarHudText(hudText[5][0]);
    DestroyHudText(hudText[5][1]);
    DestroyEffect(collectedBuffEffect[5]);

    StopChasingVariable(electroDur);

    all.electroEnabled = false;
    electroEnabled = false;
    electroCD = ELECTRO_CD;

    // start in world cooldown
    ElectroCooldown(); 

    bCnt--;
}
globalvar define ELECTRO_ESIZE;
playervar define electroHitPos;
playervar define electroEffect;
rule: "[Buff] :: Electro : Action - Primary"
Event.OngoingPlayer
if (electroEnabled)
if (IsFiringPrimary())
{
    electroHitPos = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, AllLivingPlayers(), player);
    define startPos = EyePosition() + Facing() + weaponStart;

    CreateBeamEffect(all, BeamType.BadBeam, startPos, electroHitPos, Color.SkyBlue, EffectRev.None);
    electroEffect = LastCreatedEntity();

    PlayEffect(all, PlayEffect.GoodExplosion, Color.SkyBlue, electroHitPos, ELECTRO_ESIZE);

    define players = FilteredArray(RemoveFromArray(AllLivingPlayers(), player), DistanceBetween(Curr(), electroHitPos) <= ELECTRO_ESIZE && IsInLineOfSight(electroHitPos, Curr()));
    for (define i = 0; i < CountOf(players); i++)
    {
        Damage(players[i], player, 10000);
    }

    if (minesPlaced &&
        (DistanceBetween(electroHitPos, electroMHitPos[0]) <= ELECTRO_ESIZE + 0.275 || 
        DistanceBetween(electroHitPos, electroMHitPos[1]) <= ELECTRO_ESIZE + 0.275 || 
        DistanceBetween(electroHitPos, electroMHitPos[2]) <= ELECTRO_ESIZE + 0.275))
    {
        ExplodeMine();
    }

    Wait(0.25);
    DestroyEffect(electroEffect);
}

globalvar define ELECTRO_PSPEED;
globalvar define ELECTRO_MESIZE;
playervar define electroEyePos1;
playervar define electroEyePos2;
playervar define electroEyePos3;
playervar define electroMHitPos;
playervar define electroMEffect;
rule: "[Buff] :: Electro : Action - Launch Sticky Mines"
Event.OngoingPlayer
if (electroEnabled)
if (!minesPlaced)
if (IsReloadHeld())
{
    mineColor = Color.Blue;

    // first mine //
    electroMHitPos[0] = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, null);
    PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 50);

    DestroyEffect(electroMEffect[0][0]);
    DestroyEffect(electroMEffect[0][1]);

    electroEyePos1 = EyePosition();

    CreateEffect(all, Effect.Sphere, mineColor, electroEyePos1, 0.20);
    electroMEffect[0][0] = LastCreatedEntity();
    CreateEffect(all, Effect.GoodAura, mineColor, electroEyePos1, 0.275);
    electroMEffect[0][1] = LastCreatedEntity();

    ChaseVariableAtRate(electroEyePos1, electroMHitPos[0], ELECTRO_PSPEED, RateChaseReevaluation.DestinationAndRate);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Wait(0.2);

    // second mine //
    electroMHitPos[1] = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, null);
    PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 50);

    DestroyEffect(electroMEffect[1][0]);
    DestroyEffect(electroMEffect[1][1]);

    electroEyePos2 = EyePosition();

    CreateEffect(all, Effect.Sphere, mineColor, electroEyePos2, 0.20);
    electroMEffect[1][0] = LastCreatedEntity();
    CreateEffect(all, Effect.GoodAura, mineColor, electroEyePos2, 0.275);
    electroMEffect[1][1] = LastCreatedEntity();

    ChaseVariableAtRate(electroEyePos2, electroMHitPos[1], ELECTRO_PSPEED, RateChaseReevaluation.DestinationAndRate);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Wait(0.2);

    // third mine //
    electroMHitPos[2] = RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100, null);
    PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 50);

    DestroyEffect(electroMEffect[2][0]);
    DestroyEffect(electroMEffect[2][1]);

    electroEyePos3 = EyePosition();

    CreateEffect(all, Effect.Sphere, mineColor, electroEyePos3, 0.20);
    electroMEffect[2][0] = LastCreatedEntity();
    CreateEffect(all, Effect.GoodAura, mineColor, electroEyePos3, 0.275);
    electroMEffect[2][1] = LastCreatedEntity();

    ChaseVariableAtRate(electroEyePos3, electroMHitPos[2], ELECTRO_PSPEED, RateChaseReevaluation.DestinationAndRate);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    WaitUntil(DistanceBetween(electroEyePos1, electroMHitPos[0]) < 0.1 && DistanceBetween(electroEyePos2, electroMHitPos[1]) < 0.1 && DistanceBetween(electroEyePos3, electroMHitPos[2]) < 0.1, 9999);
    minesPlaced = true;
    mineColor = Color.SkyBlue;
}

playervar define minesPlaced;
playervar define mineColor;
void ExplodeMine() playervar "[Sub] :: Electro : Action - Explode Mines"
{
    minesPlaced = false;
    define players = [];
    for (define i = 0; i < 3; i++)
    {
        // todo: mines dont explode instantly, they are delayed, only the mine shot explodes instantly
        players[i] = FilteredArray(RemoveFromArray(AllLivingPlayers(), player), DistanceBetween(Curr(), electroMHitPos[i]) <= ELECTRO_MESIZE); // get players per mine
        for (define j = 0; j < CountOf(players[i]); j++)
        {
            Damage(players[i][j], player, 10000); // damage (j) players (i)
        }

        DestroyEffect(electroMEffect[i][0]);
        DestroyEffect(electroMEffect[i][1]);

        PlayEffect(all, PlayEffect.GoodExplosion, Color.SkyBlue, electroMHitPos[i], ELECTRO_MESIZE);
        PlayEffect(all, PlayEffect.ExplosionSound, Position: electroMHitPos[i], Radius: 50);

        electroMHitPos[i] = null;
    }

    mineColor = Color.Blue;
}

rule: "[Buff] :: Electro : Action - Mines Idle"
Event.OngoingPlayer
if (minesPlaced)
{
    WaitIfTrue(ELECTRO_DELAY);
    ExplodeMine();
}

// rule: "[Debug] :: Kill"
//     Event.OngoingPlayer
//     if (player == host && IsInteractHeld())
//     {
//         Kill();
//     }

// rule: "[Debug] :: Hud Text"
// Event.OngoingPlayer
// {
//     CreateHudText(player, null, null, <" \nPos: <0>\nFacing: <1>\nHorizontal Facing Vector: <2>\nThrottle: <3>\nbhopping: <4>\nvalidMap: <5>", 
//     PositionOf(), 
//     FacingDirectionOf(), 
//     DirectionFromAngles(HorizontalFacingAngleOf(), 0), 
//     // horizontalFacingVector,
//     ThrottleOf(), 
//     bhopping, 
//     validMap

//     >, Location.Right, 10);
// }

rule: "[Debug] :: Bots"
Event.OngoingPlayer
if (player == host && IsInteractHeld() && !IsCrouchHeld())
{
    CreateDummyBot(HeroOf(), OppositeTeamOf(TeamOf()), -1, RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100), Facing() * -1);
}

rule: "[Debug] :: Destroy Bots"
Event.OngoingPlayer
if (player == host && IsCrouchHeld() && IsInteractHeld())
{
    DestroyAllDummyBots();
}

// rule: "[Debug] :: Show OW Spawn Points"
// if (matchStarted)
// {
//     for (define i = 0; i < CountOf(SpawnPoints()); i++)
//     {
//         CreateEffect(all, Effect.Ring, Color.White, SpawnPoints()[i], 1, EffectRev.None);
//     }
// }

// rule: "[Debug] :: Bots Hold Left Click"
// Event.OngoingPlayer
// if (IsDummyBot())
// {
//     StartHoldingButton(player, Button.PrimaryFire);
// }

// rule: "[Debug] :: Walls"
// Event.OngoingPlayer
// if (DistanceBetween(player, host) < 20 && IsAlive())
// {
//     StartForcingPlayerOutlines(player != host ? player : null, host, true, Color.Orange, OutlineType.Always);
// }

// rule: "[Debug] :: Remove Walls"
// Event.OngoingPlayer
// if (DistanceBetween(player, host) > 20 || IsDead())
// {
//     StopForcingPlayerOutlines(player, host);
// }

// rule: "[Debug] :: Show startPos"
// Event.OngoingPlayer
// {
//     define startPos;

//     CreateEffect(player, Effect.Sphere, Color.Aqua, startPos, 0.05);

//     while (true)
//     {
//         startPos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.675, 0), player) * 0.13;
//         MinWait();
//     }
// }