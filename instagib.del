import "macros.del";
import "instagibSettings.json";

// bhop
playervar define bhopSpeed;
playervar define speedAccumInAir;
playervar define isChasing;

// primary
playervar define primaryHit;
playervar define primaryStartPos;
// playervar define primaryBeam;

// secondary
playervar define secondaryHit;
playervar define secondaryEyePos;
playervar define secondaryOrb;
playervar define secondaryStartPos;

// grapple
playervar define grappleEyePos;
playervar define grappleBeamEffect;
playervar define usingGrapple;
playervar define grappleHit;
playervar define grappleHitSphere;
playervar define grapplePlayerBeamEffect;
playervar define grappleHitPlayer;
playervar define grappleHitPlayerSphere;

// misc
playervar define livingEnemies;

// constants :: bhop
globalvar define BHOP_MAX_SPEED;
globalvar define BHOP_SPEED_RATE;

// constants :: grapple
globalvar define GRAPPLE_PULL_SPEED;
globalvar define GRAPPLE_RANGE;

// constants :: secondary
globalvar define SECONDARY_PROJECTILE_SPEED;

// constants: misc
globalvar define MATCH_TIME_LIMIT;

// toggle
globalvar define matchStarted;

// dodge
globalvar define DODGE_FORCE;
playervar define throttleOf;
playervar define canDodge;

/////////////////////
/////// buffs ///////
/////////////////////

// global :: workshop settings
globalvar define buffsEnabled;
globalvar define teleEnabled;
globalvar define buffsSpawnImmediately;
// global
globalvar define validMap;
globalvar define buffEffect;
globalvar define buffPos;
globalvar define buffIcon;
globalvar define cdText;
// player
playervar define hudText;
playervar define lifeKills;
playervar define spreeInWorld;
playervar define spreeEffects;
playervar define spreeHud;
playervar define killsHud;

//// wallbang ////

// global :: workshop settings
globalvar define spawnWallbang;
globalvar define spawnWithWallbang;
globalvar define wallbangDbg;
// global :: constants
globalvar define NUM_WALLBANGS;
globalvar define WALLBANG_DUR;
globalvar define WALLBANG_CD;
// global
globalvar define canPickupWallbang;
globalvar define wallbangCD;
globalvar define wallbangUser;
// player
playervar define wallbangEffect;
playervar define wallbangEnabled;
playervar define wallbangDur;
playervar define wallbangBuffEffect;
playervar define wbDbgEffects;
playervar define wbDbgBeam;

//// ricochet ////

// global :: workshop settings
globalvar define spawnRicochet;
globalvar define spawnWithRicochet;
globalvar define ricochetDbg;
// global :: constants
globalvar define NUM_RICOCHETS;
globalvar define RICOCHET_CD;
globalvar define RICOCHET_DUR;
// global
globalvar define canPickupRicochet;
globalvar define ricochetCD;
globalvar define ricochetUser;
// player
playervar define ricochetEnabled;
playervar define ricochetDur;
playervar define ricochetBuffEffect;
playervar define rDbgEffects;
playervar define rDbgBeam;

// logic

playervar define eyePos;
playervar define facing;

//// buckshot ////

// global :: workshop settings
globalvar define spawnBuckshot;
globalvar define spawnWithBuckshot;
globalvar define buckshotDbg;
// global :: constants
globalvar define BUCKSHOT_SPREAD;
globalvar define BUCKSHOT_CD;
globalvar define BUCKSHOT_DUR;
// global
globalvar define canPickupBuckshot;
globalvar define buckshotCD; 
globalvar define buckshotUser;
// player
playervar define buckshotHitPos;
playervar define buckshotHitPlayer;
playervar define buckshotCenter;
playervar define buckshotEnabled;
playervar define buckshotDur;
playervar define buckshotBuffEffect;
playervar define bDbgEffects;
playervar define bDbgBeam;
// logic
globalvar define spreadDiag;
globalvar define spreadHori;

//// extra life ////

// global :: workshop settings
globalvar define spawnLife;
globalvar define spawnWithLife;
// global :: constants
globalvar define LIFE_CD;
globalvar define LIFE_DUR;
// global
globalvar define canPickupLife;
globalvar define lifeCD;
globalvar define lifeUser;
// player
playervar define extraLife;
playervar define extraLifeIcon;
playervar define lifeEnabled;
playervar define lifeBuffEffect;
playervar define lifeDur;

// workshop settings
globalvar define grappleEnabled;
globalvar define dodgeEnabled;
globalvar define secondaryEnabled;
globalvar define primaryFxEnabled;
globalvar define bhopEnabled;

/* ------------------------------------------------------------------------------- todo + notes: -------------------------------------------------------------------------------
todo:
general optimizations
fix buff cooldown in-world disappearing upon player leaving, internal timer doesnt break, only the in-world bar
drop whichever buff(s) the player has upon death (orb(s) will only be up for 20 seconds, then will disappear then use the normal cooldown at its map determined spot)
option for extra lives to "stack"
new buff: wallbang and ricochet properties all within shotgun pellets; will work on this once i figure out a more efficient spread
randomize weapon buff map locations upon match start

random world events: lasts for 30 seconds, has a 2 minute cooldown

low grav
wallhacks
explosive secondary
ratz mode (everyone is 35% scale)

notes:
dont use EntityExists() with effects
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */

disabled rule: "---------------- Main ----------------"{}

rule: "[Main] :: Initial Global"
    {
        // DisableInspectorRecording();
        DisableCompletion();
        DisableAnnouncer();

        CreateHudText(all, null, "Instagib | Created by scort#11221ㅤ", " v1.8.1 | Share Code: APPPXㅤ", Location.Right, 0, Color.White, RainbowColor(), Color.White, HudTextRev.VisibleToSortOrderStringAndColor);
        CreateHudText(all, null, null, " ", Location.Right, 0.1);

        SetMatchTime(10);

        cdText = [];
        buffEffect = [];
        buffPos = [];
        buffIcon = [];
        telePos = [];
        teleFacing = [];

        matchStarted = false;

        primaryFxEnabled = WorkshopSettingToggle("General", "Enable Primary Fire Effects (On)", true, 1);
        buffsSpawnImmediately = WorkshopSettingToggle("General", "​Buffs Spawn Immediately When Match Starts (Off)", false, 2);
        buffsEnabled = WorkshopSettingToggle("General", "​​Spawn Buffs (On)", true, 3);
        teleEnabled = WorkshopSettingToggle("General", "​​Spawn Teleporters (On)", true, 4);
        MATCH_TIME_LIMIT = WorkshopSettingInteger("General", "​Match Time (Minutes) (20)", 20, 1, 60, 5) * 60;

        grappleEnabled = WorkshopSettingToggle("Grapple", "Enable Grappling Hook (On)", true, 1);
        GRAPPLE_PULL_SPEED = WorkshopSettingReal("Grapple", "​​Grapple Pull Speed (3.5)", 3.5, 0.5, 10, 2);
        GRAPPLE_RANGE = WorkshopSettingReal("Grapple", "​​Grapple Range (40)", 40, 3.5, 100, 3);

        secondaryEnabled = WorkshopSettingToggle("Secondary Fire", "Enable Secondary Fire (On)", true, 1);
        SECONDARY_PROJECTILE_SPEED = WorkshopSettingInteger("Secondary Fire", "​​​Secondary Projectile Speed (90)", 90, 10, 500, 2);

        dodgeEnabled = WorkshopSettingToggle("Dodge", "Enable Dodge (On)", true, 1);
        DODGE_FORCE = WorkshopSettingReal("Dodge", "​​​​​Dodge Force (14)", 14, 1, 100, 2);

        bhopEnabled = WorkshopSettingToggle("BHop", "Enable Bhops (On)", true, 1);
        BHOP_MAX_SPEED = WorkshopSettingInteger("BHop", "​Maximum Speed Possible From Hops (320)", 320, 110, 10000, 2);
        BHOP_SPEED_RATE = WorkshopSettingReal("BHop", "​​Speed gain rate (12.5)", 12.5, 1, 100, 3);

        NUM_WALLBANGS = WorkshopSettingInteger("Wallbang", "​Wallbang Amount (5)", 5, 2, 100, 1);
        WALLBANG_CD = WorkshopSettingInteger("Wallbang", "​​Wallbang Spawn Time (65)", 65, 1, 500, 2);
        WALLBANG_DUR = WorkshopSettingInteger("Wallbang", "​​​Wallbang Duration (25)", 25, 1, 500, 3);
        spawnWallbang = WorkshopSettingToggle("Wallbang", "​​​​Spawn Wallbang (On)", true, 4);
        spawnWithWallbang = WorkshopSettingToggle("Wallbang", "​​​​​Spawn With Wallbang (Lasts Forever) (Off)", false, 5);

        RICOCHET_CD = WorkshopSettingInteger("Ricochet", "​Ricochet Spawn Time (55)", 55, 1, 500, 1);
        RICOCHET_DUR = WorkshopSettingInteger("Ricochet", "​​Ricochet Duration (30)", 30, 1, 500, 2);
        NUM_RICOCHETS = WorkshopSettingInteger("Ricochet", "​​​Ricochet Amount (4)", 4, 1, 32, 3);
        spawnRicochet = WorkshopSettingToggle("Ricochet", "​​​​Spawn Ricochet (On)", true, 4);
        spawnWithRicochet = WorkshopSettingToggle("Ricochet", "​​​​​Spawn With Ricochet (Lasts Forever) (Off)", false, 5);

        BUCKSHOT_CD = WorkshopSettingInteger("Buckshot", "​Buckshot Spawn Time (85)", 85, 1, 500, 1);
        BUCKSHOT_DUR = WorkshopSettingInteger("Buckshot", "​​Buckshot Duration (20)", 20, 1, 500, 2);
        BUCKSHOT_SPREAD = WorkshopSettingReal("Buckshot", "​​​Buckshot Spread (Lower is Tighter) (3.5)", 3.5, 0.1, 20, 2);
        spawnBuckshot = WorkshopSettingToggle("Buckshot", "​​​​​Spawn Buckshot (On)", true, 3);
        spawnWithBuckshot = WorkshopSettingToggle("Buckshot", "​​​​​Spawn With Buckshot (Lasts Forever) (Off)", false, 4);

        LIFE_CD = WorkshopSettingInteger("Extra Life", "​Extra Life Spawn Time (95)", 95, 1, 500, 1);
        LIFE_DUR = WorkshopSettingInteger("Extra Life", "​​​Extra Life Duration (45)", 45, 1, 500, 3);
        spawnLife = WorkshopSettingToggle("Extra Life", "​​Spawn Extra Life (On)", true, 2);
        spawnWithLife = WorkshopSettingToggle("Extra Life", "​​​Spawn With Extra Life (Off)", false, 3);

        wallbangDbg = WorkshopSettingToggle("Debug", "Show Wallbang Hits", false, 1);
        ricochetDbg = WorkshopSettingToggle("Debug", "Show Ricochet Hits", false, 2);
        buckshotDbg = WorkshopSettingToggle("Debug", "Show Buckshot Hits", false, 3);

        if (!buffsEnabled)
        {
            spawnWallbang = false;
            spawnRicochet = false;
            spawnBuckshot = false;
            spawnLife = false;
        }
    }

rule: "[Main] :: Player Join"
    Event.OnPlayerJoin
    {
        DisallowButton(player, Button.Ability1);
        DisallowButton(player, Button.Ability2);

        wallbangDur = 100;
        ricochetDur = 100;
        buckshotDur = 100;
        lifeDur = 100;

        hudText = [];
        spreeInWorld = [];
        spreeEffects = [];
        livingEnemies = FilteredArray(EnemyPlayers(), IsAlive(Curr()));

        PreloadHero(player, Hero.Mccree); // no idea if this will actually do anything
    }

rule: "[Main] :: Start Match"
    if (!matchStarted && IsGameInProgress())
    {
        LogToInspector("Match Started");
        SetMatchTime(MATCH_TIME_LIMIT);
        matchStarted = true;

        if (validMap && !buffsSpawnImmediately && buffsEnabled)
        {
            // set values first cuz apparently it doesnt work sometimes :)
            wallbangCD = WALLBANG_CD;
            ricochetCD = RICOCHET_CD;
            buckshotCD = BUCKSHOT_CD;
            lifeCD = LIFE_CD;

            WallbangCooldown();
            RicochetCooldown();
            BuckshotCooldown();
            LifeCooldown();
        }

        if (buffsEnabled && validMap)
        {
            if (!spawnWithWallbang && spawnWallbang)
            {
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Baptiste, Button.Ultimate)>, null, 
                wallbangCD != 0 ? <"<0>", RoundToInteger(wallbangCD, Rounding.Up)> : canPickupWallbang ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", wallbangUser>, 
                Location.Left, 1, Color.Yellow);
            }
            if (!spawnWithRicochet && spawnRicochet)
            {
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Winston, Button.Ability1)>, null,
                ricochetCD != 0 ? <"<0>", RoundToInteger(ricochetCD, Rounding.Up)> : canPickupRicochet ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", ricochetUser>,
                Location.Left, 2, Color.Purple);
            }
            if (!spawnWithBuckshot && spawnBuckshot)
            {
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Ashe, Button.Ability1)>, null,
                buckshotCD != 0 ? <"<0>", RoundToInteger(buckshotCD, Rounding.Up)> : canPickupBuckshot ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", buckshotUser>,
                Location.Left, 3, Color.Green);
            }
            if (!spawnWithLife && spawnLife)
            {
                CreateHudText(all, <"<0>", AbilityIconString(Hero.Mercy, Button.Ability2)>, null,
                lifeCD != 0 ? <"<0>", RoundToInteger(lifeCD, Rounding.Up)> : canPickupLife ? <"<0>", IconString(Icon.Checkmark)> : <"In-Use by <0>", lifeUser>,
                Location.Left, 4, Color.SkyBlue);
            }
            
        }
    }

rule: "[Main] :: Player Spawned"
    Event.OngoingPlayer
    if (HasSpawned() && matchStarted)
    {
        SmallMessage(player, "Welcome!");
        Wait(3);
        SmallMessage(player, <"Holding down <0> will let you gain speed by bunny hopping", InputBindingString(Button.Jump)>);
        Wait(3);
        SmallMessage(player, <"Press <0> to throw out a grappling hook to pull you towards a surface or to pull players towards you", InputBindingString(Button.Ability2)>);
        Wait(3);
        SmallMessage(player, <"Press <0> to fire a projectile that knocks players back, including yourself allowing for extra mobility", InputBindingString(Button.SecondaryFire)>);
        Wait(3);
        SmallMessage(player, <"Press <0> to dodge in any direction", InputBindingString(Button.Ability1)>);
        Wait(3);
        SmallMessage(player, "Lastly, buffs are littered thorughout the map that give you special changes to your weapon. Have fun!");
    }

rule: "[Main] :: Force Respawn"
    Event.OngoingPlayer
    if (IsButtonHeld(player, Button.Jump) && IsDead())
    {
        Respawn();
    }

rule: "[Main] :: Speedometer & Accuracy HUD Text"
    Event.OngoingPlayer
    if (bhopEnabled || BHOP_MAX_SPEED > 100)
    {
        CreateHudText(player, null, null, <" \n<0> M/S\n<1>% Modifier\n \nAccuracy: <2>%", HorizontalSpeedOf(), RoundToInteger(bhopSpeed - 100, Rounding.Up), RoundToInteger(PlayerStat(player, PlayerStat.WeaponAccuracy) * 100, Rounding.Nearest)>, Location.Left, 10);
    }

rule: "[Main] :: End Game"
    if (matchStarted && MatchTime() == 0)
    {
        EnableCompletion();
    }

rule: "[Main] :: Primary Effect"
    Event.OngoingPlayer
    if (primaryFxEnabled && !wallbangEnabled && !ricochetEnabled && !buckshotEnabled && IsFiringPrimary())
    {
        define primaryBeam = [];
        primaryStartPos = WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        primaryHit = RayCastHitPosition(EyePosition(), UpdateEveryFrame(EyePosition() + Facing() * 100), livingEnemies, player);
        
        // PlayEffect(player, PlayEffect.GoodExplosion, Color.Aqua, EyePosition() + Facing() + primaryStartPos, 0.2);
        // PlayEffect(RemoveFromArray(EnemyPlayers(), player), PlayEffect.GoodExplosion, Color.Red, EyePosition() + Facing() + primaryStartPos, 0.2);

        PlayEffect(player, PlayEffect.GoodExplosion, Color.Aqua, primaryHit, 0.2);
        PlayEffect(RemoveFromArray(EnemyPlayers(), player), PlayEffect.GoodExplosion, Color.Red, primaryHit, 0.2);

        CreateBeamEffect(player, BeamType.BadBeam, EyePosition() + Facing() + primaryStartPos, primaryHit, Color.Aqua, EffectRev.None);
        primaryBeam[0] = LastCreatedEntity();
        CreateBeamEffect(RemoveFromArray(EnemyPlayers(), player), BeamType.BadBeam, EyePosition() + Facing() + primaryStartPos, primaryHit, Color.Red, EffectRev.None);
        primaryBeam[1] = LastCreatedEntity();

        Wait(0.15);
        DestroyEffect(primaryBeam[0]);
        DestroyEffect(primaryBeam[1]);
    }


disabled rule: "---------------- Killing Spree Notifs ----------------"{}

rule: "[Killspree] :: Record Kills While Alive"
    Event.OnFinalBlow
    {
        lifeKills++;
    }

rule: "[Killspree] :: Reset Kills on death"
    Event.OnDeath
    {
        DestroyHudText(killsHud);

        if (lifeKills > 5)
        {
            BigMessage(all, !EventWasEnvironment() ? <"<0>'s <1> player spree was ended by <2>!", Victim(), lifeKills, Attacker()> : 
                                                       <"<0>'s <1> player spree was ended by the world!", Victim(), lifeKills>);
            SmallMessage(player, <"<0> player kill spree!", lifeKills>);
        }

        for (define i = 0; i < 7; i++)
        {
            DestroyEffect(spreeEffects[i]);
            DestroyInWorldText(spreeInWorld[i]);
            DestroyHudText(spreeHud[i]);
        }

        Wait(0.032);
        lifeKills = 0;
        spreeInWorld = [];
        spreeEffects = [];
        spreeHud = [];
    }

// @wang - could probably use a subroutine on these killspree rules
// ^ maybe
rule: "[Killspree] :: Killing Spree"
    Event.OnFinalBlow
    if (lifeKills == 6)
    {
        BigMessage(all, <"<0> is on a Killing Spree!", player>);
        CreateInWorldText(player, "Killing Spree!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.White);
        spreeInWorld[0] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.White, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[0] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Killing Spree", Location.Left, 15, Color.White, Color.White, Color.White);
        spreeHud[0] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[0]);
    }

rule: "[Killspree] :: Rampage"
    Event.OnFinalBlow
    if (lifeKills == 8)
    {
        DestroyEffect(spreeEffects[0]);
        DestroyHudText(spreeHud[0]);
        BigMessage(all, <"<0> is on a Rampage!", player>);
        CreateInWorldText(player, "Rampage!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.LimeGreen);
        spreeInWorld[1] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.LimeGreen, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[1] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Rampage", Location.Left, 15, Color.White, Color.White, Color.LimeGreen);
        spreeHud[1] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[1]);
    }

rule: "[Killspree] :: Dominating"
    Event.OnFinalBlow
    if (lifeKills == 11)
    {
        DestroyEffect(spreeEffects[1]);
        DestroyHudText(spreeHud[1]);
        BigMessage(all, <"<0> is Dominating!", player>);
        CreateInWorldText(player, "Dominating!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.SkyBlue);
        spreeInWorld[2] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.SkyBlue, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[2] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Dominating", Location.Left, 15, Color.White, Color.White, Color.SkyBlue);
        spreeHud[2] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[2]);
    }

rule: "[Killspree] :: Unstoppable"
    Event.OnFinalBlow
    if (lifeKills == 14)
    {
        DestroyEffect(spreeEffects[2]);
        DestroyHudText(spreeHud[2]);
        BigMessage(all, <"<0> is Unstoppable!", player>);
        CreateInWorldText(player, "Unstoppable!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Purple);
        spreeInWorld[3] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Violet, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[3] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Unstoppable", Location.Left, 15, Color.White, Color.White, Color.Purple);
        spreeHud[3] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[3]);
    }

rule: "[Killspree] :: Godlike"
    Event.OnFinalBlow
    if (lifeKills == 17)
    {
        DestroyEffect(spreeEffects[3]);
        DestroyHudText(spreeHud[3]);
        BigMessage(all, <"<0> is Godlike!", player>);
        CreateInWorldText(player, "Godlike!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Yellow);
        spreeInWorld[4] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Yellow, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[4] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Godlike", Location.Left, 15, Color.White, Color.White, Color.Yellow);
        spreeHud[4] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[4]);
    }

rule: "[Killspree] :: Divine"
    Event.OnFinalBlow
    if (lifeKills == 21)
    {
        DestroyEffect(spreeEffects[4]);
        DestroyHudText(spreeHud[4]);
        BigMessage(all, <"<0> is Divine!", player>);
        CreateInWorldText(player, "Divine!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Orange);
        spreeInWorld[5] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Orange, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[5] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Divine", Location.Left, 15, Color.White, Color.White, Color.Orange);
        spreeHud[5] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[5]);
    }

rule: "[Killspree] :: Empyreal"
    Event.OnFinalBlow
    if (lifeKills == 24)
    {
        DestroyEffect(spreeEffects[5]);
        DestroyHudText(spreeHud[5]);
        BigMessage(all, <"<0> is Empyreal!", player>);
        CreateInWorldText(player, "Empyreal!", PositionOf(Victim()) + Up(), 3, Clipping.DoNotClip, InworldTextRev.None, Color.Red);
        spreeInWorld[6] = LastTextID();
        CreateEffect(all, Effect.Sparkles, Color.Red, player, 1, EffectRev.VisibleToPositionAndRadius);
        spreeEffects[6] = LastCreatedEntity();
        CreateHudText(player, null, <" \n<0> Kills", lifeKills>, "Empyreal", Location.Left, 15, Color.White, Color.White, Color.Red);
        spreeHud[6] = LastTextID();
        Wait(2);
        DestroyInWorldText(spreeInWorld[6]);
    }

disabled rule: "---------------- Bhop ----------------"{}

rule: "[Bhop] :: Auto Hop"
    Event.OngoingPlayer
    if (bhopEnabled && IsOnGround() && IsJumpHeld())
    {
        DisableJump();
        MinWait();
        AllowJump();
    }

rule: "[Bhop] :: Starting Speed"
    Event.OngoingPlayer
    {
        bhopSpeed = 100;
    }

rule: "[Bhop] :: If Airborne"
    Event.OngoingPlayer
    if (bhopEnabled && (!usingGrapple && IsJumping() && HorizontalSpeedOf() > 5.14) || (usingGrapple && IsInAir() && DistanceBetween(grappleEyePos, grappleHit) < GRAPPLE_RANGE))
    {
        speedAccumInAir = HorizontalSpeedOf();
        Wait(0.05);
        ChaseVariableAtRate(bhopSpeed, BHOP_MAX_SPEED, BHOP_SPEED_RATE, RateChaseReevaluation.DestinationAndRate);

        isChasing = true;
    }

rule: "[Bhop] :: Update Speed"
    Event.OngoingPlayer
    if (isChasing)
    {
        speedAccumInAir = HorizontalSpeedOf();
        SetMoveSpeed(player, bhopSpeed);
        Wait(0.032);
        LoopIfConditionIsTrue();
    }

rule: "[Bhop] :: Update isChasing"
    Event.OngoingPlayer
    if (isChasing && bhopSpeed == BHOP_MAX_SPEED || bhopSpeed == 100)
    {
        StopChasingVariable(bhopSpeed);
        isChasing = false;
    }

rule: "[Bhop] :: Stop chasing if too slow"
    Event.OngoingPlayer
    if (!usingGrapple && !usingTele && (isChasing || bhopSpeed == BHOP_MAX_SPEED) && HorizontalSpeedOf() < 5.14)
    {
        StopChasingVariable(bhopSpeed);
        isChasing = false;
        bhopSpeed = 100;
        SetMoveSpeed(player, bhopSpeed);
        Wait(0.032);
        LoopIfConditionIsTrue();
    }

rule: "[Bhop] :: Stop if player is on ground"
    Event.OngoingPlayer
    if ((IsOnGround() && !usingGrapple) && (bhopSpeed > 100))
    {
        WaitIfTrue(0.2);
        StopChasingVariable(bhopSpeed);
        bhopSpeed = 100;
        // ChaseVariableAtRate(bhopSpeed, 100, 325, RateChaseReevaluation.DestinationAndRate);
        // isChasing = true;
        SetMoveSpeed(player, bhopSpeed);
    }

disabled rule: "---------------- Dodge ----------------"{}

rule: "[Dodge] :: Action"
    Event.OngoingPlayer
    if (dodgeEnabled && canDodge && IsAbility1Held())
    {
        throttleOf = ThrottleOf() + Vector(0, 0.5, 0);

        if (throttleOf == Vector(0, 0.5, 0))
            throttleOf = Vector(0, 0.5, 1);

        ApplyImpulse(player, throttleOf, DODGE_FORCE, Relative.ToPlayer, ContraryMotion.Cancel);

        if (bhopSpeed < 120)
            bhopSpeed += BHOP_SPEED_RATE * 3;

        canDodge = false;
    }

rule: "[Dodge] :: On Ground"
    Event.OngoingPlayer
    if (IsOnGround())
    {
        canDodge = true;
    }


disabled rule: "---------------- Secondary Fire ----------------"{}

playervar define secondaryInAir;
rule: "[Secondary Fire] :: Projectile"
    Event.OngoingPlayer
    if (matchStarted && secondaryEnabled && IsSecondaryHeld() && IsAlive())
    {
        DestroyEffect(secondaryOrb);
        secondaryHit = RayCastHitPosition(EyePosition(), UpdateEveryFrame(EyePosition() + Facing() * 100), AllLivingPlayers(), player);
        secondaryEyePos = UpdateEveryFrame(EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18);

        secondaryInAir = true;
        PlayEffect(all, PlayEffect.RingExplosionSound, Color.White, player, 50);

        // projectile
        CreateEffect(all, Effect.Orb, Color.Red, secondaryEyePos, 0.1);
        secondaryOrb = LastCreatedEntity();

        ChaseVariableAtRate(secondaryEyePos, secondaryHit, SECONDARY_PROJECTILE_SPEED, RateChaseReevaluation.DestinationAndRate);

        Wait(0.75);
        LoopIfConditionIsTrue();
    }

rule: "[Secondary Fire] :: Impulse"
    Event.OngoingPlayer
    if (DistanceBetween(secondaryEyePos, secondaryHit) < 0.1 || RayCastHitPlayer(EyePosition(), secondaryEyePos, AllLivingPlayers(), player) != null)
    {
        secondaryInAir = false;
        StopChasingVariable(secondaryEyePos);
        define players = FilteredArray(AllLivingPlayers(), DistanceBetween(Curr(), secondaryEyePos) <= 4.5);
        for (define i = 0; i < CountOf(players); i++)
        {
            ApplyImpulse(players[i], DirectionTowards(secondaryEyePos, players[i] + Up()), 15, Relative.ToWorld, ContraryMotion.Incorporate);
        }
        
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Red, secondaryHit, 2.5);
        // PlayEffect(VisibleTo: all, Type: PlayEffect.RingExplosionSound, Position: player, Radius: 15);
        DestroyEffect(secondaryOrb);
    }

rule: "[Secondary Fire] :: Effect Loop"
    Event.OngoingPlayer
    if (secondaryInAir)
    {
        while (secondaryInAir)
        {
            PlayEffect(all, PlayEffect.BadExplosion, Color.Red, secondaryEyePos, 0.05);
            Wait(0.016);
        }
    }

disabled rule: "---------------- Grapple ----------------"{}
playervar define grappleBeam;
playervar define grappleSphere;

void EndGrapple() playervar "[Sub] :: End Grapple"
    {
        usingGrapple = false;
        StopForcingThrottle();
        DestroyEffect(grappleSphere);
        DestroyEffect(grappleBeam);
        grappleHitPlayer = null;
    }

rule: "[Grapple] :: Grapple Start"
    Event.OngoingPlayer
    if (matchStarted && grappleEnabled && IsAbility2Held() && IsAlive())
    {
        grappleHit = RayCastHitPosition(EyePosition(), UpdateEveryFrame(EyePosition() + Facing() * GRAPPLE_RANGE), AllLivingPlayers(), player);
        grappleHitPlayer = RayCastHitPlayer(EyePosition(), UpdateEveryFrame(EyePosition() + Facing() * GRAPPLE_RANGE), AllLivingPlayers(), player, true);
        grappleEyePos = EyePosition();

        if (grappleHitPlayer)
        {
            CreateBeamEffect(all, BeamType.GrappleBeam, player, grappleHitPlayer, Color.Yellow, EffectRev.VisibleToPositionAndRadius);
            grappleBeam = LastCreatedEntity();
            
            if (DistanceBetween(grappleEyePos, grappleHit) != GRAPPLE_RANGE)
            {
                CreateEffect(all, Effect.Sphere, Color.Yellow, grappleHitPlayer, 0.2);
                grappleSphere = LastCreatedEntity();
            }
        }
        else 
        {
            CreateBeamEffect(all, BeamType.GrappleBeam, player, grappleHit, Color.Yellow, EffectRev.VisibleToPositionAndRadius);
            grappleBeam = LastCreatedEntity();
            
            if (DistanceBetween(grappleEyePos, grappleHit) != GRAPPLE_RANGE)
            {
                CreateEffect(all, Effect.Sphere, Color.Yellow, grappleHit, 0.2);
                grappleSphere = LastCreatedEntity();
            }
        }

        usingGrapple = true;

        if (DistanceBetween(grappleEyePos, grappleHit) == GRAPPLE_RANGE)
        {
            Wait(0.25);
            EndGrapple();
        }
        else if (DistanceBetween(player, grappleHit) < 3)
        {
            Wait(0.25);
            EndGrapple();
        }
        else
        {
            PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, grappleHit, 0.2);
            PlayEffect(all, PlayEffect.BadExplosion, Color.Yellow, player, 0.33);
            PlayEffect(all, PlayEffect.BuffImpactSound, Color.White, player, 100);
        }

        Wait(0.5);
        LoopIf(IsAbility2Held() && IsAlive() && DistanceBetween(grappleEyePos, grappleHit) == GRAPPLE_RANGE);
    }

rule: "[Grapple] :: Pull"
    Event.OngoingPlayer
    if (usingGrapple && DistanceBetween(grappleEyePos, grappleHit) < GRAPPLE_RANGE)
    {
        ForceThrottle(player, 0, 0.05, 0, 0.05, 0, 0.05);

        if (grappleHitPlayer && IsAlive(grappleHitPlayer))
            ApplyImpulse(grappleHitPlayer, Vector(0, 0.3, 0) + DirectionTowards(grappleHitPlayer, EyePosition()), GRAPPLE_PULL_SPEED / 1.25, Relative.ToWorld, ContraryMotion.Incorporate);
        else if (IsJumpHeld()) 
            ApplyImpulse(player, Vector(0, 0.3, 0) + DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);
        else
            ApplyImpulse(player, DirectionTowards(EyePosition(), grappleHit), GRAPPLE_PULL_SPEED, Relative.ToWorld, ContraryMotion.Incorporate);

        Wait(0.064);
        LoopIfConditionIsTrue();
    }

rule: "[Grapple] :: Grapple End Ability 2"
    Event.OngoingPlayer
    if (!IsAbility2Held())
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End On Death"
    Event.OnDeath
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Grappled Player Dead"
    Event.OngoingPlayer
    if (IsDead(grappleHitPlayer))
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Grappled Player Too Close"
    Event.OngoingPlayer
    if (DistanceBetween(player, grappleHitPlayer) < 3)
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Too Close"
    Event.OngoingPlayer
    if (DistanceBetween(player, grappleHit) < 3)
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Out of LOS"
    Event.OngoingPlayer
    if (!IsInLineOfSight(player, grappleHitPlayer))
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Grappled Player out of sight"
    Event.OngoingPlayer
    if (!IsInViewAngle(player, grappleHitPlayer, 105))
    {
        EndGrapple();
    }

rule: "[Grapple] :: Grapple End Using Teleporter"
    Event.OngoingPlayer
    if (usingTele)
    {
        EndGrapple();
    }

disabled rule: "---------------- Buff + Tele ----------------"{}

rule: "[Buff + Tele] :: Map Locations"
    {
        // [0]: wallbang
        // [1]: bullet bouncy bouncy go go
        // [2]: buckshot
        // [3]: extra 'life'
        // [4]: redeemer

        // teles:
        // [0] -> [1]
        // [1] -> [0]
        // [2] -> [3]
        // [3] -> [2]

        validMap = false;

        switch (buffsEnabled)
        {
            case (CurrentMap() == Map.Workshop_Chamber || CurrentMap() == Map.Workshop_Expanse || CurrentMap() == Map.Workshop_Expanse_Night || CurrentMap() == Map.Workshop_Island || CurrentMap() == Map.Workshop_Island_Night || CurrentMap() == Map.Workshop_Green_Screen):
                validMap = true;
                buffPos[0] = Vector(0, 1, 2);
                buffPos[1] = Vector(0, 1, -2);
                buffPos[2] = Vector(0, 1, -6);
                buffPos[3] = Vector(0, 1, 6);
                buffPos[4] = Vector(12, 1, 0);

                telePos[0] = Vector(0, -10000, 0);
                teleFacing[0] = Vector(0, 0, 0);
                telePos[1] = Vector(0, -10000, 0);
                teleFacing[1] = Vector(0, 0, 0);
                telePos[2] = Vector(0, -10000, 0);
                teleFacing[2] = Vector(0, 0, 0);
                telePos[3] = Vector(0, -10000, 0);
                teleFacing[3] = Vector(0, 0, 0);
                break;
            case (CurrentMap() == Map.Black_Forest || CurrentMap() == Map.Black_Forest_Winter):
                validMap = true;
                buffPos[0] = Vector(16.79, 12.44, 29.48);
                buffPos[1] = Vector(4.66, 18.28, 5.00);
                buffPos[2] = Vector(16.18, 12.36, -20.11);
                buffPos[3] = Vector(-25.49, 13.09, 5.00);
                buffPos[4] = Vector(21.00, 10.00, 5.00);
                
                telePos[0] = Vector(29.09, 11, 4.97);
                teleFacing[0] = Vector(-1, 0, 0);
                telePos[1] = Vector(-31.25, 14.96, 5.00);
                teleFacing[1] = Vector(1, 0, 0);
                telePos[2] = Vector(35.92, 14, -26.70);
                teleFacing[2] = Vector(-0.85, 0, 0.52);
                telePos[3] = Vector(37.47, 14, 37.26);
                teleFacing[3] = Vector(-0.87, 0, -0.50);
                break;
            case (CurrentMap() == Map.Blizzard_World || CurrentMap() == Map.Blizzard_World_Winter):
                validMap = true;
                buffPos[0] = Vector(-32.50, 0.61, 73.15);
                buffPos[1] = Vector(-77.28, 5.88, 66.15);
                buffPos[2] = Vector(-54.50, 0.61, 110.20);
                buffPos[3] = Vector(-67.55, 1.75, 138.74);
                buffPos[4] = Vector(-25.04, 1.29, 109.95);
                
                telePos[0] = Vector(-82.73, 2.46, 60.72);
                teleFacing[0] = Vector(0.71, 0, 0.71);
                telePos[1] = Vector(-72.27, 3.75, 157.62);
                teleFacing[1] = Vector(0.27, 0, -0.96);
                telePos[2] = Vector(-15.39, 4, 63.37);
                teleFacing[2] = Vector(-0.71, 0, 0.71);
                telePos[3] = Vector(-101.27, 2.75, 90.34);
                teleFacing[3] = Vector(0.96, 0, 0.29);
                break;
            case (CurrentMap() == Map.Castillo):
                validMap = true;
                buffPos[0] = Vector(-106.18, 40.56, 43.20);
                buffPos[1] = Vector(-115.85, 39.57, 60.92);
                buffPos[2] = Vector(-100.35, 40.56, 73.75);
                buffPos[3] = Vector(-74.82, 33.00, 52.93);
                buffPos[4] = Vector(-85.65, 39.64, 55.00);
                
                telePos[0] = Vector(-131.30, 36.38, 63.88);
                teleFacing[0] = Vector(0.98, 0, -0.20);
                telePos[1] = Vector(-72.11, 34.59, 48.36);
                teleFacing[1] = Vector(-0.53, 0, 0.85);
                telePos[2] = Vector(-86.30, 34.56, 85.75);
                teleFacing[2] = Vector(-0.22, 0, -0.97);
                telePos[3] = Vector(-97.60, 34.56, 27.19);
                teleFacing[3] = Vector(0.15, 0, 0.98);
                break;
            case (CurrentMap() == Map.Chateau_Guillard || CurrentMap() == Map.Chateau_Guillard_Halloween):
                validMap = true;
                buffPos[0] = Vector(206.31, 9.03, 101.90);
                buffPos[1] = Vector(206.31, 9.00, 61.91);
                buffPos[2] = Vector(180.60, 10, 101.93);
                buffPos[3] = Vector(206.19, 1, 77.96);
                buffPos[4] = Vector(229.12, 14.00, 61.97);

                telePos[0] = Vector(193.14, 11, 117.07);
                teleFacing[0] = Vector(0, 0, -1);
                telePos[1] = Vector(201.08, 10, 44.50);
                teleFacing[1] = Vector(0, 0, 1);
                telePos[2] = Vector(165.76, 7, 81.01);
                teleFacing[2] = Vector(1, 0, 0);
                telePos[3] = Vector(206.26, 2, 84.50);
                teleFacing[3] = Vector(0, 0, -1);
                break;
            case (CurrentMap() == Map.Dorado):
                validMap = true;
                buffPos[0] = Vector(115.66, 8.73, -7.08);
                buffPos[1] = Vector(85.30, 13.75, 29.84);
                buffPos[2] = Vector(98.04, 19.01, 15.26);
                buffPos[3] = Vector(131.27, 12.05, 26.12);
                buffPos[4] = Vector(76.87, 9.00, 7.34);

                telePos[0] = Vector(137.96, 13, 28.06);
                teleFacing[0] = Vector(-0.96, 0, -0.28);
                telePos[1] = Vector(92.75, 11, -23.05);
                teleFacing[1] = Vector(0.57, 0, 0.82);
                telePos[2] = Vector(112.44, 13, 50.55);
                teleFacing[2] = Vector(0.27, 0, -0.96);
                telePos[3] = Vector(165.12, 12.01, -5.92);
                teleFacing[3] = Vector(-1, 0, -0.05);
                break;
            case (CurrentMap() == Map.Ecopoint_Antarctica || CurrentMap() == Map.Ecopoint_Antarctica_Winter):
                validMap = true;
                buffPos[0] = Vector(1.66, 12.63, -25.00);
                buffPos[1] = Vector(-19.50, 13.00, 0.00);
                buffPos[2] = Vector(1.66, 12.63, 25.00);
                buffPos[3] = Vector(20.50, 10.00, 0.00);
                buffPos[4] = Vector(18.70, 5.00, 0.00);

                telePos[0] = Vector(24.30, 11, 0);
                teleFacing[0] = Vector(-1, 0, 0);
                telePos[1] = Vector(-35.11, 11, 0);
                teleFacing[1] = Vector(1, 0, 0);
                telePos[2] = Vector(12.20, 10.18, 54.16);
                teleFacing[2] = Vector(-0.29, 0, -0.96);
                telePos[3] = Vector(12.21, 10.16, -54.15);
                teleFacing[3] = Vector(-0.29, 0, 0.96);
                break;
            case (CurrentMap() == Map.Eichenwalde || CurrentMap() == Map.Eichenwalde_Halloween):
                validMap = true;
                buffPos[0] = Vector(55.70, 22.00, -67.84);
                buffPos[1] = Vector(58.33, 5.72, -90.39);
                buffPos[2] = Vector(76.03, 11.69, -109.66);
                buffPos[3] = Vector(88.13, 13.67, -67.39);
                buffPos[4] = Vector(30.76, 15.00, -81.88);

                telePos[0] = Vector(89.08, 14.81, -63.58);
                teleFacing[0] = Vector(-0.30, 0, -0.95);
                telePos[1] = Vector(35.93, 6.93, -63.79);
                teleFacing[1] = Vector(0.92, 0, -0.39);
                telePos[2] = Vector(53.57, 12.72, -124.58);
                teleFacing[2] = Vector(0.24, 0, 0.97);
                telePos[3] = Vector(105.83, 14.72, -110.91);
                teleFacing[3] = Vector(-0.90, 0, 0.44);
                break;
            case (CurrentMap() == Map.Havana):
                validMap = true;
                buffPos[0] = Vector(9.50, 7.00, -79.23);
                buffPos[1] = Vector(37.64, 11.00, -94.23);
                buffPos[2] = Vector(27.92, 13.00, -61.96);
                buffPos[3] = Vector(64.50, 13.00, -83.33);
                buffPos[4] = Vector(40.74, 6.82, -83.33);

                telePos[0] = Vector(0, -10000, 0);
                teleFacing[0] = Vector(0, 0, 0);
                telePos[1] = Vector(0, -10000, 0);
                teleFacing[1] = Vector(0, 0, 0);
                telePos[2] = Vector(0, -10000, 0);
                teleFacing[2] = Vector(0, 0, 0);
                telePos[3] = Vector(0, -10000, 0);
                teleFacing[3] = Vector(0, 0, 0);
                break;
            case (CurrentMap() == Map.Hollywood || CurrentMap() == Map.Hollywood_Halloween):
                validMap = true;
                buffPos[0] = Vector(-11.91, 2.73, -74.64);
                buffPos[1] = Vector(-4.09, 2.60, -15.87);
                buffPos[2] = Vector(20.67, 2.60, -51.82);
                buffPos[3] = Vector(7.87, 13.90, -48.38);
                buffPos[4] = Vector(18.51, 5.69, -28.41);

                telePos[0] = Vector(2.18, 3.75, -2.50);
                teleFacing[0] = Vector(0.78, 0, -0.63);
                telePos[1] = Vector(-1.11, 3.60, -83.00);
                teleFacing[1] = Vector(0.25, 0, 0.97);
                telePos[2] = Vector(-27.85, 7.75, -38.88);
                teleFacing[2] = Vector(0.52, 0, -0.86);
                telePos[3] = Vector(53.28, 4.75, -56.83);
                teleFacing[3] = Vector(-0.98, 0, 0.22);
                break;
            case (CurrentMap() == Map.Kings_Row || CurrentMap() == Map.Kings_Row_Winter):
                validMap = true;
                buffPos[0] = Vector(-49.46, 1.00, 2.69);
                buffPos[1] = Vector(-31.19, 10.00, -13.40);
                buffPos[2] = Vector(-93.67, 8.50, -29.38);
                buffPos[3] = Vector(-48.85, 10.12, -37.62);
                buffPos[4] = Vector(-92.15, 2.10, 7.65);

                telePos[0] = Vector(-91.81, 3.12, 11.97);
                teleFacing[0] = Vector(0.07, 0, -1);
                telePos[1] = Vector(-30.90, 8, -51.25);
                teleFacing[1] = Vector(-0.17, 0, 0.97);
                telePos[2] = Vector(-36.75, 2.07, -34.78);
                teleFacing[2] = Vector(-1, 0, 0.09);
                telePos[3] = Vector(-99.91, 3.01, -8.54);
                teleFacing[3] = Vector(0.99, 0, -0.16);
                break;
            case (CurrentMap() == Map.Lijiang_Control_Center || CurrentMap() == Map.Lijiang_Control_Center_Lunar):
                validMap = true;
                buffPos[0] = Vector(-26.80, 268.00, 308.00);
                buffPos[1] = Vector(0.00, 271.00, 323.00);
                buffPos[2] = Vector(26.80, 268.00, 308.00);
                buffPos[3] = Vector(0.00, 271.00, 260.65);
                buffPos[4] = Vector(0.00, 279.00, 291.85);

                telePos[0] = Vector(0, 272, 329.50);
                teleFacing[0] = Vector(0, 0, -1);
                telePos[1] = Vector(0, 272, 266.10);
                teleFacing[1] = Vector(0, 0, 1);
                telePos[2] = Vector(-26.78, 269, 333.84);
                teleFacing[2] = Vector(-0.71, 0, -0.71);
                telePos[3] = Vector(26.78, 269, 333.84);
                teleFacing[3] = Vector(0.71, 0, -0.71);
                break;
            case (CurrentMap() == Map.Necropolis):
                validMap = true;
                buffPos[0] = Vector(1.68, 12.70, 17.25);
                buffPos[1] = Vector(-21.05, 13.71, 0);
                buffPos[2] = Vector(1.80, 12.70, -16.41);
                buffPos[3] = Vector(8.50, 2.01, 0.00);
                buffPos[4] = Vector(23.08, 5.99, 0.00);

                telePos[0] = Vector(0, -10000, 0);
                teleFacing[0] = Vector(0, 0, 0);
                telePos[1] = Vector(0, -10000, 0);
                teleFacing[1] = Vector(0, 0, 0);
                telePos[2] = Vector(0, -10000, 0);
                teleFacing[2] = Vector(0, 0, 0);
                telePos[3] = Vector(0, -10000, 0);
                teleFacing[3] = Vector(0, 0, 0);
                break;
            case (CurrentMap() == Map.Paris):
                validMap = true;
                buffPos[0] = Vector(-104.10, 16.00, -100.65);
                buffPos[1] = Vector(-109.18, 11.00, -60.60);
                buffPos[2] = Vector(-57.19, 14.00, -82.00);
                buffPos[3] = Vector(-73.39, 11.02, -38.23);
                buffPos[4] = Vector(-85.93, 13.00, -64.09);

                telePos[0] = Vector(-50.33, 11.27, -43.73);
                teleFacing[0] = Vector(-0.84, 0, -0.54);
                telePos[1] = Vector(-105.87, 17, -104.22);
                teleFacing[1] = Vector(0.44, 0, 0.90);
                telePos[2] = Vector(-53.82, 15, -84.22);
                teleFacing[2] = Vector(-0.90, 0, 0.44);
                telePos[3] = Vector(-109.57, 13.06, -29.32);
                teleFacing[3] = Vector(-0.15, 0, -0.99);
                break;
        }
    }

globalvar define telePos;
globalvar define teleFacing;
playervar define usingTele;
playervar define teleThrottle;

void TeleImpulse() playervar "[Sub] :: Teleporter Impulse"
    {
        SetGravity(player, 0);

        ApplyImpulse(player, Up(), 0.001);
        ApplyImpulse(player, Down(), 0.001);
        ApplyImpulse(player, Forward(), 0.001);
        ApplyImpulse(player, Backward(), 0.001);
        ApplyImpulse(player, Left(), 0.001);
        ApplyImpulse(player, Right(), 0.001);

        teleThrottle = ThrottleOf() + Vector(0, 0.25, 1);

        if (ThrottleOf() == Vector(XOf(ThrottleOf()), 0, -1))
            teleThrottle = Vector(0, 0.25, 1);

        Wait(0.08);
        SetGravity(player, 100);
        ApplyImpulse(player, teleThrottle, 20, Relative.ToPlayer, ContraryMotion.Cancel);

        Wait(1.5);
        usingTele = false;
    }

rule: "[Tele] :: Create Tele Effects"
    if (validMap && matchStarted && teleEnabled)
    {
        for (define i = 0; i < 4; i++)
        {
            CreateEffect(all, Effect.BadAura, Color.Violet, telePos[i], 2, EffectRev.None);
        }
    }

rule: "[Tele] :: 0 to 1"
    Event.OngoingPlayer
    if (!usingTele && teleEnabled && validMap && DistanceBetween(telePos[0], player) < 3)
    {
        usingTele = true;
        Teleport(player, telePos[1]);
        SetFacing(player, teleFacing[1] + Vector(0, YOf(Facing()), 0));
        PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, player, 1);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, telePos[0], 3);

        TeleImpulse();
    }

rule: "[Tele] :: 1 to 0"
    Event.OngoingPlayer
    if (!usingTele && teleEnabled && validMap && DistanceBetween(telePos[1], player) < 3)
    {
        usingTele = true;
        Teleport(player, telePos[0]);
        SetFacing(player, teleFacing[0] + Vector(0, YOf(Facing()), 0));
        PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, player, 1);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, telePos[1], 3);

        TeleImpulse();
    }

rule: "[Tele] :: 2 to 3"
    Event.OngoingPlayer
    if (!usingTele && teleEnabled && validMap && DistanceBetween(telePos[2], player) < 3)
    {
        usingTele = true;
        Teleport(player, telePos[3]);
        SetFacing(player, teleFacing[3] + Vector(0, YOf(Facing()), 0));
        PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, player, 1);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, telePos[2], 3);

        TeleImpulse();
    }

rule: "[Tele] :: 3 to 2"
    Event.OngoingPlayer
    if (!usingTele && teleEnabled && validMap && DistanceBetween(telePos[3], player) < 3)
    {
        usingTele = true;
        Teleport(player, telePos[2]);
        SetFacing(player, teleFacing[2] + Vector(0, YOf(Facing()), 0));
        PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, player, 1);
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, telePos[3], 3);

        TeleImpulse();
    }

rule: "[Buff] :: Player With Buff Doesn't Exist"
    Event.OnPlayerLeave
    {
        if (player == wallbangUser)
        {
            LogToInspector("wallbangUser no longer exists");
            wallbangUser.wallbangEnabled = false;
            wallbangUser = null;
            WallbangCooldown();
        }

        if (player == ricochetUser)
        {
            LogToInspector("riochetUser no longer exists");
            ricochetUser.ricochetEnabled = false;
            ricochetUser = null;
            RicochetCooldown();
        }

        if (player == buckshotUser)
        {
            LogToInspector("buckshotUser no longer exists");
            buckshotUser.buckshotEnabled = false;
            buckshotUser = null;
            BuckshotCooldown();
        }

        if (player == lifeUser)
        {
            LogToInspector("lifeUser no longer exists");
            lifeUser.lifeEnabled = false;
            lifeUser = null;
            LifeCooldown();
        }
    }

globalvar define wallbangPBar;
globalvar define wallbangSphereSize;
globalvar define wallbangInProgressEffect;
globalvar define ricochetPBar;
globalvar define ricochetSphereSize;
globalvar define ricochetInProgressEffect;
globalvar define buckshotPBar;
globalvar define buckshotSphereSize;
globalvar define buckshotInProgressEffect;
globalvar define lifePBar;
globalvar define lifeSphereSize;
globalvar define lifeInProgressEffect;

void WallbangCooldown() "[Sub] :: Wallbang Cooldown" 
    {
        if (!spawnWithWallbang && spawnWallbang)
        {
            if (wallbangCD == 0 || wallbangCD == WALLBANG_CD)
            {
                LogToInspector("Wallbang cooldown started");
                wallbangCD = WALLBANG_CD;
                wallbangPBar = 0;
                wallbangSphereSize = 0;

                ChaseVariableAtRate(wallbangCD, 0, 1, RateChaseReevaluation.None);

                ChaseVariableOverTime(wallbangPBar, 100, WALLBANG_CD, TimeChaseReevaluation.None);
                ChaseVariableOverTime(wallbangSphereSize, 0.4, WALLBANG_CD, TimeChaseReevaluation.None);
            }

            // wallbangUser = null;
            // destroy and recreate the effects, just in case
            DestroyEffect(wallbangInProgressEffect[0]);
            DestroyEffect(wallbangInProgressEffect[1]);
            DestroyProgressBarInWorldText(cdText[0]);

            MinWait();

            CreateEffect(all, Effect.Sphere, Color.Yellow, buffPos[0], wallbangSphereSize);
            wallbangInProgressEffect[0] = LastCreatedEntity();

            CreateEffect(all, Effect.Ring, Color.Yellow, buffPos[0] - Vector(0, 1, 0), wallbangSphereSize);
            wallbangInProgressEffect[1] = LastCreatedEntity();

            CreateProgressBarInWorldText(all, wallbangPBar, null, buffPos[0] + Vector(0, wallbangSphereSize, 0), 0, Clipping.ClipAgainstSurfaces, Color.Yellow, Color.White);
            cdText[0] = LastTextID();
        }
    }

void RicochetCooldown() "[Sub] :: Ricochet Cooldown"
    {
        if (!spawnWithRicochet && spawnRicochet)
        {
            if (ricochetCD == 0 || ricochetCD == RICOCHET_CD)
            {
                LogToInspector("Riochet cooldown started");
                ricochetCD = RICOCHET_CD;
                ricochetPBar = 0;
                ricochetSphereSize = 0;

                ChaseVariableAtRate(ricochetCD, 0, 1, RateChaseReevaluation.None);

                ChaseVariableOverTime(ricochetPBar, 100, RICOCHET_CD, TimeChaseReevaluation.None);
                ChaseVariableOverTime(ricochetSphereSize, 0.4, RICOCHET_CD, TimeChaseReevaluation.None);
            }

            // ricochetUser = null;
            // destroy and recreate the effects, just in case
            DestroyEffect(ricochetInProgressEffect[0]);
            DestroyEffect(ricochetInProgressEffect[1]);
            DestroyProgressBarInWorldText(cdText[1]);

            MinWait();

            CreateEffect(all, Effect.Sphere, Color.Violet, buffPos[1], ricochetSphereSize);
            ricochetInProgressEffect[0] = LastCreatedEntity();

            CreateEffect(all, Effect.Ring, Color.Violet, buffPos[1] - Vector(0, 1, 0), ricochetSphereSize);
            ricochetInProgressEffect[1] = LastCreatedEntity();

            CreateProgressBarInWorldText(all, ricochetPBar, null, buffPos[1] + Vector(0, ricochetSphereSize, 0), 0, Clipping.ClipAgainstSurfaces, Color.Violet, Color.White);
            cdText[1] = LastTextID();
        }
    }

void BuckshotCooldown() "[Sub] :: Buckshot Cooldown"
    {
        if (!spawnWithBuckshot && spawnBuckshot)
        {
            if (buckshotCD == 0 || buckshotCD == BUCKSHOT_CD)
            {
                LogToInspector("Buckshot cooldown started");
                buckshotCD = BUCKSHOT_CD;
                buckshotPBar = 0;
                buckshotSphereSize = 0;

                ChaseVariableAtRate(buckshotCD, 0, 1, RateChaseReevaluation.None);

                ChaseVariableOverTime(buckshotPBar, 100, BUCKSHOT_CD, TimeChaseReevaluation.None);
                ChaseVariableOverTime(buckshotSphereSize, 0.4, BUCKSHOT_CD, TimeChaseReevaluation.None);
            }
            
            // buckshotUser = null;
            // destroy and recreate the effects, just in case
            DestroyEffect(buckshotInProgressEffect[0]);
            DestroyEffect(buckshotInProgressEffect[1]);
            DestroyProgressBarInWorldText(cdText[2]);

            MinWait();

            CreateEffect(all, Effect.Sphere, Color.Green, buffPos[2], buckshotSphereSize);
            buckshotInProgressEffect[0] = LastCreatedEntity();

            CreateEffect(all, Effect.Ring, Color.Green, buffPos[2] - Vector(0, 1, 0), buckshotSphereSize);
            buckshotInProgressEffect[1] = LastCreatedEntity();

            CreateProgressBarInWorldText(all, buckshotPBar, null, buffPos[2] + Vector(0, buckshotSphereSize, 0), 0, Clipping.ClipAgainstSurfaces, Color.Green, Color.White);
            cdText[2] = LastTextID();
        }
    }

void LifeCooldown() "[Sub] :: Life Cooldown"
    {
        if (!spawnWithLife && spawnLife)
        {
            if (lifeCD == 0 || lifeCD == LIFE_CD)
            {
                LogToInspector("Extra Life cooldown started");
                lifeCD = LIFE_CD;
                lifePBar = 0;
                lifeSphereSize = 0;
                    
                ChaseVariableAtRate(lifeCD, 0, 1, RateChaseReevaluation.None);

                ChaseVariableOverTime(lifePBar, 100, LIFE_CD, TimeChaseReevaluation.None);
                ChaseVariableOverTime(lifeSphereSize, 0.4, LIFE_CD, TimeChaseReevaluation.None);
            }
            
            // lifeUser = null;
            // destroy and recreate the effects, just in case
            DestroyEffect(lifeInProgressEffect[0]);
            DestroyEffect(lifeInProgressEffect[1]);
            DestroyProgressBarInWorldText(cdText[3]);

            MinWait();

            CreateEffect(all, Effect.Sphere, Color.SkyBlue, buffPos[3], lifeSphereSize);
            lifeInProgressEffect[0] = LastCreatedEntity();

            CreateEffect(all, Effect.Ring, Color.SkyBlue, buffPos[3] - Vector(0, 1, 0), lifeSphereSize);
            lifeInProgressEffect[1] = LastCreatedEntity();

            CreateProgressBarInWorldText(all, lifePBar, null, buffPos[3] + Vector(0, lifeSphereSize, 0), 0, Clipping.ClipAgainstSurfaces, Color.Blue, Color.White);
            cdText[3] = LastTextID();
        }
    }

disabled rule: "---------------- Wallbang ----------------"{}

rule: "[Buff] :: Wallbang : Create Orb"
    if (matchStarted && validMap && !spawnWithWallbang && spawnWallbang && (wallbangCD == 0 || buffsSpawnImmediately))
    {
        canPickupWallbang = true;
        LogToInspector("Wallbang Orb Created");
        DestroyEffect(wallbangInProgressEffect[0]);
        CreateEffect(all, Effect.Orb, Color.Yellow, buffPos[0], 2);
        buffEffect[0] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Yellow, buffPos[0], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Baptiste, Button.Ultimate), buffPos[0], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[0] = LastTextID();

        DestroyProgressBarInWorldText(cdText[0]);
    }

rule: "[Buff] :: Wallbang : Collect"
    Event.OngoingPlayer
    if ((matchStarted && canPickupWallbang && DistanceBetween(buffPos[0], player) < 2.5 && IsAlive()) || spawnWithWallbang)
    {
        canPickupWallbang = false;
        wallbangUser = player;
        wallbangEnabled = true;

        LogToInspector(<"Wallbang Enabled for <0>", wallbangUser>);

        if (!spawnWithWallbang)
        {
            // destroy inworld text / icon / orb
            DestroyProgressBarInWorldText(cdText[0]);
            DestroyEffect(wallbangInProgressEffect[1]);
            DestroyInWorldText(buffIcon[0]);
            DestroyEffect(buffEffect[0]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Yellow, buffPos[0], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Yellow, buffPos[0], 200);

            // start timer
            wallbangDur = 100;
            ChaseVariableOverTime(wallbangDur, 0, WALLBANG_DUR, TimeChaseReevaluation.None);

            // toasts
            CreateProgressBarHudText(player, wallbangDur, <"<0> Wallbang <0>", AbilityIconString(Hero.Baptiste, Button.Ultimate)>, Location.Right, 0.3, Color.Yellow, Color.Yellow);
            hudText[0] = LastTextID();
            SmallMessage(player, "Your bullets go through walls!");
            BigMessage(player, "Wallbang");

            // create effect
            CreateEffect(IsAlive() ? all : null, Effect.GoodAura, Color.Yellow, player, 0.75, EffectRev.VisibleToPositionAndRadius);
            wallbangBuffEffect = LastCreatedEntity();

            // sound when buff is about to run out
            Wait(WALLBANG_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
                Wait(1);
            }
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Wallbang: Forever <0>", AbilityIconString(Hero.Baptiste, Button.Ultimate)>, Location.Right, 0.3, Color.White, Color.White, Color.Yellow);
            hudText[0] = LastTextID();
        }
    }

rule: "[Buff] :: Wallbang : Remove"
    Event.OngoingPlayer
    if (!spawnWithWallbang && wallbangDur == 0)
    {
        Wait(0.128);
        LogToInspector(<"Wallbang Disabled for <0>", wallbangUser>);

        // destroy hud timer and player effect
        DestroyProgressBarHudText(hudText[0]);
        DestroyEffect(wallbangBuffEffect);
        StopChasingVariable(wallbangDur);

        wallbangEnabled = false;
        wallbangDur = 100;

        // start in world cooldown
        WallbangCooldown(); 
    }

rule: "[Buff] :: Wallbang : Action"
    Event.OngoingPlayer
    if (wallbangEnabled && IsFiringPrimary())
    {
        define gunPos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        define wallbangHitPos = EyePosition();

        define wallbangHitPlayer;

        for (define wallbangCount = 0; DistanceBetween(gunPos, wallbangHitPos) < 100 && wallbangCount < NUM_WALLBANGS; wallbangCount++)
        {
            wallbangHitPos = RayCastHitPosition(wallbangHitPos + Facing(), UpdateEveryFrame(wallbangHitPos + Facing() * (100 - DistanceBetween(gunPos, wallbangHitPos))), AllLivingPlayers(), player, true);
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, wallbangHitPos, 0.2);
            wallbangHitPlayer = RayCastHitPlayer(wallbangHitPos, UpdateEveryFrame(wallbangHitPos + Facing() * (100 - DistanceBetween(gunPos, wallbangHitPos))), AllLivingPlayers(), player, true);

            if (wallbangHitPlayer != null && wallbangHitPlayer != player)
            {
                Damage(wallbangHitPlayer, player, 10000);
            }

            if (wallbangDbg)
            {
                DestroyEffect(wbDbgEffects[wallbangCount]);
                DestroyEffect(wbDbgBeam[wallbangCount]);
                CreateEffect(all, Effect.Sphere, Color.Yellow, wallbangHitPos, 0.25, EffectRev.None);
                wbDbgEffects[wallbangCount] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, EyePosition(), wallbangHitPos, Color.Yellow, EffectRev.None);
                wbDbgBeam[wallbangCount] = LastCreatedEntity();
            }
        }

        CreateBeamEffect(all, BeamType.BadBeam, gunPos, wallbangHitPos, Color.Yellow, EffectRev.None);
        wallbangEffect[0] = LastCreatedEntity();
        // PlayEffect(all, PlayEffect.GoodExplosion, Color.Yellow, gunPos, 0.2);

        Wait(0.25);
        DestroyEffect(wallbangEffect[0]);
    }

disabled rule: "---------------- Ricochet ----------------"{}

rule: "[Buff] :: Ricochet : Create Orb"
    if (matchStarted && validMap && !spawnWithRicochet && spawnRicochet && (ricochetCD == 0 || buffsSpawnImmediately))
    {
        LogToInspector("Ricochet Orb Created");
        canPickupRicochet = true;

        DestroyEffect(ricochetInProgressEffect[0]);
        CreateEffect(all, Effect.Orb, Color.Violet, buffPos[1], 2);
        buffEffect[1] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Violet, buffPos[1], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Winston, Button.Ability1), buffPos[1], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[1] = LastTextID();

        DestroyProgressBarInWorldText(cdText[1]);
    }

rule: "[Buff] :: Ricochet : Collect"
    Event.OngoingPlayer
    if ((matchStarted && canPickupRicochet && DistanceBetween(buffPos[1], player) < 2.5 && IsAlive()) || spawnWithRicochet)
    {
        canPickupRicochet = false;
        ricochetUser = player;
        ricochetEnabled = true;

        LogToInspector(<"Ricochet Enabled for <0>", ricochetUser>);

        if (!spawnWithRicochet)
        {
            // destroy inworld text / icon / orb
            DestroyProgressBarInWorldText(cdText[1]);
            DestroyEffect(ricochetInProgressEffect[1]);
            DestroyInWorldText(buffIcon[1]);
            DestroyEffect(buffEffect[1]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Violet, buffPos[1], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Violet, buffPos[1], 200);

            // start timer
            ricochetDur = 100;
            ChaseVariableOverTime(ricochetDur, 0, RICOCHET_DUR, TimeChaseReevaluation.None);

            // toasts
            CreateProgressBarHudText(player, ricochetDur, <"<0> Ricochet <0>", AbilityIconString(Hero.Winston, Button.Ability1)>, Location.Right, 0.4, Color.Violet, Color.Violet);
            hudText[1] = LastTextID();
            SmallMessage(player, "Your bullets ricochet off walls!");
            BigMessage(player, "Ricochet");

            // create effect
            CreateEffect(IsAlive() ? all : null, Effect.GoodAura, Color.Violet, player, 0.75, EffectRev.VisibleToPositionAndRadius);
            ricochetBuffEffect = LastCreatedEntity();

            // sound when buff is about to run out
            Wait(RICOCHET_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
                Wait(1);
            }
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Ricochet: Forever <0>", AbilityIconString(Hero.Winston, Button.Ability1)>, Location.Right, 0.4, Color.White, Color.White, Color.Violet);
            hudText[1] = LastTextID();
        }
    }

rule: "[Buff] :: Ricochet : Remove"
    Event.OngoingPlayer
    if (!spawnWithRicochet && ricochetDur == 0)
    {
        Wait(0.128);
        LogToInspector(<"Riochet Disabled for <0>", ricochetUser>);
        // destroy hud timer and player effect
        DestroyProgressBarHudText(hudText[1]);
        DestroyEffect(ricochetBuffEffect);
        StopChasingVariable(ricochetDur);

        ricochetEnabled = false;
        ricochetDur = 100;

        // start in world cooldown
        RicochetCooldown(); 
    }


rule: "[Buff] :: Ricochet : Action"
    Event.OngoingPlayer
    if (ricochetEnabled && IsFiringPrimary())
    {
        // https://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector
        define normals = [];
        define hitPos = [];
        define hitPosPlayer = [];
        define ricochets = [];
        define hitPosRicochets = [];
        define hitPosPlayerRicochets = [];
        define ricochetEffects = [];
        define ricochetEffect = [];

        eyePos = EyePosition() + Facing() + WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        facing = Facing();

        for (define loop = 0; loop < NUM_RICOCHETS; loop++)
        {
            if (loop > 0)
            {
                eyePos = hitPos[loop - 1];
                facing = ricochets[loop - 1];
            }

            normals[loop] = RayCastHitNormal(eyePos, eyePos + facing * 100, AllLivingPlayers(), player, true);
            hitPos[loop] = RayCastHitPosition(eyePos, UpdateEveryFrame(eyePos + facing * 100), AllLivingPlayers(), player, true);
            hitPosPlayer[loop] = RayCastHitPlayer(eyePos, eyePos + facing * 100, AllLivingPlayers(), player, true);
            ricochets[loop] = facing - (2 * (normals[loop] * DotProduct(facing, normals[loop])));
            hitPosRicochets[loop] = RayCastHitPosition(hitPos[loop], hitPos[loop] + ricochets[loop] * 100, AllLivingPlayers(), player, true);
            hitPosPlayerRicochets[loop] = RayCastHitPlayer(hitPos[loop], hitPos[loop] + ricochets[loop] * 100, AllLivingPlayers(), player, true);

            CreateBeamEffect(all, BeamType.BadBeam, eyePos, hitPos[loop], Color.Violet, EffectRev.None); // first raycast hit
            ricochetEffect[loop] = LastCreatedEntity();

            CreateBeamEffect(all, BeamType.BadBeam, hitPos[loop], hitPosRicochets[loop], Color.Violet, EffectRev.None); // ricochets
            ricochetEffects[loop] = LastCreatedEntity();

            // PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, eyePos, 0.2); // muzzle flash
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, hitPos[loop], 0.2); // first raycast hit
            PlayEffect(all, PlayEffect.GoodExplosion, Color.Violet, hitPosRicochets[loop], 0.2); // ricochets

            Damage(hitPosPlayer[loop], player, 10000);
            Damage(hitPosPlayerRicochets[loop], player, 10000);

            if (ricochetDbg)
            {
                DestroyEffect(rDbgEffects[0][loop]);
                DestroyEffect(rDbgEffects[1][loop]);
                DestroyEffect(rDbgBeam[0][loop]);
                DestroyEffect(rDbgBeam[1][loop]);
                CreateEffect(all, Effect.Sphere, Color.Violet, hitPos[loop], 0.25, EffectRev.None);
                rDbgEffects[0][loop] = LastCreatedEntity();
                CreateEffect(all, Effect.Sphere, Color.Violet, hitPosRicochets[loop], 0.25, EffectRev.None);
                rDbgEffects[1][loop] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, eyePos, hitPos[loop], Color.Violet, EffectRev.None);
                rDbgBeam[0][loop] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, hitPos[loop], hitPosRicochets[loop], Color.Violet, EffectRev.None);
                rDbgBeam[1][loop] = LastCreatedEntity();
            }
        }

        Wait(0.15);
        for (define i = 0; i < NUM_RICOCHETS; i++)
        {
            DestroyEffect(ricochetEffect[i]);
            DestroyEffect(ricochetEffects[i]);
        }
    }

disabled rule: "---------------- Buckshot ----------------"{}

rule: "[Buff] :: Buckshot : Create Orb"
    if (matchStarted && validMap && !spawnWithBuckshot && spawnBuckshot && (buckshotCD == 0 || buffsSpawnImmediately))
    {
        LogToInspector("Buckshot Orb Created");
        canPickupBuckshot = true;

        DestroyEffect(buckshotInProgressEffect[0]);
        CreateEffect(all, Effect.Orb, Color.Green, buffPos[2], 2);
        buffEffect[2] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Green, buffPos[2], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Ashe, Button.Ability1), buffPos[2], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[2] = LastTextID();

        DestroyProgressBarInWorldText(cdText[2]);
    }

rule: "[Buff] :: Buckshot : Collect"
    Event.OngoingPlayer
    if ((matchStarted && canPickupBuckshot && DistanceBetween(buffPos[2], player) < 2.5 && IsAlive()) || spawnWithBuckshot)
    {
        canPickupBuckshot = false;
        buckshotUser = player;
        buckshotEnabled = true;

        LogToInspector(<"Buckshot Enabled for <0>", buckshotUser>);

        if (!spawnWithBuckshot)
        {
            // destroy inworld text / icon / orb
            DestroyProgressBarInWorldText(cdText[2]);
            DestroyEffect(buckshotInProgressEffect[1]);
            DestroyInWorldText(buffIcon[2]);
            DestroyEffect(buffEffect[2]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.Green, buffPos[2], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.Green, buffPos[2], 200);

            // start timer
            buckshotDur = 100;
            ChaseVariableOverTime(buckshotDur, 0, BUCKSHOT_DUR, TimeChaseReevaluation.None);

            // toasts
            CreateProgressBarHudText(player, buckshotDur, <"<0> Buckshot <0>", AbilityIconString(Hero.Ashe, Button.Ability1)>, Location.Right, 0.5, Color.Green, Color.Green);
            hudText[2] = LastTextID();

            BigMessage(player, "Buckshot");
            SmallMessage(player, "Your bullets spread like a shotgun!");

            // create effect
            CreateEffect(IsAlive() ? all : null, Effect.GoodAura, Color.Green, player, 0.75, EffectRev.VisibleToPositionAndRadius);
            buckshotBuffEffect = LastCreatedEntity();

            // sound when buff is about to run out
            Wait(BUCKSHOT_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, buckshotUser, 100);
                Wait(1);
            }
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Buckshot: Forever <0>", AbilityIconString(Hero.Ashe, Button.Ability1)>, Location.Right, 0.5, Color.White, Color.White, Color.Green);
            hudText[2] = LastTextID();
        }
    }

rule: "[Buff] :: Buckshot : Remove"
    Event.OngoingPlayer
    if (!spawnWithBuckshot && buckshotDur == 0)
    {
        Wait(0.128);

        LogToInspector(<"Buckshot Disabled for <0>", buckshotUser>);

        // destroy hud timer and player effect
        DestroyProgressBarHudText(hudText[2]);
        DestroyEffect(buckshotBuffEffect);
        StopChasingVariable(buckshotDur);

        buckshotEnabled = false;
        buckshotDur = 100;

        // start in world cooldown
        BuckshotCooldown(); 
    }

rule: "[Buff] :: Buckshot : Action"
    Event.OngoingPlayer
    if (buckshotEnabled && IsFiringPrimary())
    {
        buckshotHitPos = [];
        buckshotHitPlayer = [];
        define gunPos = WorldVectorOf(Right() - Vector(0, 0.3, 0), player) * 0.18;
        define buckshotBeam = [];
        define centerBeam;

        spreadDiag = BUCKSHOT_SPREAD - (BUCKSHOT_SPREAD * 0.33);
        spreadHori = BUCKSHOT_SPREAD;

        // center
        buckshotCenter = RayCastHitPosition(EyePosition(), UpdateEveryFrame(EyePosition() + Facing() * 100), livingEnemies, player);

        // lower left
        buckshotHitPos[0] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        // upper left
        buckshotHitPos[1] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        // lower right
        buckshotHitPos[2] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        // upper right
        buckshotHitPos[3] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        // lower mid
        buckshotHitPos[4] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadHori) 
        * 100, AllLivingPlayers(), player, false);

        // upper mid
        buckshotHitPos[5] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadHori) 
        * 100, AllLivingPlayers(), player, false);

        // mid left
        buckshotHitPos[6] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadHori) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        * 100, AllLivingPlayers(), player, false);

        // mid right
        buckshotHitPos[7] = RayCastHitPosition(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadHori) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        * 100, AllLivingPlayers(), player, false);

        // player

        buckshotHitPlayer[0] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[1] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag)
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[2] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadDiag) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[3] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadDiag) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadDiag)
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[4] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() + spreadHori) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[5] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(0) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf() - spreadHori) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[6] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(spreadHori) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        * 100, AllLivingPlayers(), player, false);

        buckshotHitPlayer[7] = RayCastHitPlayer(EyePosition(), EyePosition() + 
        WorldVectorOf(Vector(TangentFromDegrees(-spreadHori) * 100, 0, 0), player) + 
        DirectionFromAngles(HorizontalFacingAngleOf(), VerticalFacingAngleOf()) 
        * 100, AllLivingPlayers(), player, false);
        
        // PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, EyePosition() + Facing() + gunPos, 0.2); // muzzle flash
        PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotCenter, 0.2);

        CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotCenter, Color.Green, EffectRev.None);
        centerBeam = LastCreatedEntity();

        for (define pellets = 0; pellets < 8; pellets++)
        {
            Damage(buckshotHitPlayer[pellets], player, 10000);

            PlayEffect(all, PlayEffect.GoodExplosion, Color.Green, buckshotHitPos[pellets], 0.2);

            CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotHitPos[pellets], Color.Green, EffectRev.None);
            buckshotBeam[pellets] = LastCreatedEntity();

            if (buckshotDbg) // destroying is broken. dont care!
            {
                DestroyEffect(bDbgEffects[pellets]);
                DestroyEffect(bDbgBeam[pellets]);
                CreateEffect(all, Effect.Sphere, Color.Green, buckshotHitPos[pellets], 0.25, EffectRev.None);
                bDbgEffects[pellets] = LastCreatedEntity();
                CreateBeamEffect(all, BeamType.BadBeam, EyePosition(), buckshotHitPos[pellets], Color.Green, EffectRev.None);
                bDbgBeam[pellets] = LastCreatedEntity();

                CreateBeamEffect(all, BeamType.BadBeam, EyePosition() + Facing() + gunPos, buckshotHitPos[pellets], Color.Green, EffectRev.None);
                buckshotBeam[pellets] = LastCreatedEntity();
            }
        }

        Wait(0.25);
        DestroyEffect(centerBeam);
        for (define beams = 0; beams < 8; beams++)
        {
            DestroyEffect(buckshotBeam[beams]);
        }
    }

disabled rule: "---------------- Extra Life ----------------"{}

rule: "[Buff] :: Extra Life : Create Orb"
    if (matchStarted && validMap && !spawnWithLife && spawnLife && (lifeCD == 0 || buffsSpawnImmediately))
    {
        canPickupLife = true;

        DestroyEffect(lifeInProgressEffect[0]);
        CreateEffect(all, Effect.Orb, Color.SkyBlue, buffPos[3], 2);
        buffEffect[3] = LastCreatedEntity();
        PlayEffect(all, PlayEffect.GoodPickupEffect, Color.SkyBlue, buffPos[3], 1);

        CreateInWorldText(all, AbilityIconString(Hero.Mercy, Button.Ability2), buffPos[3], 2, Clipping.ClipAgainstSurfaces);
        buffIcon[3] = LastTextID();

        DestroyProgressBarInWorldText(cdText[3]);
    }

rule: "[Buff] :: Extra Life : Collect"
    Event.OngoingPlayer
    if ((matchStarted && !extraLife && canPickupLife && DistanceBetween(buffPos[3], player) < 2.5 && IsAlive()) || (spawnWithLife && IsAlive()))
    {
        canPickupLife = false;
        lifeUser = player;
        lifeEnabled = true;

        LogToInspector(<"Extra Life Enabled for <0>", lifeUser>);

        if (!spawnWithLife)
        {
            // destroy inworld text / icon / orb
            DestroyProgressBarInWorldText(cdText[3]);
            DestroyEffect(lifeInProgressEffect[1]);
            DestroyInWorldText(buffIcon[3]);
            DestroyEffect(buffEffect[3]);

            // pickup effects
            PlayEffect(all, PlayEffect.GoodPickupEffect, Color.SkyBlue, buffPos[3], 1);
            PlayEffect(all, PlayEffect.BuffExplosionSound, Color.SkyBlue, buffPos[3], 200);

            // start timer
            lifeDur = 100;
            ChaseVariableOverTime(lifeDur, 0, LIFE_DUR, TimeChaseReevaluation.None);

            // toasts
            CreateProgressBarHudText(player, lifeDur, <"<0> Extra Life <0>", AbilityIconString(Hero.Mercy, Button.Ability2)>, Location.Right, 0.3, Color.Blue, Color.Blue);
            hudText[3] = LastTextID();
            SmallMessage(player, "Extra Life");
            BigMessage(player, "Extra Life");

            // sound when buff is about to run out
            Wait(LIFE_DUR - 4);
            for (define sound; 4; 1)
            {
                PlayEffect(all, PlayEffect.DebuffImpactSound, Color.White, player, 100);
                Wait(1);
            }
        }
        else
        {
            CreateHudText(player, null, null, <"<0> Extra Life: Forever <0>", AbilityIconString(Hero.Mercy, Button.Ability2)>, Location.Right, 0.3, Color.White, Color.White, Color.SkyBlue);
            hudText[0] = LastTextID();
        }
    }

rule: "[Buff] :: Extra Life : Remove"
    Event.OngoingPlayer
    if (lifeEnabled && (lifeDur == 0 || (Health() == 1 || IsDead())))
    {
        ClearStatus(player, Status.Unkillable);
        Wait(0.128);

        LogToInspector(<"Extra Life Disabled for <0>", lifeUser>);

        if (Health() == 1 || IsDead())
        {
            SmallMessage(player, "Extra life used");
            PlayEffect(player, PlayEffect.DebuffImpactSound, Color.White, player, 200);
        }

        // destroy
        DestroyInWorldText(extraLifeIcon);
        DestroyProgressBarHudText(hudText[3]);
        DestroyEffect(lifeBuffEffect);
        StopChasingVariable(lifeDur);

        lifeEnabled = false;
        lifeDur = 100;

        // start in world cooldown
        LifeCooldown(); 

        Wait(1);
        SetPlayerHealth(player, MaxHealth());
    }

rule: "[Buff] :: Extra Life : Action"
    Event.OngoingPlayer
    if (lifeEnabled)
    {
        SetStatus(player, null, Status.Unkillable, 10000);

        // create effect
        CreateEffect(IsAlive() ? all : null, Effect.BadAura, Color.SkyBlue, player, 0.75, EffectRev.VisibleToPositionAndRadius);
        lifeBuffEffect = LastCreatedEntity();

        // create icon above player
        CreateInWorldText(all, AbilityIconString(Hero.Mercy, Button.Ability2), player, 2, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString);
        extraLifeIcon = LastTextID();
    }

// rule: "[Debug] :: Kill"
//     Event.OngoingPlayer
//     if (player == host && IsInteractHeld())
//     {
//         Kill();
//     }

// rule: "[Debug] :: Hud Text"
//     {
//         CreateHudText(host, null, null, <"Pos: <0>", PositionOf(host)>, Location.Top, 10);
//         CreateHudText(host, null, null, <"Facing: <0>", FacingDirectionOf(host)>, Location.Top, 10);
//     }

rule: "[Debug] :: Bots"
    Event.OngoingPlayer
    if (player == host && IsInteractHeld() && !IsCrouchHeld())
    {
        CreateDummyBot(HeroOf(), OppositeTeamOf(TeamOf()), -1, RayCastHitPosition(EyePosition(), EyePosition() + Facing() * 100), Facing() * -1);
    }

rule: "[Debug] :: Destroy Bots"
    Event.OngoingPlayer
    if (player == host && IsCrouchHeld() && IsInteractHeld())
    {
        DestroyAllDummyBots();
    }

// rule: "[Debug] :: Show OW Spawn Points"
//     if (matchStarted)
//     {
//         for (define i = 0; i < CountOf(SpawnPoints()); i++)
//             CreateEffect(all, Effect.Ring, Color.White, SpawnPoints()[i], 1, EffectRev.None);
//     }

// rule: "[Degug] :: Bots Hold Left Click"
//     Event.OngoingPlayer
//     if (IsDummyBot())
//     {
//         StartHoldingButton(player, Button.PrimaryFire);
//     }