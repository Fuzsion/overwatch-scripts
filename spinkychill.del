import "macros.del";

//globalvar define MAX_ROOT_ITEM_COUNT; // max root menu items
//globalvar define DEF_WAIT_TIME; // standard wait time for various features

//globalvar define MENU_HOLD_TIME; // time to hold interact to open/close menu
//globalvar define AUTOCLOSE_WAIT_TIME; // menu autoclose wait period

//globalvar define NO_SAFEMODE_RESTRICT; // safemode restriction toggle for host
//globalvar define NO_SAFEMODE_RESTRICT_DMG_OUT; // damage dealt - lower grav out of safemode
//globalvar define NO_SAFEMODE_RESTRICT_DMG_IN; // damage recieved - higher speed out of safemode

//globalvar define SAFEMODE_PUNISH_TIME;

//globalvar define SUDDEN_DEATH_TIME; // time in seconds when sudden death starts
//globalvar define SUDDEN_DEATH_ALLOWED; // enable/disable sudden death (host)
//globalvar define MATCH_TIME_LIMIT; // time limit in seconds

//globalvar define TELEPORT_DIST_MAX;
//globalvar define PLAYER_MIN_GRAVITY;
//globalvar define PLAYER_MAX_SPEED;

/* Global Variables */
//globalvar define mapTeleportsOut; // locations out of map
//globalvar define mapTeleportsIn; // locations into map

globalvar define inspector;
globalvar define infoTxt;
globalvar define chillestTxt;
globalvar define killestTxt;

globalvar define t_running;
globalvar define t_left;
globalvar define t_text;
globalvar define t_leftYellow;
//globalvar define t_paused;

//globalvar define suddenDeath;

globalvar define chillest; // highest chill score player
globalvar define killest; // lowest chill score player
globalvar define chillestIcon;

// text visibility arrays
//globalvar define openMenuPlayers; // open menu text players
//globalvar define closedMenuPlayers; // closed menu text players

//globalvar define chillPlayers;
//globalvar define isSkirmish;

//globalvar define paddingPlayers; // for any various texts

//globalvar define hasMapTeleports;

//globalvar define chillGroupMultiplier;

/* Player Variables & Handlers */
playervar define menuAllowed;
playervar define menu; // if the player's menu is open
playervar define selItem; // currently selected item

// text ids for menu items
//playervar define iIds0;
playervar define iIds1;
playervar define iIds2;
playervar define iIds3;
//playervar define iIds4;
//playervar define iIds5;

playervar define selId; // item text id used on closed menu
//playervar define deathId; // item text id used when dead for resurrect

playervar define p_grav;
playervar define h_grav;

playervar define p_speed;
playervar define h_speed;

playervar define safeMode;
playervar define h_safeMode;
playervar define safeModeCD; // punish

playervar define dead;
playervar define resSel;
playervar define resAllowed;
playervar define resCD;
//playervar define resTime;

//playervar define changingHero;
playervar define h_heroSel;
playervar define prevPos; // previous position on hero swap
playervar define prevAng; // previous facing angle on hero swap
playervar define tpDist; // player option for teleport distance
playervar define prevPosSafe;

playervar define h_select;

playervar define h_ability;
playervar define status;

playervar define c_score; // player score
//playervar define c_scoreCD;
//playervar define c_commCD;
//playervar define c_emoteCD;
//playervar define chillCount;
//playervar define chillestHeal;
//playervar define damageEventTime;
//playervar define healEventCooldown;
playervar define menuCD;
//playervar define joinTime;

playervar define vMode; // 1st and 3rd
//playervar define healerMode; // heal instead of damage
//playervar define healerModeText;
//playervar define canChillestBuff;
//playervar define chillestBuff;

playervar define firstSpawn;
//playervar define mapTeleportCooldown;
//playervar define hostTarget;
//playervar define hostInvis;

define item0:   "Playstyle: Kill";
define item0On: "Playstyle: Chill";
define item1:   <"Teleport (Dist: <0>)", tpDist>;
define item2:   <"Gravity: <0>%", p_grav>;
define item3:   <"Speed: <0>%", p_speed>;
define item4:   "Change View";
define item5:   "Hero Select";

define item0Selected:    "Playstyle: Kill  <";
define item0SelectedOn:  "Playstyle: Chill  <";
define item1Selected:    <"Teleport (Dist: <0>)  <", tpDist>;
define item2Selected:    <"Gravity: <0>%  <", p_grav>;
define item3Selected:    <"Speed: <0>%  <", p_speed>;
define item4Selected:    "Change View  <";
define item5Selected:    "Hero Select  <";

define Right: Location.Right;
define White: Color.White;

define InfoText(ref define text): CreateHudText(all, text, "ＶＥＲ  1.2.0.21", "Spinky and Chill", Right, -100, Color.LimeGreen);
define StatusText(ref define text, Color color): CreateHudText(VisibleTo: player, Subheader: text, Location: Location.Left, SortOrder: 1, SubheaderColor: color);

define CreateItemText(ref define text, ref define sortOrder)
{
    MinWait();
    CreateHudText(VisibleTo: player, Text: text, SortOrder: sortOrder);
    return LastTextID();
}
//////////////////////
//   Global Rules   //
//////////////////////

//rule: "Game Setup | Constants"
    //{
        //MAX_ROOT_ITEM_COUNT = 6;
        //DEF_WAIT_TIME = 2.0;
        //AUTOCLOSE_WAIT_TIME = 10.0;

        //TELEPORT_DIST_MAX = 20;

        //SAFEMODE_PUNISH_TIME = 60;

        //SUDDEN_DEATH_TIME = 30;
        //SUDDEN_DEATH_ALLOWED = false;
        //MATCH_TIME_LIMIT = 900; // seconds

        //PLAYER_MIN_GRAVITY = 20;
        //PLAYER_MAX_SPEED = 200;

        //SHOW_LEAST_CHILL = true;
    //}

rule: "Game Setup | Initialization"
    {
        t_left = 900; // MATCH_TIME_LIMIT;
        t_leftYellow = 900 / 4; // MATCH_TIME_LIMIT

        //if (CurrentGameMode() == GameMode.Skirmish)
            //isSkirmish = true;

        t_running = true;

        CreateHudText(VisibleTo: all, Text: " ", Subheader: " ", SortOrder: 0, Reevaluation: HudTextRev.VisibleToAndString);
        CreateHudText(VisibleTo: all, Text: " ", Subheader: " ", SortOrder: 0, Reevaluation: HudTextRev.VisibleToAndString);
        MinWait();
        CreateHudText(VisibleTo: all, Text: " ", Subheader: " ", SortOrder: 0, Reevaluation: HudTextRev.VisibleToAndString);
        CreateHudText(VisibleTo: all, Text: " ", Subheader: " ", SortOrder: 0, Reevaluation: HudTextRev.VisibleToAndString);
        MinWait();
    /*
        if (CurrentMap() == Map.Oasis_City_Center)
        {
            // road
            mapTeleportsOut[0] = Vector(116, 1, 220);
            mapTeleportsIn[0] = Vector(110, 0.7, 214);
            CreateEffect(all, Effect.Sphere, Color.Aqua, Vector(116, 1.5, 220), 0.8, EffectRev.VisibleToPositionAndRadius);
            CreateEffect(all, Effect.Sphere, Color.Aqua, Vector(110, 1.2, 214), 0.8, EffectRev.VisibleToPositionAndRadius);
            mapTeleportsOut[1] = Vector(999, 999, 999);
            mapTeleportsIn[1] = Vector(999, 999, 999);

            hasMapTeleports = true;
        }
        else if (CurrentMap() == Map.Eichenwalde || CurrentMap() == Map.Eichenwalde_Halloween)
        {
            // 2nd point
            mapTeleportsOut[0] = Vector(88, 13, -67);
            mapTeleportsIn[0] = Vector(90, 13, -59);
            CreateEffect(all, Effect.Sphere, Color.Aqua, Vector(88, 13.8, -67), 0.8, EffectRev.VisibleToPositionAndRadius);
            CreateEffect(all, Effect.Sphere, Color.Aqua, Vector(90, 13.8, -59), 0.8, EffectRev.VisibleToPositionAndRadius);
            mapTeleportsOut[1] = Vector(999, 999, 999);
            mapTeleportsIn[1] = Vector(999, 999, 999);

            hasMapTeleports = true;
        }
        else if (CurrentMap() == Map.Dorado)
        {
            // 1st point
            mapTeleportsOut[0] = Vector(83, 7, -4);
            mapTeleportsIn[0] = Vector(77, 7, -8);
            CreateEffect(all, Effect.Sphere, Color.Aqua, Vector(83, 7.5, -4), 0.8, EffectRev.VisibleToPositionAndRadius);
            CreateEffect(all, Effect.Sphere, Color.Aqua, Vector(77, 7.5, -8), 0.8, EffectRev.VisibleToPositionAndRadius);

            // 2nd point
            mapTeleportsOut[1] = Vector(137, 11.1, 27.5);
            mapTeleportsIn[1] = Vector(141, 11.1, 29);
            CreateEffect(all, Effect.Sphere, Color.Aqua, Vector(137, 11.9, 27.5), 0.8, EffectRev.VisibleToPositionAndRadius);
            CreateEffect(all, Effect.Sphere, Color.Aqua, Vector(141, 11.9, 29), 0.8, EffectRev.VisibleToPositionAndRadius);

            hasMapTeleports = true;
        }
    */
        SetMatchTime(900);
        PauseMatchTime();
        //SetMatchTime(754);
        DisableAnnouncer();
        DisableMusic();
        DisableScoring();
    }

rule: "Setup | Info Text"
    if (t_running)
    {
        while(t_running)
        {
            DestroyHudText(infoTxt);

            // dumb cute mode info text
            define rand = RandomInteger(0, 27);
            
            if (rand == 0)       InfoText("(.♡ω♡.)");
            else if (rand == 1)  InfoText("(Ｔ▽Ｔ)");
            else if (rand == 2)  InfoText("(｡♥‿♥｡)");
            else if (rand == 3)  InfoText("(*´▽｀*)");
            else if (rand == 4)  InfoText(" ヽ(･∀･)ﾉ ");
            else if (rand == 5)  InfoText(" (=ﾟωﾟ)ﾉ ");
            else if (rand == 6)  InfoText("☆ﾐ(o*･ω･)ﾉ ");
            else if (rand == 7)  InfoText("(Ŏ艸Ŏ)");
            else if (rand == 8)  InfoText(" (〃∀〃)ゞ ");
            else if (rand == 9)  InfoText(" (´ ▽｀).。ｏ♡ ");
            else if (rand == 10) InfoText("(ó﹏ò｡)");
            else if (rand == 11) InfoText("(・ωｰ)～☆ ");
            else if (rand == 12) InfoText("(人・ェ・)");
            else if (rand == 13) InfoText("(｡･ω･｡)ﾉ♡ ");
            else if (rand == 14) InfoText("(;; @益@)");
            else if (rand == 15) InfoText("(*´_ゝ｀)");
            else if (rand == 16) InfoText("(*＾∀゜)");
            else if (rand == 17) InfoText("。(⌒∇⌒。)");
            else if (rand == 18) InfoText("ヾ(☆▽☆)");
            else if (rand == 19) InfoText(" (づ￣ ³￣)づ ");
            else if (rand == 20) InfoText(" ∪＾ェ＾∪ ");
            else if (rand == 21) InfoText(" (●♡∀♡))ヾ☆*。 ");
            else if (rand == 22) InfoText("ヾ(^ิ∀^ิ) ");
            else if (rand == 23) InfoText("(*＾ワ＾*)");
            else if (rand == 24) InfoText(" (ﾉ•ิ_•ิ)ﾉ ");
            else if (rand == 25) InfoText("(☆^ー^☆)");
            else if (rand == 26) InfoText("(^ワ^＝)");
            else if (rand == 27) InfoText("(๑òᆺó๑)");

            infoTxt = LastTextID();
            Wait(180.111);
        }
    }

rule: "Setup | Global Text Visibility"
    {
        // open menu text
        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().menu == true), // openMenuPlayers
                      Text:         "Navigate: LMB/RMB  |  Select: Interact (tap)  |  Close: Interact (hold)",
                      TextColor:    Color.SkyBlue,
                      SortOrder:    4,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        // closed menu text
        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().menu == false), // closedMenuPlayers
                      Text:         "Menu: Interact (hold) | Quick Select: Interact (tap)",
                      TextColor:    Color.SkyBlue,
                      SortOrder:    4,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        MinWait();

        // chill mode off/unselected
        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().menu && ArrayElement().selItem != 0 && ArrayElement().safeMode == false),
                      Text:         item0,
                      SortOrder:    5,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        // chill mode on/unselected
        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().menu && ArrayElement().selItem != 0 && ArrayElement().safeMode),
                      Text:         item0On,
                      SortOrder:    5,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        MinWait();

        // chill mode off/selected
        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().selItem == 0 && ArrayElement().safeMode == false),
                      Text:         item0Selected,
                      TextColor:    Color.Aqua,
                      SortOrder:    5,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        // chill mode on/selected
        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().selItem == 0 && ArrayElement().safeMode),
                      Text:         item0SelectedOn,
                      TextColor:    Color.Aqua,
                      SortOrder:    5,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        MinWait();

        // Change view
        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().menu == true && ArrayElement().selItem != 4), // change view not
                      Text:         item4,
                      SortOrder:    9,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().selItem == 4), // change view selected
                      Text:         item4Selected,
                      TextColor:    Color.Aqua,
                      SortOrder:    9,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        MinWait();

        // hero swap
        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().menu == true && ArrayElement().selItem != 5), // hero select
                      Text:         item5,
                      SortOrder:    10,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        CreateHudText(VisibleTo:    FilteredArray(AllLivingPlayers(), ArrayElement().selItem == 5), // hero select
                      Text:         item5Selected,
                      TextColor:    Color.Aqua,
                      SortOrder:    10,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);

        MinWait();

        // res text
        CreateHudText(VisibleTo:    FilteredArray(AllDeadPlayers(), ArrayElement().resAllowed == true), // hero select
                      Text:         "Hold Interact To Resurrect",
                      TextColor:    Color.Green,
                      SortOrder:    4,
                      Reevaluation: HudTextRev.VisibleToAndString,
                      Spectators:   Spectators.VisibleNever);
                    
    }

rule: "Setup | Chillest Icon"
    {
        Wait(60);
        CreateIcon(FilteredArray(AllLivingPlayers(), ArrayElement().c_score >= 0), EyePosition(chillest) + Vector (0,0.5,0), Icon.Heart, IconRev.VisibleToAndPosition, Color.LimeGreen, false);
        chillestIcon = LastCreatedEntity();

        //CreateIcon(AllLivingPlayers(), EyePosition(leastChillPlayer) + Vector (0,0.5,0), Icon.Skull, IconRev.VisibleToAndPosition, Color.Red, false);
    }

rule: "Timer | Tick"
    if (t_running)
    //if (t_paused == false)
    {
        t_left--;
        Wait(1);
        LoopIfConditionIsTrue();
    }

rule: "Timer | End"
    if (t_left == 0)
    {
        t_running = false;
        EnableAnnouncer();
        MinWait();

        //if (isSkirmish)
        //    DeclareTeamVictory(TeamOf(chillest));
        //else
        if (chillest != 0)
            DeclarePlayerVictory(chillest);
        else if (killest != 0)
            DeclarePlayerVictory(killest);
    }

rule: "Timer | Text Update < 10"
    if (t_running)
    if (t_left % 60 < 10)
    {
        if (t_left <= 60)
        {
            DestroyHudText(t_text);
            CreateHudText(VisibleTo: all,
                    Header: <"<0>：0<1>", RoundToInteger(t_left / 60, Rounding.Down), t_left % 60>,
                    Location: Location.Top,
                    HeaderColor: Color.Red,
                    SortOrder: 5,
                    Reevaluation: HudTextRev.VisibleToAndString);
            t_text = LastTextID();
            return;
        }

        if (t_left > t_leftYellow)
        {
            DestroyHudText(t_text);
            CreateHudText(VisibleTo: all,
                    Header: <"<0>：0<1>", RoundToInteger(t_left / 60, Rounding.Down), t_left % 60>,
                    Location: Location.Top,
                    HeaderColor: Color.LimeGreen,
                    SortOrder: 5,
                    Reevaluation: HudTextRev.VisibleToAndString);
            t_text = LastTextID();
        }
        else
        {
            DestroyHudText(t_text);
            CreateHudText(VisibleTo: all,
                    Header: <"<0>：0<1>", RoundToInteger(t_left / 60, Rounding.Down), t_left % 60>,
                    Location: Location.Top,
                    HeaderColor: Color.Yellow,
                    SortOrder: 5,
                    Reevaluation: HudTextRev.VisibleToAndString);
            t_text = LastTextID();
        }
    }

rule: "Timer | Text Update >= 10"
    if (t_running)
    if (t_left % 60 >= 10)
    {
        if (t_left <= 60)
        {
            DestroyHudText(t_text);
            CreateHudText(VisibleTo: all,
                    Header: <"<0>：<1>", RoundToInteger(t_left / 60, Rounding.Down), t_left % 60>,
                    Location: Location.Top,
                    HeaderColor: Color.Red,
                    SortOrder: 5,
                    Reevaluation: HudTextRev.VisibleToAndString);
            t_text = LastTextID();
            return;
        }

        if (t_left > t_leftYellow)
        {
            DestroyHudText(t_text);
            CreateHudText(VisibleTo: all,
                    Header: <"<0>：<1>", RoundToInteger(t_left / 60, Rounding.Down), t_left % 60>,
                    Location: Location.Top,
                    HeaderColor: Color.LimeGreen,
                    SortOrder: 5,
                    Reevaluation: HudTextRev.VisibleToAndString);
            t_text = LastTextID();
        }
        else
        {
            DestroyHudText(t_text);
            CreateHudText(VisibleTo: all,
                    Header: <"<0>：<1>", RoundToInteger(t_left / 60, Rounding.Down), t_left % 60>,
                    Location: Location.Top,
                    HeaderColor: Color.Yellow,
                    SortOrder: 5,
                    Reevaluation: HudTextRev.VisibleToAndString);
            t_text = LastTextID();
        }
    }

rule: "Timer | 60 Seconds Left"
    if (t_left == 60)
    {
        BigMessage(all, "ONE MINUTE REMAINING");
    }

rule: "Scoring | Display Initial"
    {
        CreateHudText(VisibleTo: all, Subheader: " ", Location: Location.Right, SortOrder: -97, Reevaluation: HudTextRev.VisibleToAndString);

        MinWait();

        CreateHudText(AllLivingPlayers(), IconString(Icon.QuestionMark), "ｃｈｉｌｌｅｓｔ                               ", "???", Location.Right, -96, Color.Aqua, Color.White, Color.White, HudTextRev.VisibleToAndString);
        chillestTxt = LastTextID();

        MinWait();

        CreateHudText(AllLivingPlayers(), IconString(Icon.QuestionMark), "ｋｉｌｌｅｓｔ  ", "???", Location.Right, -95, Color.Red, Color.White, Color.White, HudTextRev.VisibleToAndString);
        killestTxt = LastTextID();
    }

rule: "Scoring | Display Chillest"
    if (chillest != 0)
    {
        WaitIfTrue(25);
        DestroyHudText(chillestTxt);
        CreateHudText(AllLivingPlayers(), HeroIconString(HeroOf(chillest)), "ｃｈｉｌｌｅｓｔ                               ", chillest, Location.Right, -96, Color.Aqua, Color.White, Color.White, HudTextRev.VisibleToAndString);
        chillestTxt = LastTextID();
    }

rule: "Scoring | Display Killest"
    if (killest != 0)
    {
        WaitIfTrue(25);
        DestroyHudText(killestTxt);
        CreateHudText(AllLivingPlayers(), HeroIconString(HeroOf(killest)), "ｋｉｌｌｅｓｔ  ", killest, Location.Right, -95, Color.Red, Color.White, Color.White, HudTextRev.VisibleToAndString);
        killestTxt = LastTextID();
    }


//////////////////////
//   Player Rules   //
//////////////////////

void AbilityHandler() "Player Subroutine | Ability Handler"
{
    h_ability = true;

    if (!menu)
    {
        AllowPrimary();
        AllowSecondary();
    }

    AllowAbility1();
    AllowAbility2();
    AllowUlt();

    // for any hero with no specific rule
    Wait(0.11);
    if (h_ability)
        h_ability = false;
}

void ChangeView() "Player Subroutine | Change Camera View"
{
    if (vMode == 1)
        StartCamera(player, (player + Vector(0,YOf(EyePosition() - player),0)) + (Facing() * -2.1) + (WorldVectorOf(Right(), player, LocalVector.Rotation) * 0.5),
                    (player + (EyePosition() - player)) + (Facing() * 20), 100);
    else if (vMode == 2)
        StartCamera(player, (player + Vector(0,YOf(EyePosition() - player),0)) + (Facing() * -2.1) + (WorldVectorOf(Right(), player, LocalVector.Rotation) * -0.5),
                    (player + (EyePosition() - player)) + (Facing() * 20), 100);
    else
        StopCamera();
}

rule: "Player Join"
    Event.OnPlayerJoin
    {
        tpDist = 8;
        menuAllowed = true;
        MinWait();
        firstSpawn = true;
        p_grav = 100;
        p_speed = 100;
        MinWait();
        CreateHudText(VisibleTo: player, Text: " ", Location: Location.Left, SortOrder: 1, Reevaluation: HudTextRev.VisibleToAndString);
        status = LastTextID();
    }

rule: "Player Leave"
    Event.OnPlayerLeave
    {
        if (player == killest)
            killest = LastOf(FilteredArray(SortedArray(all, ArrayElement().c_score), ArrayElement().c_score < 0));

        if (player == chillest)
            chillest = FirstOf(FilteredArray(SortedArray(all, ArrayElement().c_score), ArrayElement().c_score > 0));
    }

rule: "Player Join | First Spawn"
    Event.OngoingPlayer
    if (firstSpawn)
    if (HasSpawned())
    {
        BigMessage(player, "ヾ(^ิ∀^ิ) Welcome to the lobby!");
        Wait(4);
        SmallMessage(player, "(ﾉ•ิ_•ิ)ﾉ To open the menu, hold interact (F)!");
        Wait(4);

        // dumb cute shit
        define random = RandomInteger(0, 27);

        if (random == 0)       SmallMessage(player, "(.♡ω♡.) Enjoy your stay!");
        else if (random == 1)  SmallMessage(player, "(Ｔ▽Ｔ) Have fun!");
        else if (random == 2)  SmallMessage(player, "(｡♥‿♥｡) Smile!");
        else if (random == 3)  SmallMessage(player, "(*´▽｀*)");
        else if (random == 4)  SmallMessage(player, "ヽ(･∀･)ﾉ Remember MVC!");
        else if (random == 5)  SmallMessage(player, "(=ﾟωﾟ)ﾉ ");
        else if (random == 6)  SmallMessage(player, "☆ﾐ(o*･ω･)ﾉ ");
        else if (random == 7)  SmallMessage(player, "(Ŏ艸Ŏ) CHILL/KILL DON'T CHILL KILLERS");
        else if (random == 8)  SmallMessage(player, "(〃∀〃)ゞ uh ohhhh spinkyyy");
        else if (random == 9)  SmallMessage(player, "(´ ▽｀).。ｏ♡ ");
        else if (random == 10) SmallMessage(player, "(ó﹏ò｡) are u scared?");
        else if (random == 11) SmallMessage(player, "(・ωｰ)～☆ winky face~");
        else if (random == 12) SmallMessage(player, "(人・ェ・) i love u mr bubz");
        else if (random == 13) SmallMessage(player, "(｡･ω･｡)ﾉ♡ Also try MangoMode!");
        else if (random == 14) SmallMessage(player, "(;; @益@) CHILL ALL KILLERS");
        else if (random == 15) SmallMessage(player, "(*´_ゝ｀) BARRY WHAT IS THAT");
        else if (random == 16) SmallMessage(player, "(*＾∀゜)");
        else if (random == 17) SmallMessage(player, "。(⌒∇⌒。)");
        else if (random == 18) SmallMessage(player, "ヾ(☆▽☆)");
        else if (random == 19) SmallMessage(player, "(づ￣ ³￣)づ ");
        else if (random == 20) SmallMessage(player, "∪＾ェ＾∪ woof");
        else if (random == 21) SmallMessage(player, "(●♡∀♡))ヾ☆*。 ");
        else if (random == 22) SmallMessage(player, "ヾ(^ิ∀^ิ) ");
        else if (random == 23) SmallMessage(player, "(*＾ワ＾*)");
        else if (random == 24) SmallMessage(player, "(ﾉ•ิ_•ิ) u wot");
        else if (random == 25) SmallMessage(player, "(☆^ー^☆)");
        else if (random == 26) SmallMessage(player, "(^ワ^＝)");
        else if (random == 27) SmallMessage(player, "(๑òᆺó๑)");

        firstSpawn = false;
    }

rule: "Menu | Open"
    Event.OngoingPlayer
    if (IsAlive())
    if (IsInteractHeld())
    if (menuCD == false)
    if (resSel == false)
    if (menu == false)
    {
        WaitIfTrue(0.2); // require holding briefly to prevent spam

        menuCD = true;

        SetPrimaryFireEnabled(player, false);
        SetSecondaryFireEnabled(player, false);

        if (selItem == 0)
        {
            iIds1 = CreateItemText(item1, 6);
            iIds2 = CreateItemText(item2, 7);
            iIds3 = CreateItemText(item3, 8);
        }
        else if (selItem == 1)
        {
            DestroyHudText(selId);

            MinWait();
            CreateHudText(VisibleTo: player, Text: item1Selected, TextColor: Color.Aqua, SortOrder: 6);
            selId = LastTextID();

            iIds2 = CreateItemText(item2, 7);
            iIds3 = CreateItemText(item3, 8);
        }
        else if (selItem == 2)
        {
            //DestroyHudText(selId);

            iIds1 = CreateItemText(item1, 6);

            //MinWait();
            //CreateHudText(VisibleTo: player, Text: item2Selected, TextColor: Color.Aqua, SortOrder: 7);
            //selId = LastTextID();

            iIds3 = CreateItemText(item3, 8);
        }
        else if (selItem == 3)
        {
            //DestroyHudText(selId);

            iIds1 = CreateItemText(item1, 6);
            iIds2 = CreateItemText(item2, 7);

            //MinWait();
            //CreateHudText(VisibleTo: player, Text: item3Selected, TextColor: Color.Aqua, SortOrder: 8);
            //selId = LastTextID();
        }
        else if (selItem == 4)
        {
            iIds1 = CreateItemText(item1, 6);
            iIds2 = CreateItemText(item2, 7);
            iIds3 = CreateItemText(item3, 8);
        }
        else if (selItem == 5)
        {
            iIds1 = CreateItemText(item1, 6);
            iIds2 = CreateItemText(item2, 7);
            iIds3 = CreateItemText(item3, 8);
        }

        menu = true;
        Wait(1.1);
        menuCD = false;
    }

rule: "Menu | Close"
    Event.OngoingPlayer
    if (IsAlive())
    if (IsInteractHeld())
    if (menuCD == false)
    if (resSel == false)
    if (menu)
    {
        WaitIfTrue(0.2); // require holding briefly to prevent spam

        menu = false; // disable first

        DestroyHudText(iIds1);
        DestroyHudText(iIds2);
        DestroyHudText(iIds3);
        MinWait();

        if (safeMode)
            AbilityHandler();
        else
        {
            AllowPrimary();
            AllowSecondary();
            AllowUlt();
        }

        menuCD = true;
        Wait(1.1);
        menuCD = false;
    }

rule: "Menu | Select Controller On"
    Event.OngoingPlayer
    if (IsAlive())
    if (IsInteractHeld())
    if (IsSecondaryHeld() == false)
    if (IsPrimaryHeld() == false)
    if (resSel == false)
    if (h_heroSel == false)
    if (h_safeMode == false)
    {
        h_select = true;
    }

rule: "Menu | Select Controller Off"
    Event.OngoingPlayer
    if (IsDead() || IsInteractHeld() == false || IsSecondaryHeld() || IsPrimaryHeld() || resSel || h_heroSel || h_safeMode)
    {
        h_select = false;
    }

rule: "Menu | Select 0 - Playstyle"
    Event.OngoingPlayer
    if (selItem == 0)
    if (h_select)
    {
        Wait(0.11);
        AbortIf(IsInteractHeld());

        if (!h_safeMode && !safeModeCD && !h_ability && IsOnGround())
        {
            ChangePlaystyle();
        }
        else if (!IsOnGround())
        {
            SmallMessage(player, "You must be on the ground to change playstyle!");
        }
    }

rule: "Menu | Select 1 - Teleport"
    Event.OngoingPlayer
    if (selItem == 1)
    if (h_select)
    if (safeMode)
    {
        Wait(0.11);
        AbortIf(IsInteractHeld());

        prevAng = Facing();
        Teleport(player, PositionOf() + (prevAng * tpDist));
        SetFacing(player, prevAng);
    }

rule: "Menu | Select 2 - Player Gravity"
    Event.OngoingPlayer
    if (selItem == 2)
    if (h_select)
    if (h_grav == false)
    if (safeMode)
    {
        Wait(0.11);
        AbortIf(IsInteractHeld());
        ChangeGravity();
    }

rule: "Menu | Select 3 - Player Speed"
    Event.OngoingPlayer
    if (selItem == 3)
    if (h_select)
    if (h_speed == false)
    if (safeMode)
    {
        Wait(0.11);
        AbortIf(IsInteractHeld());
        ChangeSpeed();
    }

rule: "Menu | Select 4 - Change View"
    Event.OngoingPlayer
    if (selItem == 4)
    if (h_select)
    {
        Wait(0.11);
        AbortIf(IsInteractHeld());

        vMode++;

        if (vMode == 3)
            vMode = 0;

        ChangeView();
    }

rule: "Menu | Item 5 - Hero Select"
    Event.OngoingPlayer
    if (selItem == 5)
    if (h_select)
    {
        Wait(0.1);
        AbortIf(IsInteractHeld());

        h_heroSel = true;
    }

rule: "Menu | Next"
    Event.OngoingPlayer
    if (menu)
    if (IsPrimaryHeld())
    if (IsInteractHeld() == false)
    if (IsSecondaryHeld() == false)
    {
        WaitIfTrue(0.032);

        if (selItem == 5)//MAX_ROOT_ITEM_COUNT - 1) // safe mode
        {
            selItem = 0;
        }
        else
        {
            selItem++;

            if (!safeMode && selItem == 1)
                selItem = 4;
        }

        MinWait();

        if (selItem == 1) // teleport
        {
            DestroyHudText(iIds1);
            CreateHudText(VisibleTo: player, Text: item1Selected, TextColor: Color.Aqua, SortOrder: 6);
            MinWait();
            selId = LastTextID();
        }
        else if (selItem == 2) // gravity
        {
            DestroyHudText(selId);
            MinWait();
            CreateHudText(VisibleTo: player, Text: item1, SortOrder: 6);
            iIds1 = LastTextID();

            DestroyHudText(iIds2);
            CreateHudText(VisibleTo: player, Text: item2Selected, TextColor: Color.Aqua, SortOrder: 7);
            MinWait();
            selId = LastTextID();
        }
        else if (selItem == 3) // speed
        {
            DestroyHudText(selId);
            MinWait();
            CreateHudText(VisibleTo: player, Text: item2, SortOrder: 7);
            iIds2 = LastTextID();

            DestroyHudText(iIds3);
            CreateHudText(VisibleTo: player, Text: item3Selected, TextColor: Color.Aqua, SortOrder: 8);
            MinWait();
            selId = LastTextID();
        }
        else if (selItem == 4 && safeMode) // view
        {
            DestroyHudText(selId);
            CreateHudText(VisibleTo: player, Text: item3, SortOrder: 8);
            iIds3 = LastTextID();
        }
    }

rule: "Menu | Previous"
    Event.OngoingPlayer
    if (menu)
    if (IsSecondaryHeld())
    if (IsPrimaryHeld() == false)
    if (IsInteractHeld() == false)
    {
        WaitIfTrue(0.032);

        if (selItem == 0)
        {
            selItem = 5;//MAX_ROOT_ITEM_COUNT - 1;
        }
        else
        {
            selItem--;

            if (!safeMode && selItem == 3)
                selItem = 0;
        }

        MinWait();

        // reverse order for possible optimization
        if (selItem == 3) // speed, change view not required (used to be above this)
        {
            DestroyHudText(iIds3);
            CreateHudText(VisibleTo: player, Text: item3Selected, TextColor: Color.Aqua, SortOrder: 8);
            selId = LastTextID();
        }
        else if (selItem == 2) // gravity
        {
            DestroyHudText(iIds2);
            MinWait();
            CreateHudText(VisibleTo: player, Text: item2Selected, TextColor: Color.Aqua, SortOrder: 7);
            DestroyHudText(selId);
            selId = LastTextID();

            CreateHudText(VisibleTo: player, Text: item3, SortOrder: 8);
            MinWait();
            iIds3 = LastTextID();
        }
        else if (selItem == 1) // teleport
        {
            DestroyHudText(iIds1);
            MinWait();
            CreateHudText(VisibleTo: player, Text: item1Selected, TextColor: Color.Aqua, SortOrder: 6);
            DestroyHudText(selId);
            selId = LastTextID();

            CreateHudText(VisibleTo: player, Text: item2, SortOrder: 7);
            MinWait();
            iIds2 = LastTextID();
        }
        else if (selItem == 0 && safeMode) // safe mode
        {
            DestroyHudText(selId);
            CreateHudText(VisibleTo: player, Text: item1, SortOrder: 6);
            iIds1 = LastTextID();
        }
    }

rule: "Menu | Auto-Close"
    Event.OngoingPlayer
    if (menu)
    if (IsPrimaryHeld() == false)
    if (IsSecondaryHeld() == false)
    if (IsInteractHeld() == false)
    if (IsUltHeld() == false)
    {
        WaitIfTrue(10); // AUTOCLOSE_WAIT_TIME
        menu = false; // disable first

        DestroyHudText(iIds1);
        DestroyHudText(iIds2);
        DestroyHudText(iIds3);
        MinWait();

        if (safeMode)
            AbilityHandler();
        else
        {
            AllowPrimary();
            AllowSecondary();
            AllowUlt();
        }
    }

void ChangePlaystyle() "Player Subroutine | Change Playstyle"
{
    safeMode = !safeMode;
    h_safeMode = true;

    if (safeMode)
    {
        SmallMessage(player, "enabling chillmode");

        SetStatus(player, null, Status.Stunned, 2); // DEF_WAIT_TIME
        MinWait();
        SetStatus(player, null, Status.Invincible, 900);
        SetStatus(player, null, Status.PhasedOut, 900);
        MinWait();

        SetDamageDealt(player, 0);
        //SetHealingDealt(player, 0);
        MinWait();

        prevPosSafe = PositionOf();

        if (c_score < -30)
            c_score += 5;

        SetGravity(player, p_grav);
        SetMoveSpeed(player, p_speed);
        MinWait();

        h_safeMode = false;
        AbilityHandler();
    }
    else
    {
        SmallMessage(player, "disabling chillmode");

        SetGravity(player, 100);
        SetMoveSpeed(player, 100);
        MinWait();

        ClearStatus(player, Status.Invincible);
        ClearStatus(player, Status.PhasedOut);
        MinWait();
        SetStatus(player, null, Status.Stunned, 2); // DEF_WAIT_TIME
        MinWait();
        SetStatus(player, null, Status.Invincible, 2); // DEF_WAIT_TIME
        SetStatus(player, null, Status.PhasedOut, 2); // DEF_WAIT_TIME
        Wait(2); // DEF_WAIT_TIME

        SetDamageDealt(player, 100);
        //SetHealingDealt(player, 100);
        MinWait();
        Teleport(player, prevPosSafe);
        Wait(2); // DEF_WAIT_TIME

        h_safeMode = false;

        if (!menu)
        {
            AllowPrimary();
            MinWait();
            AllowSecondary();
        }

        AllowUlt();
        MinWait();
        AllowAbility1();
        AllowAbility2();
    }
}

void ChangeGravity() "Player Subroutine | Change Gravity"
{
    h_grav = true;
    Wait(0.064);

    if (p_grav <= 20) // PLAYER_MIN_GRAVITY
        p_grav = 100;
    else
        p_grav -= 20;

    SetGravity(player, p_grav);
    h_grav = false;
}

void ChangeSpeed() "Player Subroutine | Change Speed"
{
    h_speed = true;
    Wait(0.064);

    if (p_speed < 220) // PLAYER_MAX_SPEED
        p_speed += 20;
    else
        p_speed = 100;

    SetMoveSpeed(player, p_speed);
    h_speed = false;
}

rule: "Chill | Punishment (env kills)"
    Event.OnElimination
    if (safeMode)
    if (safeModeCD == false)
    {
        safeMode = false;
        h_safeMode = true;
        safeModeCD = true;
        SmallMessage(player, "Chill playstyle disabled for 30 seconds!"); // SAFEMODE_PUNISH_TIME
        Wait(30); // SAFEMODE_PUNISH_TIME
        safeModeCD = false;
    }

rule: "Chill | Damage Taken"
    Event.OnDamageTaken
    if (safeMode == false)
    if (safeModeCD == false)
    {
        safeModeCD = true;
        Wait(5);
        safeModeCD = false;
    }

/* Teleport */
// rule: "Teleport | Distance"
//     Event.OngoingPlayer
//     if (selItem == 1)
//     if (menu)
//     if (IsUltHeld())
//     {
//         WaitIfTrue(0.064);

//         if (tpDist < 16) // TELEPORT_DIST_MAX
//             tpDist += 2;
//         else
//             tpDist = 8;
//     }

/* Select Hero */
rule: "Hero Select | Handler"
    Event.OngoingPlayer
    if (h_heroSel)
    {
        prevPos = PositionOf();
        prevAng = Facing();
        menu = false; // disable first
        MinWait();
        DestroyHudText(iIds1);
        DestroyHudText(iIds2);
        DestroyHudText(iIds3);
        MinWait();
        DestroyHudText(selId);
        DestroyHudText(status);

        if (safeMode)
        {
            ClearStatus(player, Status.Invincible);
            ClearStatus(player, Status.PhasedOut);
        }

        SetStatus(player, null, Status.Stunned, 2);
        MinWait();
        SetStatus(player, null, Status.Invincible, 2);
        SetStatus(player, null, Status.PhasedOut, 2);
        Wait(2);
        SetHeroRoster(player, RemoveFromArray(AllHeroes(), HeroOf()));
        Wait(0.2);
        ResetHeroRoster();
    }

rule: "Hero Select | Selected"
    Event.OngoingPlayer
    if (h_heroSel)
    if (HasSpawned() == false)
    {
        Wait(0.3);
        LoopIfConditionIsTrue();

        h_heroSel = false;

        Teleport(player, prevPos);
        SetFacing(player, prevAng);
        MinWait();
        prevPos = 0;
        prevAng = 0;
        MinWait();

        if (safeMode)
        {
            SetStatus(player, null, Status.Invincible, 900);
            SetStatus(player, null, Status.PhasedOut, 900);
            MinWait();
            AbilityHandler();
        }
        else
        {
            AllowPrimary();
            AllowSecondary();
            AllowAbility1();
            AllowAbility2();
            AllowUlt();
        }
    }

/* Resurrect */
rule: "Res | Selected"
    Event.OngoingPlayer
    if (IsDead())
    if (resCD == false)
    if (resSel)
    if (resAllowed)
    {
        Resurrect();
        MinWait();

        SetStatus(player, null, Status.Asleep, 2);
        MinWait();
        SetStatus(player, null, Status.Invincible, 2);
        SetStatus(player, null, Status.PhasedOut, 2);

        Wait(2);
        resSel = false;
        resCD = true;
        Wait(13);
        resCD = false;
    }

rule: "Res | Handler"
    Event.OngoingPlayer
    if (IsDead())
    if (IsInteractHeld())
    if (resSel == false)
    if (resAllowed)
    {
        Wait(0.75);
        AbortIfConditionIsFalse();
        resSel = true;
    }

rule: "Res | Error Check"
    Event.OngoingPlayer
    if (IsDead())
    {
        Wait(14.855);
        AbortIfConditionIsFalse();
        Respawn();
    }

/* View Mode */
rule: "View Mode | Ana On"
    Event.OngoingPlayer
    Player.Ana
    if (vMode > 0)
    if (IsFiringSecondary())
    if (IsSecondaryHeld())
    {
        WaitIfTrue(0.22);
        StopCamera();
    }

rule: "View Mode | Ana Off"
    Event.OngoingPlayer
    Player.Ana
    if (vMode > 0)
    if (IsFiringSecondary())
    if (IsSecondaryHeld() == false)
    {
        ChangeView();
    }

rule: "View Mode | Widow On"
    Event.OngoingPlayer
    Player.Widowmaker
    if (vMode > 0)
    if (IsFiringSecondary())
    if (IsSecondaryHeld())
    {
        WaitIfTrue(0.26);
        StopCamera();
    }

rule: "View Mode | Widow Off"
    Event.OngoingPlayer
    Player.Widowmaker
    if (vMode > 0)
    if (IsFiringSecondary())
    if (IsSecondaryHeld() == false)
    {
        ChangeView();
    }

rule: "View Mode | Ashe On"
    Event.OngoingPlayer
    Player.Ashe
    if (vMode > 0)
    if (IsFiringSecondary())
    {
        WaitIfTrue(0.05);
        StopCamera();
    }

rule: "View Mode | Ashe Off"
    Event.OngoingPlayer
    Player.Ashe
    if (vMode > 0)
    if (IsFiringSecondary())
    if (IsSecondaryHeld() == false)
    {
        ChangeView();
    }

rule: "Scoring | Displays +"
    Event.OngoingPlayer
    if (IsAlive())
    if (c_score >= 20)
    {
        WaitIfTrue(201.5);
        DestroyHudText(status);
        define rand2 = RandomInteger(0, 7);

        if (rand2 == 0)      StatusText("Ｃｈｉｌｌｉｎｇ  ｏｕｔ．．． ", Color.LimeGreen);
        else if (rand2 == 1) StatusText("ｃｈｉｌｌ  ｌｅｖｅｌ：  ｌｏｆｉ ", Color.Green);
        else if (rand2 == 2) StatusText("Ｓｐｒｅａｄｉｎｇ  ｇｏｏｄ  ｖｉｂｅｓ．．． ", Color.SkyBlue);
        else if (rand2 == 3) StatusText("ｓｐｉｎｋｙ  ｌｏｖｅｓ  ｕ ", Color.Turquoise);
        else if (rand2 == 4) StatusText("ｃｈｉｌｌ  ｌｅｖｅｌ：  ｓｙｎｔｈｗａｖｅ ", Color.Aqua);
        else if (rand2 == 5) StatusText("ＡＥＳＴＨＥＴＩＣ ＆ ＣＨＩＬＬ ", Color.Purple);
        else if (rand2 == 6) StatusText("Ａｌｌ  ｃｈｉｌｌ  ｎｏ  ｋｉｌｌ ", Color.LimeGreen);
        else if (rand2 == 7) StatusText(<"Ｙｏｕ  ｈａｖｅ  <0>  ｃｈｉｌｌ ", RoundToInteger(c_score, Rounding.Nearest)>, Color.LimeGreen);

        status = LastTextID();
        Loop();
    }

rule: "Scoring | Displays -"
    Event.OngoingPlayer
    if (c_score < 20 || IsDead())
    {
        DestroyHudText(status);
        //CreateHudText(VisibleTo: player, Text: " ", Location: Location.Top, SortOrder: 1, Reevaluation: StringRev.VisibleToAndString);
        //status = LastTextID();
    }

rule: "Scoring | Chillest Update"
    Event.OngoingPlayer
    if (t_running && c_score > chillest.c_score)
    {
        chillest = player;
    }

rule: "Scoring | Killest Update"
    Event.OngoingPlayer
    if (t_running && c_score < killest.c_score)
    {
        killest = player;
    }

rule: "Scoring | Base Chill Gain"
    Event.OngoingPlayer
    if (safeMode)
    {
        WaitIfTrue(7.51);
        c_score += 2;
        Loop();
    }

rule: "Scoring | Base Chill Loss"
    Event.OngoingPlayer
    if (safeMode == false)
    if (c_score > 0)
    {
        WaitIfTrue(7.51);
        c_score -= 2;
        Loop();
    }

// rule: "Scoring | Voice Line & Targeting"
//     Event.OngoingPlayer
//     if (IsCommunicatingAnyVoiceLine())
//     if (Time() - c_commCD > 11.68)
//     {
//         //if (RayCastHitPlayer(EyePosition(), EyePosition() + (Facing() * 4), AllLivingPlayers(), player, false) != null)
//         //{
//             c_score += 2;
//         //}
//         //else
//         //{
//             //c_score++;
//         //}

//         c_commCD = Time();
//     }

rule: "Scoring | Emote"
    Event.OngoingPlayer
    if (IsCommunicatingAnyEmote())
    {
        WaitIfTrue(3.31);
        c_score += 0.4;
        Loop();
    }

// rule: "Scoring | Jumping around cuz why not"
//     Event.OngoingPlayer
//     if (throttle == false)
//     if (p_grav <= 20)
//     if (p_speed >= 200)
//     if (IsInAir())
//     {
//         Wait(3.943);
//         AbortIfConditionIsFalse();
//         c_score++;
//         LoopIf();
//     }
/*
rule: "Scoring | Damage Dealt"
    Event.OnDamageDealt
    if (Time() - damageEventTime > 5)
    {
        damageEventTime = Time();
        if (c_score <= 0)
            c_score--;
        else
            c_score -= 8;
    }*/

rule: "Scoring | Final Blow - Killer"
    Event.OnFinalBlow
    if (Victim() != player)
    if (c_score <= 0)
    {
        c_score--;
        StartHealOverTime(player, null, 2, MaxHealth() / 6);
    }

rule: "Scoring | Final Blow - Chiller"
    Event.OnFinalBlow
    if (Victim() != player)
    if (c_score > 0)
    {
        c_score -= 15;
        StartHealOverTime(player, null, 2, MaxHealth() / 6);
    }

rule: "Scoring | Final Blow - On Killest"
    Event.OnFinalBlow
    if (Victim() == killest)
    if (Victim() != player)
    {
        MinWait(); // pass this to the next frame
        c_score -= 5;
    }

/*
rule: "Scoring | Buff Updates"
    Event.OngoingPlayer
    if (c_score >= 25)
    {
        if (c_score < 50)
            SetMaxHealth(player, 110);
        else if (c_score < 100)
            SetMaxHealth(player, 120);
        else if (c_score >= 100)
            SetMaxHealth(player, 130);
        else if (c_score >= 200)
            SetMaxHealth(player, 150);

        Wait(30);
        LoopIfConditionIsTrue();
    }

rule: "Scoring | Remove Buff"
    Event.OngoingPlayer
    if (c_score < 25)
    {
        SetMaxHealth(player, 100);
    }

rule: "Chillest Player | Heal Others"
    Event.OngoingPlayer
    if (safeMode)
    if (DistanceBetween(player, chillest) < 5)
    if (Health() < MaxHealth())
    if (chillestHeal == 0)
    {
        StartHealOverTime(player, chillest, 8, 20);
        chillestHeal = LastHealOverTime();
    }

rule: "Chillest Player | Heal Others (stop)"
    Event.OngoingPlayer
    if (!safeMode || (IsAlive() && DistanceBetween(player, chillest) > 5))
    {
        StopHealOverTime(chillestHeal);
        chillestHeal = 0;
    }*/

/* General */
// rule: "Dead"
//     Event.OnDeath
//     {
//         if (menu)
//         {
//             ClosePlayerMenuOnDeath();
//         }
//         else
//         {
//             //closedMenuPlayers = RemoveFromArray(closedMenuPlayers, player);
//             MinWait();
//             DestroyHudText(selId);
//         }

//         MinWait();
//         dead = true;

//         if (Attacker() != player && !resCD && !throttle)
//         {
//             CreateHudText(VisibleTo: player, Text: "Hold Interact To Resurrect", TextColor: Color.Aqua, SortOrder: 4);
//             deathId = LastTextID();
//             MinWait();
//             resAllowed = true;
//         }
//         else
//         {
//             resAllowed = false;
//         }
//     }

rule: "Dead"
    Event.OnDeath
    {
        MinWait();
        if (menu)
        {
            menu = false; // disable first

            DestroyHudText(iIds1);
            DestroyHudText(iIds2);
            DestroyHudText(iIds3);
            MinWait();
            DestroyHudText(selId);
            DestroyHudText(status);
        }
        else
        {
            MinWait();
            DestroyHudText(selId);
        }

        MinWait();
        dead = true;
    }

rule: "Dead | Resurrect Enabled"
    Event.OnDeath
    if (Attacker() != player)
    if (resCD == false)
    if (safeMode == false)
    {
        resAllowed = true;
    }

rule: "Dead | Resurrect Disabled"
    Event.OnDeath
    if (Attacker() == player || resCD)
    {
        resAllowed = false;
    }

rule: "Player | Respawn Updates"
    Event.OngoingPlayer
    if (IsAlive())
    {
        if (dead)
        {
            if (selItem == 1) // teleport
            {
                CreateHudText(VisibleTo: player, Text: item1Selected, TextColor: Color.Aqua, SortOrder: 5, Spectators: Spectators.VisibleNever);
                selId = LastTextID();
            }
            else if (selItem == 2) // grav
            {
                CreateHudText(VisibleTo: player, Text: item2Selected, TextColor: Color.Aqua, SortOrder: 5, Spectators: Spectators.VisibleNever);
                selId = LastTextID();
            }
            else if (selItem == 3) // speed
            {
                CreateHudText(VisibleTo: player, Text: item3Selected, TextColor: Color.Aqua, SortOrder: 5, Spectators: Spectators.VisibleNever);
                selId = LastTextID();
            }
            MinWait();
            dead = false;
        }

        if (safeMode)
        {
            SetStatus(player, null, Status.Invincible, 900);
            MinWait();
            SetStatus(player, null, Status.PhasedOut, 900);
        }
    }

rule: "Dva Demech"
    Event.OngoingPlayer
    Player.Dva
    if (Health() > 150)
    if (IsUltHeld())
    if (UltimateChargePercent() < 95)
    {
        WaitIfTrue(2);

        if (!safeMode)
            Damage(player, null, 1000);
        else
        {
            ClearStatus(player, Status.Invincible);
            ClearStatus(player, Status.PhasedOut);
            Wait(0.25);
            Damage(player, null, 1000);
            Wait(0.5);
            SetStatus(player, null, Status.Invincible, 900);
            SetStatus(player, null, Status.PhasedOut, 900);
        }
    }

rule: "Dva Demech Message"
    Event.OngoingPlayer
    Player.Dva
    if (HasSpawned())
    if (safeMode == false)
    {
        Wait(2);
        SmallMessage(player, "Hold Q to demech!");
    }

/* Abilities */
rule: "Abilities | General"
    Event.OngoingPlayer
    if (h_ability)
    {
        if (!menu)
        {
            AllowPrimary();
            AllowSecondary();
        }

        AllowAbility1();
        AllowAbility2();
        AllowUlt();

        // for any hero with no specific rule
        Wait(0.11);
        if (h_ability)
            h_ability = false;
    }

rule: "Abilities | Ana"
    Event.OngoingPlayer
    Player.Ana
    if (h_ability)
    {
        Wait(0.08);
        SetAbility1Enabled(player, false);
        SetAbility2Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Ashe"
    Event.OngoingPlayer
    Player.Ashe
    if (h_ability)
    {
        Wait(0.08);
        SetAbility1Enabled(player, false);
        SetAbility2Enabled(player, false);
        SetUltimateAbilityEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Roadhog"
    Event.OngoingPlayer
    Player.Roadhog
    if (h_ability)
    {
        Wait(0.08);
        SetAbility1Enabled(player, false);
        SetUltimateAbilityEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Reinhardt"
    Event.OngoingPlayer
    Player.Reinhardt
    if (h_ability)
    {
        Wait(0.08);
        SetSecondaryFireEnabled(player, false);
        SetAbility1Enabled(player, false);
        MinWait();
        SetAbility2Enabled(player, false);
        SetUltimateAbilityEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Sigma"
    Event.OngoingPlayer
    Player.Sigma
    if (h_ability)
    {
        Wait(0.08);
        SetPrimaryFireEnabled(player, false);
        SetSecondaryFireEnabled(player, false);
        SetAbility1Enabled(player, false);
        MinWait();
        SetAbility2Enabled(player, false);
        SetUltimateAbilityEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Brigitte"
    Event.OngoingPlayer
    Player.Brigitte
    if (h_ability)
    {
        Wait(0.08);
        SetPrimaryFireEnabled(player, false);
        SetSecondaryFireEnabled(player, false);
        SetAbility1Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Genji"
    Event.OngoingPlayer
    Player.Genji
    if (h_ability)
    {
        Wait(0.08);
        SetAbility2Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Junkrat"
    Event.OngoingPlayer
    Player.Junkrat
    if (h_ability)
    {
        Wait(0.08);
        SetPrimaryFireEnabled(player, false);
        SetSecondaryFireEnabled(player, false);
        SetAbility1Enabled(player, false);
        MinWait();
        SetAbility2Enabled(player, false);
        SetUltimateAbilityEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Doomfist"
    Event.OngoingPlayer
    Player.Doomfist
    if (h_ability)
    if (player != host)
    {
        Wait(0.08);
        SetPrimaryFireEnabled(player, false);
        SetSecondaryFireEnabled(player, false);
        MinWait();
        SetAbility1Enabled(player, false);
        SetAbility2Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Mei"
    Event.OngoingPlayer
    Player.Mei
    if (h_ability)
    {
        Wait(0.08);
        SetUltimateAbilityEnabled(player, false);
        SetAbility1Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | McCree"
    Event.OngoingPlayer
    Player.Mccree
    if (h_ability)
    {
        Wait(0.08);
        SetAbility2Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Pharah"
    Event.OngoingPlayer
    Player.Pharah
    if (h_ability)
    {
        Wait(0.08);
        SetPrimaryFireEnabled(player, false);
        SetAbility2Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Winston"
    Event.OngoingPlayer
    Player.Winston
    if (h_ability)
    {
        Wait(0.08);
        SetUltimateAbilityEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Sombra"
    Event.OngoingPlayer
    Player.Sombra
    if (h_ability)
    {
        Wait(0.08);
        SetUltimateAbilityEnabled(player, false);
        SetSecondaryFireEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Lucio"
    Event.OngoingPlayer
    Player.Lucio
    if (h_ability)
    {
        Wait(0.08);
        SetSecondaryFireEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Orisa"
    Event.OngoingPlayer
    Player.Orisa
    if (h_ability)
    {
        Wait(0.08);
        SetSecondaryFireEnabled(player, false);
        SetAbility2Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Zenyatta"
    Event.OngoingPlayer
    Player.Zenyatta
    if (h_ability)
    {
        Wait(0.08);
        SetAbility2Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Moira"
    Event.OngoingPlayer
    Player.Moira
    if (h_ability)
    {
        Wait(0.08);
        SetSecondaryFireEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Torbjorn"
    Event.OngoingPlayer
    Player.Torbjorn
    if (h_ability)
    {
        Wait(0.08);
        SetAbility1Enabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Wrecking Ball"
    Event.OngoingPlayer
    Player.WreckingBall
    if (h_ability)
    {
        Wait(0.08);
        SetUltimateAbilityEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Bastion"
    Event.OngoingPlayer
    Player.Bastion
    if (h_ability)
    {
        Wait(0.08);
        SetPrimaryFireEnabled(player, false);
        h_ability = false;
    }

rule: "Abilities | Soldier"
    Event.OngoingPlayer
    Player.Soldier76
    if (h_ability)
    {
        Wait(0.08);
        SetSecondaryFireEnabled(player, false);
        SetUltimateAbilityEnabled(player, false);
        h_ability = false;
    }

/*
rule: "Host | End Match"
	Event.OngoingPlayer
    if (player == host && IsCrouching())
    {
        if (IsUltHeld() && IsInteractHeld() && (RoundToInteger(YOf(Facing()), Rounding.Nearest) == -1))
        {
            t_running = false;
            BigMessage(all, "Host ending match!");
            Wait(2.5);
            EnableAnnouncer();
            MinWait();
            DeclarePlayerVictory(null);
        }
    }*/


// playervar define findy;
// globalvar    define target;
// playervar define hostInvis;
// globalvar define invisIcon;

// rule: "Host | Invisibility"
//     Event.OngoingPlayer
//     if (player == host && IsUltHeld())
//     {
//         if (IsButtonHeld(player, Button.Crouch))
//         {
//             target = RayCastHitPlayer(EyePosition(), EyePosition() + (Facing() * 10), AllLivingPlayers(), player, false);

//             if (target != null)
//             {
//                 hostInvis = !hostInvis;

//                 if (hostInvis)
//                 {
//                     // if (target.safeMode == false)
//                     // {
//                     //     SetStatus(target, null, Status.PhasedOut, 9999);
//                     // }

//                     DestroyIcon(invisIcon);
//                     CreateIcon(host, EyePosition(target), Icon.Heart, IconRev.VisibleToAndPosition, Color.Red, true);
//                     invisIcon = LastCreatedEntity();
//                     SetInvisible(target, InvisibleTo.All);
//                     SmallMessage(target, "Invisibility On")
//                 }
//                 else
//                 {
//                     // if (target.safeMode == false)
//                     // {
//                     //     ClearStatus(target, Status.PhasedOut);
//                     // }


//                     DestroyIcon(invisIcon);
//                     SetInvisible(target, InvisibleTo.None);
//                     SmallMessage(target, "Invisibility Off")
//                 }
//             }
//         }
//     }

// rule: "lol"
//     Event.OngoingPlayer
//     if (player == host)
//     if (IsButtonHeld(player, Button.Crouch))
//     if (IsUltHeld())
//     {
//         if (IsButtonHeld(player, Button.Jump))
//         {
//             Communicate(AllLivingPlayers(), Communication.VoiceLineUp);
//         }
//     }

// rule: "lol"
//     Event.OngoingPlayer
//     if (player == host && findy && target != null)
//     {
//         if (target != null)
//         {
//             findy = true;
//             Teleport(player, PositionOf(target) + (Facing(target) * 1.5));
//         }
//         Wait(0.15);
//         LoopIfConditionIsTrue();
//     }

/*rule: "Healer Mode | Start Heal"
	Event.OnDamageDealt
    if (safeMode && HeroOf() == Hero.Ana)
    {
        StartHealOverTime(Victim(), player, 2.5, 400);
    }

rule: "Healer Mode | Healing Dealt"
    Event.OnHealingDealt
    if (!healEventCooldown)
    {
        healEventCooldown = true;

        if (c_score < 0)
            c_score += 10;
        else
            c_score += 2;

        Wait(2.5);
        healEventCooldown = false;
    }

rule: "Healer Mode | Text Change"
    Event.OngoingPlayer
    if (safeMode && HeroOf() == Hero.Ana)
    {
        CreateHudText(player, null, null, "Healer Mode Enabled (Chill Ana)", Location.Left, 1, Color.White, Color.White, Color.Green);
        healerModeText = LastTextID();
    }

rule: "Healer Mode | Text Reset"
    Event.OngoingPlayer
    if ((!safeMode && HeroOf() == Hero.Ana) || HeroOf() != Hero.Ana)
    {
        DestroyHudText(healerModeText); // should be status
    }*/

/*
rule: "Map Teleports | Temp Handler 1"
    Event.OngoingPlayer
    if (hasMapTeleports && !mapTeleportCooldown && (DistanceBetween(player, mapTeleportsIn[0]) < 1 || DistanceBetween(player, mapTeleportsIn[1]) < 1))
    {
        mapTeleportCooldown = true;
        prevAng = Facing();

        if (DistanceBetween(player, mapTeleportsIn[0]) < 1)
            Teleport(player, mapTeleportsOut[0]);
        else if (DistanceBetween(player, mapTeleportsIn[1]) < 1)
            Teleport(player, mapTeleportsOut[1]);

        SetFacing(prevAng);
        Wait(2);
        mapTeleportCooldown = false;
    }

rule: "Map Teleports | Temp Handler 2"
    Event.OngoingPlayer
    if (hasMapTeleports && !mapTeleportCooldown && (DistanceBetween(player, mapTeleportsOut[0]) < 1 || DistanceBetween(player, mapTeleportsOut[1]) < 1))
    {
        mapTeleportCooldown = true;
        prevAng = Facing();

        if (DistanceBetween(player, mapTeleportsOut[0]) < 1)
            Teleport(player, mapTeleportsIn[0]);
        else if (DistanceBetween(player, mapTeleportsOut[1]) < 1)
            Teleport(player, mapTeleportsIn[1]);

        SetFacing(prevAng);
        Wait(2);
        mapTeleportCooldown = false;
    }*/

/*rule: "Suicide Debug"
    Event.OngoingPlayer
    if (player == host && IsAlive() && IsButtonHeld(player, Button.Crouch))
    {
        Kill();
    }*/




/*
playervar define heavyScorty;
playervar define effect;
playervar define findy;
playervar define target;

rule: "Host | c"
    Event.OngoingPlayer
    if (player == host && IsUltHeld())
    {
        if (IsButtonHeld(player, Button.Crouch) && safeMode)
        {
            findy = !findy;

            if (findy)
                target = RayCastHitPlayer(EyePosition(), EyePosition() + (Facing() * 10), AllLivingPlayers(), player, false);

            // hostInvis = !hostInvis;

            // if (hostInvis)
            // {
            //     SetInvisible(player, InvisibleTo.All);
            //     SmallMessage(player, "Invisibility On")
            // }
            // else
            // {
            //     SetInvisible(player, InvisibleTo.None);
            //     SmallMessage(player, "Invisibility Off")
            // }
        }
    }


rule: "aaaa"
    Event.OngoingPlayer
    if (findy && player == host)
    {
        if (target != null)
        {
            ClearStatus(target, Status.Stunned);
            MinWait();
            SetStatus(target, null, Status.Stunned, RandomReal(0.05, 0.2));
            MinWait();
            SetStatus(target, null, Status.Hacked, RandomReal(0.05, 0.2));
            MinWait();
            SetStatus(target, null, Status.Burning, RandomReal(0.05, 0.2));
            MinWait();
            SetFacing(target, Vector(RandomReal(-1, 1), RandomReal(-1, 1), RandomReal(-1, 1)), Relative.ToWorld);
            MinWait();
            LoopIfConditionIsTrue();
        }
    }

rule: "aaaa"
    Event.OngoingPlayer
    if (findy && player == host)
    {
        if (target != null)
        {
            CreateEffect(all, Effect.Sphere, Color.Purple, EyePosition(target), 1, EffectRev.VisibleToPositionAndRadius);
            effect = LastCreatedEntity();
            Wait(0.1);
            DestroyEffect(effect);
            CreateEffect(all, Effect.Sphere, Color.Yellow, EyePosition(target), 1, EffectRev.VisibleToPositionAndRadius);
            effect = LastCreatedEntity();
            Wait(0.1);
            DestroyEffect(effect);
            CreateEffect(all, Effect.Sphere, Color.Green, EyePosition(target), 1, EffectRev.VisibleToPositionAndRadius);
            effect = LastCreatedEntity();
            Wait(0.1);
            DestroyEffect(effect);
            CreateEffect(all, Effect.Sphere, Color.Red, EyePosition(target), 1, EffectRev.VisibleToPositionAndRadius);
            effect = LastCreatedEntity();
            Wait(0.1);
            DestroyEffect(effect);
            CreateEffect(all, Effect.Sphere, Color.Blue, EyePosition(target), 1, EffectRev.VisibleToPositionAndRadius);
            effect = LastCreatedEntity();
            Wait(0.1);
            DestroyEffect(effect);
            LoopIfConditionIsTrue();
        }
    }

/*rule: "aaaa"
    Event.OngoingPlayer
    if (heavyScorty && player == host)
    {
        Communicate(player, Communication.VoiceLineUp);
        Wait(2.5);
        LoopIfConditionIsTrue();
    }*/
/* HELL END */

/*rule: "no scorty"
    Event.OngoingPlayer
    if (player == host && IsInLineOfSight(player, PlayersInSlot(0, OppositeTeamOf(TeamOf()))))
    {
        heavyScorty = true;
    }

rule: "scorty"
    Event.OngoingPlayer
    if (player == host && !IsInLineOfSight(player, PlayersInSlot(0, OppositeTeamOf(TeamOf()))))
    {
        heavyScorty = false;
    }*/

// rule: "Host | Pause Timer"
//     Event.OngoingPlayer
//     if (player == host)
//     if (IsUltHeld())
//     {
//         if (IsCrouching() && IsPrimaryHeld())
//         {
//             t_paused = !t_paused;
//         }
//     }

// globalvar define hostbuff;
// rule: "Host | buff toggle"
//     Event.OngoingPlayer
//     if (player == host)
//     if (IsUltHeld())
//     {
//         if (IsCrouching() && IsPrimaryHeld())
//         {
//             hostbuff = !hostbuff;
//         }
//     }

// rule: "Host | buff on"
//     Event.OngoingPlayer
//     if (player == host)
//     if (hostbuff)
//     {
//         SetDamageDealt(player, 300);
//         SetDamageReceived(player, 250);
//         SetMoveSpeed(player, 400);
//         SetProjectileSpeed(player, 250);
//         SmallMessage(host, "buff on");
//     }

// rule: "Host | buff on 2"
//     Event.OngoingPlayer
//     if (player == host)
//     if (hostbuff)
//     if (IsCrouching())
//     {
//         SetPrimaryFireEnabled(player, false);
//         SetSecondaryFireEnabled(player, false);

//         SetInvisible(player, InvisibleTo.All);
//     }

// rule: "Host | buff off 2"
//     Event.OngoingPlayer
//     if (player == host)
//     if (hostbuff)
//     if (IsCrouching() == false)
//     {
//         AllowPrimary();
//         AllowSecondary();
//         SetInvisible(player, InvisibleTo.None);
//     }

// rule: "Host | buff off"
//     Event.OngoingPlayer
//     if (player == host)
//     if (hostbuff == false)
//     {
//         SetDamageDealt(player, 100);
//         SetDamageReceived(player, 100);
//         SetMoveSpeed(player, 100);
//         SetProjectileSpeed(player, 100);
//         SmallMessage(host, "buff off");
//     }

// globalvar define tog;
// rule: "lolspam"
//     if (IsButtonHeld(host, Button.Crouch))
//     if (IsButtonHeld(host, Button.Jump))
//     if (IsButtonHeld(host, Button.SecondaryFire))
//     {
//         tog = !tog;

//         if (tog && host.safeMode)
//             SetUltimateAbilityEnabled(host, true);
//         else if (!tog && host.safeMode)
//             SetUltimateAbilityEnabled(host, false);
//     }

// rule: "lolspam"
//     if (tog)
//     {
//         SetUltimateCharge(host, 100);
//         MinWait();
//         PressButton(host, Button.Ultimate);
//         MinWait();
//         SetStatus(host, null, Status.Stunned, 0.016);
//         MinWait();
//         if (HeroOf(host) == Hero.Reinhardt)
//             Wait(0.44);
//         LoopIfConditionIsTrue();
//     }

// playervar define tog;

// rule: "lolspam"
//     Event.OngoingPlayer
//     if (IsButtonHeld(player, Button.Crouch))
//     if (IsButtonHeld(player, Button.Jump))
//     if (IsButtonHeld(player, Button.SecondaryFire))
//     {
//         tog = !tog;

//         if (tog && safeMode)
//             SetUltimateAbilityEnabled(player, true);
//         else if (!tog && safeMode)
//             SetUltimateAbilityEnabled(player, false);
//     }

// rule: "lolspam"
//     Event.OngoingPlayer
//     if (tog)
//     {
//         SetUltimateCharge(player, 100);
//         MinWait();
//         PressButton(player, Button.Ultimate);
//         MinWait();
//         SetStatus(player, null, Status.Stunned, 0.016);
//         if (HeroOf() == Hero.Reinhardt)
//             Wait(0.44);
//         else if (HeroOf() == Hero.Doomfist)
//             MinWait();
//         MinWait();

//         LoopIfConditionIsTrue();
//     }

// rule: "lolrein"
//     Event.OngoingPlayer
//     Player.Reinhardt
//     if (IsUsingAbility1())
//     {
//         SetDamageDealt(player, 20);
//         SetMoveSpeed(player, 1000);
//     }

// rule: "lolrein off"
//     Event.OngoingPlayer
//     Player.Reinhardt
//     if (IsUsingAbility1() == false)
//     {
//         SetDamageDealt(player, 100);
//         SetMoveSpeed(player, p_speed);
//     }

// rule: "lolrein cancel"
//     Event.OngoingPlayer
//     Player.Reinhardt
//     if (IsButtonHeld(player, Button.Reload))
//     if (IsUsingAbility1())
//     {
//         SetStatus(player, null, Status.Stunned, 0.1);
//     }

rule: "Host | Toggle Inspector"
    if (IsButtonHeld(host, Button.Reload))
    if (IsButtonHeld(host, Button.Melee))
    if (IsButtonHeld(host, Button.Interact))
    {
        inspector = !inspector;

        if (inspector)
        {
            SmallMessage(host, "Inspector disabled");
            DisableInspectorRecording();
        }
        else
        {
            SmallMessage(host, "Inspector enabled");
            EnableInspectorRecording();
        }
    }

rule: "Server Load"
    {
        //CreateHudText(host, null, null, AltitudeOf(host), Location.Top, -99);
        CreateHudText(host, null, null, <"(Server Load : <0>% / <1>% / <2>%)", ServerLoadAverage(), ServerLoad(), ServerLoadPeak()>, Location.Top, -100);
    }